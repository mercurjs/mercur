/**
 * Generated by orval v7.3.0 ðŸº
 * Do not edit manually.
 * Medusa API
 * OpenAPI spec version: 1.0.0
 */
import type {
  AdminApiKeyResponse,
  AdminBatchProductRequest,
  AdminBatchProductResponse,
  AdminBatchProductVariantRequest,
  AdminBatchProductVariantResponse,
  AdminCampaignResponse,
  AdminClaimDeleteResponse,
  AdminClaimListResponse,
  AdminClaimOrderResponse,
  AdminClaimPreviewResponse,
  AdminClaimRequestResponse,
  AdminClaimResponse,
  AdminClaimReturnPreviewResponse,
  AdminCollectionDeleteResponse,
  AdminCollectionListResponse,
  AdminCollectionResponse,
  AdminCreateApiKey,
  AdminCreateCollection,
  AdminCreateCustomerGroup,
  AdminCreateFulfillment,
  AdminCreateInventoryItem,
  AdminCreatePriceList,
  AdminCreatePricePreference,
  AdminCreateProductCategory,
  AdminCreateProductTag,
  AdminCreateProductType,
  AdminCreateRefundReason,
  AdminCreateRegion,
  AdminCreateReservation,
  AdminCreateReturnReason,
  AdminCreateSalesChannel,
  AdminCreateShipment,
  AdminCreateShippingOption,
  AdminCreateShippingProfile,
  AdminCreateStockLocation,
  AdminCreateTaxRate,
  AdminCreateTaxRateRule,
  AdminCreateTaxRegion,
  AdminCreateVariantInventoryItem,
  AdminCreateWorkflowsAsyncResponse,
  AdminCreateWorkflowsRun,
  AdminCurrencyListResponse,
  AdminCurrencyResponse,
  AdminCustomerAddressResponse,
  AdminCustomerGroupResponse,
  AdminCustomerResponse,
  AdminDeleteApiKeysId200,
  AdminDeleteCampaignsId200,
  AdminDeleteClaimsIdClaimItemsActionIdParams,
  AdminDeleteClaimsIdOutboundItemsActionIdParams,
  AdminDeleteClaimsIdOutboundShippingMethodActionIdParams,
  AdminDeleteCustomerGroupsId200,
  AdminDeleteCustomersId200,
  AdminDeleteCustomersIdAddressesAddressId200,
  AdminDeleteCustomersIdAddressesAddressIdParams,
  AdminDeleteExchangesIdOutboundItemsActionIdParams,
  AdminDeleteExchangesIdOutboundShippingMethodActionIdParams,
  AdminDeleteInventoryItemsId200,
  AdminDeleteInventoryItemsIdLocationLevelsLocationId200,
  AdminDeleteInventoryItemsIdLocationLevelsLocationIdParams,
  AdminDeleteInvitesId200,
  AdminDeleteOrderEditsId200,
  AdminDeletePaymentCollectionResponse,
  AdminDeleteProductsIdOptionsOptionIdParams,
  AdminDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams,
  AdminDeleteProductsIdVariantsVariantIdParams,
  AdminDeletePromotionsId200,
  AdminDeleteRefundReasonsId200,
  AdminDeleteRegionsId200,
  AdminDeleteReservationsId200,
  AdminDeleteReturnsIdDismissItemsActionIdParams,
  AdminDeleteReturnsIdReceive200,
  AdminDeleteReturnsIdReceiveItemsActionIdParams,
  AdminDeleteReturnsIdRequest200,
  AdminDeleteReturnsIdRequestItemsActionIdParams,
  AdminDeleteReturnsIdShippingMethodActionIdParams,
  AdminDeleteTaxRatesIdRulesRuleId200,
  AdminDeleteTaxRatesIdRulesRuleIdParams,
  AdminDeleteUploadsId200,
  AdminDraftOrderResponse,
  AdminExchangeDeleteResponse,
  AdminExchangeOrderResponse,
  AdminExchangePreviewResponse,
  AdminExchangeRequestResponse,
  AdminExchangeResponse,
  AdminExchangeReturnResponse,
  AdminExportProductResponse,
  AdminFileListResponse,
  AdminFileResponse,
  AdminFulfillmentProviderListResponse,
  AdminFulfillmentProviderOptionsListResponse,
  AdminFulfillmentResponse,
  AdminFulfillmentSetDeleteResponse,
  AdminFulfillmentSetResponse,
  AdminGetApiKeys200,
  AdminGetApiKeysIdParams,
  AdminGetApiKeysParams,
  AdminGetCampaigns200,
  AdminGetCampaignsIdParams,
  AdminGetCampaignsParams,
  AdminGetClaimsIdParams,
  AdminGetClaimsParams,
  AdminGetCollectionsIdParams,
  AdminGetCollectionsParams,
  AdminGetCurrenciesCodeParams,
  AdminGetCurrenciesParams,
  AdminGetCustomerGroups200,
  AdminGetCustomerGroupsIdParams,
  AdminGetCustomerGroupsParams,
  AdminGetCustomers200,
  AdminGetCustomersIdAddresses200,
  AdminGetCustomersIdAddressesAddressIdParams,
  AdminGetCustomersIdAddressesParams,
  AdminGetCustomersIdParams,
  AdminGetCustomersParams,
  AdminGetDraftOrders200,
  AdminGetDraftOrdersParams,
  AdminGetExchanges200,
  AdminGetExchangesIdParams,
  AdminGetExchangesParams,
  AdminGetFulfillmentProvidersParams,
  AdminGetFulfillmentSetsIdServiceZonesZoneIdParams,
  AdminGetInventoryItems200,
  AdminGetInventoryItemsIdLocationLevels200,
  AdminGetInventoryItemsIdLocationLevelsParams,
  AdminGetInventoryItemsIdParams,
  AdminGetInventoryItemsParams,
  AdminGetInvites200,
  AdminGetInvitesIdParams,
  AdminGetInvitesParams,
  AdminGetNotificationsIdParams,
  AdminGetNotificationsParams,
  AdminGetOrders200,
  AdminGetOrdersIdChangesParams,
  AdminGetOrdersIdLineItems200,
  AdminGetOrdersIdLineItemsParams,
  AdminGetOrdersIdParams,
  AdminGetOrdersParams,
  AdminGetPayments200,
  AdminGetPaymentsIdParams,
  AdminGetPaymentsParams,
  AdminGetPaymentsPaymentProviders200,
  AdminGetPaymentsPaymentProvidersParams,
  AdminGetPriceListsIdParams,
  AdminGetPriceListsParams,
  AdminGetPricePreferencesIdParams,
  AdminGetPricePreferencesParams,
  AdminGetProductCategoriesIdParams,
  AdminGetProductCategoriesParams,
  AdminGetProductTagsIdParams,
  AdminGetProductTagsParams,
  AdminGetProductTypesIdParams,
  AdminGetProductTypesParams,
  AdminGetProductVariants200,
  AdminGetProductVariantsParams,
  AdminGetProducts200,
  AdminGetProductsIdOptions200,
  AdminGetProductsIdOptionsOptionIdParams,
  AdminGetProductsIdOptionsParams,
  AdminGetProductsIdParams,
  AdminGetProductsIdVariants200,
  AdminGetProductsIdVariantsParams,
  AdminGetProductsIdVariantsVariantIdParams,
  AdminGetProductsParams,
  AdminGetPromotions200,
  AdminGetPromotionsIdParams,
  AdminGetPromotionsIdRuleType200,
  AdminGetPromotionsIdRuleTypeParams,
  AdminGetPromotionsParams,
  AdminGetPromotionsRuleAttributeOptionsRuleType200,
  AdminGetPromotionsRuleAttributeOptionsRuleTypeParams,
  AdminGetPromotionsRuleValueOptionsRuleTypeRuleAttributeId200,
  AdminGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParams,
  AdminGetRefundReasons200,
  AdminGetRefundReasonsIdParams,
  AdminGetRefundReasonsParams,
  AdminGetRegions200,
  AdminGetRegionsIdParams,
  AdminGetRegionsParams,
  AdminGetReservations200,
  AdminGetReservationsIdParams,
  AdminGetReservationsParams,
  AdminGetReturnReasonsIdParams,
  AdminGetReturnReasonsParams,
  AdminGetReturns200,
  AdminGetReturnsIdParams,
  AdminGetReturnsParams,
  AdminGetSalesChannels200,
  AdminGetSalesChannelsIdParams,
  AdminGetSalesChannelsParams,
  AdminGetShippingOptions200,
  AdminGetShippingOptionsIdParams,
  AdminGetShippingOptionsParams,
  AdminGetShippingProfiles200,
  AdminGetShippingProfilesIdParams,
  AdminGetShippingProfilesParams,
  AdminGetStockLocationsIdParams,
  AdminGetStockLocationsParams,
  AdminGetStoresIdParams,
  AdminGetStoresParams,
  AdminGetTaxRates200,
  AdminGetTaxRatesIdParams,
  AdminGetTaxRatesParams,
  AdminGetTaxRegions200,
  AdminGetTaxRegionsIdParams,
  AdminGetTaxRegionsParams,
  AdminGetUploadsIdParams,
  AdminGetUsersIdParams,
  AdminGetUsersMeParams,
  AdminGetUsersParams,
  AdminGetWorkflowsExecutions200,
  AdminGetWorkflowsExecutionsIdParams,
  AdminGetWorkflowsExecutionsParams,
  AdminGetWorkflowsExecutionsWorkflowIdTransactionIdParams,
  AdminImportProductRequest,
  AdminImportProductResponse,
  AdminInventoryItemResponse,
  AdminInviteResponse,
  AdminLinkPriceListProducts,
  AdminNotificationListResponse,
  AdminNotificationResponse,
  AdminOrderChangesResponse,
  AdminOrderEditPreviewResponse,
  AdminOrderEditResponse,
  AdminOrderPreviewResponse,
  AdminOrderResponse,
  AdminOrderReturnResponse,
  AdminPaymentCollectionResponse,
  AdminPaymentResponse,
  AdminPostActorTypeAuthProvider200,
  AdminPostActorTypeAuthProviderBody,
  AdminPostActorTypeAuthProviderRegisterBody,
  AdminPostActorTypeAuthProviderResetPasswordBody,
  AdminPostActorTypeAuthProviderUpdate200,
  AdminPostActorTypeAuthProviderUpdateBody,
  AdminPostActorTypeAuthProviderUpdateParams,
  AdminPostApiKeysIdParams,
  AdminPostApiKeysIdRevokeParams,
  AdminPostApiKeysIdSalesChannelsBody,
  AdminPostApiKeysIdSalesChannelsParams,
  AdminPostCampaignsBody,
  AdminPostCampaignsIdBody,
  AdminPostCampaignsIdParams,
  AdminPostCampaignsIdPromotionsBody,
  AdminPostCampaignsIdPromotionsParams,
  AdminPostCampaignsParams,
  AdminPostCancelClaimReqSchema,
  AdminPostCancelExchangeReqSchema,
  AdminPostCancelReturnReqSchema,
  AdminPostClaimItemsReqSchema,
  AdminPostClaimsAddItemsReqSchema,
  AdminPostClaimsIdClaimItemsActionIdParams,
  AdminPostClaimsIdClaimItemsParams,
  AdminPostClaimsIdInboundShippingMethodActionIdParams,
  AdminPostClaimsIdOutboundItemsActionIdParams,
  AdminPostClaimsIdOutboundItemsParams,
  AdminPostClaimsIdOutboundShippingMethodActionIdParams,
  AdminPostClaimsIdOutboundShippingMethodParams,
  AdminPostClaimsIdRequestParams,
  AdminPostClaimsItemsActionReqSchema,
  AdminPostClaimsParams,
  AdminPostClaimsShippingActionReqSchema,
  AdminPostClaimsShippingReqSchema,
  AdminPostCollectionsIdParams,
  AdminPostCollectionsIdProductsBody,
  AdminPostCollectionsIdProductsParams,
  AdminPostCollectionsParams,
  AdminPostCustomerGroupsIdCustomersBody,
  AdminPostCustomerGroupsIdCustomersParams,
  AdminPostCustomerGroupsIdParams,
  AdminPostCustomerGroupsParams,
  AdminPostCustomersBody,
  AdminPostCustomersIdAddressesAddressIdBody,
  AdminPostCustomersIdAddressesAddressIdParams,
  AdminPostCustomersIdAddressesBody,
  AdminPostCustomersIdAddressesParams,
  AdminPostCustomersIdBody,
  AdminPostCustomersIdCustomerGroupsBody,
  AdminPostCustomersIdCustomerGroupsParams,
  AdminPostCustomersIdParams,
  AdminPostCustomersParams,
  AdminPostDraftOrdersBody,
  AdminPostDraftOrdersParams,
  AdminPostExchangesAddItemsReqSchema,
  AdminPostExchangesIdInboundShippingMethodActionIdParams,
  AdminPostExchangesIdOutboundItemsActionIdParams,
  AdminPostExchangesIdOutboundItemsParams,
  AdminPostExchangesIdOutboundShippingMethodActionIdParams,
  AdminPostExchangesIdOutboundShippingMethodParams,
  AdminPostExchangesIdRequestParams,
  AdminPostExchangesItemsActionReqSchema,
  AdminPostExchangesParams,
  AdminPostExchangesRequestItemsReturnActionReqSchema,
  AdminPostExchangesReturnRequestItemsReqSchema,
  AdminPostExchangesShippingActionReqSchema,
  AdminPostExchangesShippingReqSchema,
  AdminPostFulfillmentSetsIdServiceZonesBody,
  AdminPostFulfillmentSetsIdServiceZonesParams,
  AdminPostFulfillmentSetsIdServiceZonesZoneIdBody,
  AdminPostFulfillmentSetsIdServiceZonesZoneIdParams,
  AdminPostFulfillmentsIdCancelParams,
  AdminPostFulfillmentsIdShipmentParams,
  AdminPostFulfillmentsParams,
  AdminPostInventoryItemsIdBody,
  AdminPostInventoryItemsIdLocationLevelsBatch200,
  AdminPostInventoryItemsIdLocationLevelsBatchBody,
  AdminPostInventoryItemsIdLocationLevelsBody,
  AdminPostInventoryItemsIdLocationLevelsLocationIdBody,
  AdminPostInventoryItemsIdLocationLevelsLocationIdParams,
  AdminPostInventoryItemsIdLocationLevelsParams,
  AdminPostInventoryItemsIdParams,
  AdminPostInventoryItemsParams,
  AdminPostInvitesAccept200,
  AdminPostInvitesAcceptBody,
  AdminPostInvitesBody,
  AdminPostInvitesIdResendParams,
  AdminPostInvitesParams,
  AdminPostOrderClaimsReqSchema,
  AdminPostOrderEditsAddItemsReqSchema,
  AdminPostOrderEditsItemsActionReqSchema,
  AdminPostOrderEditsReqSchema,
  AdminPostOrderEditsShippingActionReqSchema,
  AdminPostOrderEditsShippingReqSchema,
  AdminPostOrderEditsUpdateItemQuantityReqSchema,
  AdminPostOrderExchangesReqSchema,
  AdminPostOrdersIdArchiveParams,
  AdminPostOrdersIdCancelParams,
  AdminPostOrdersIdCompleteBody,
  AdminPostOrdersIdCompleteParams,
  AdminPostOrdersIdFulfillmentsBody,
  AdminPostOrdersIdFulfillmentsFulfillmentIdCancelBody,
  AdminPostOrdersIdFulfillmentsFulfillmentIdCancelParams,
  AdminPostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredParams,
  AdminPostOrdersIdFulfillmentsFulfillmentIdShipmentsBody,
  AdminPostOrdersIdFulfillmentsFulfillmentIdShipmentsParams,
  AdminPostOrdersIdFulfillmentsParams,
  AdminPostOrdersIdParams,
  AdminPostOrdersIdTransferCancelParams,
  AdminPostOrdersIdTransferParams,
  AdminPostPaymentCollectionsBody,
  AdminPostPaymentCollectionsIdMarkAsPaidBody,
  AdminPostPaymentCollectionsIdMarkAsPaidParams,
  AdminPostPaymentCollectionsParams,
  AdminPostPaymentsIdCaptureBody,
  AdminPostPaymentsIdCaptureParams,
  AdminPostPaymentsIdRefundBody,
  AdminPostPaymentsIdRefundParams,
  AdminPostPriceListsIdParams,
  AdminPostPriceListsIdPricesBatchBody,
  AdminPostPriceListsIdProductsParams,
  AdminPostPriceListsParams,
  AdminPostPricePreferencesIdParams,
  AdminPostPricePreferencesParams,
  AdminPostProductCategoriesIdBody,
  AdminPostProductCategoriesIdParams,
  AdminPostProductCategoriesIdProductsBody,
  AdminPostProductCategoriesIdProductsParams,
  AdminPostProductCategoriesParams,
  AdminPostProductTagsIdBody,
  AdminPostProductTagsIdParams,
  AdminPostProductTagsParams,
  AdminPostProductTypesIdBody,
  AdminPostProductTypesIdParams,
  AdminPostProductTypesParams,
  AdminPostProductsBatchParams,
  AdminPostProductsBody,
  AdminPostProductsExportParams,
  AdminPostProductsIdBody,
  AdminPostProductsIdOptionsBody,
  AdminPostProductsIdOptionsOptionIdBody,
  AdminPostProductsIdOptionsOptionIdParams,
  AdminPostProductsIdOptionsParams,
  AdminPostProductsIdParams,
  AdminPostProductsIdVariantsBatchParams,
  AdminPostProductsIdVariantsBody,
  AdminPostProductsIdVariantsInventoryItemsBatchBody,
  AdminPostProductsIdVariantsParams,
  AdminPostProductsIdVariantsVariantIdBody,
  AdminPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams,
  AdminPostProductsIdVariantsVariantIdInventoryItemsParams,
  AdminPostProductsIdVariantsVariantIdParams,
  AdminPostProductsParams,
  AdminPostPromotionsBody,
  AdminPostPromotionsIdBody,
  AdminPostPromotionsIdBuyRulesBatch200,
  AdminPostPromotionsIdBuyRulesBatchBody,
  AdminPostPromotionsIdBuyRulesBatchParams,
  AdminPostPromotionsIdParams,
  AdminPostPromotionsIdRulesBatch200,
  AdminPostPromotionsIdRulesBatchBody,
  AdminPostPromotionsIdRulesBatchParams,
  AdminPostPromotionsIdTargetRulesBatch200,
  AdminPostPromotionsIdTargetRulesBatchBody,
  AdminPostPromotionsIdTargetRulesBatchParams,
  AdminPostPromotionsParams,
  AdminPostReceiveReturnsReqSchema,
  AdminPostRefundReasonsIdBody,
  AdminPostRefundReasonsIdParams,
  AdminPostRefundReasonsParams,
  AdminPostRegionsIdBody,
  AdminPostRegionsIdParams,
  AdminPostRegionsParams,
  AdminPostReservationsIdBody,
  AdminPostReservationsIdParams,
  AdminPostReservationsParams,
  AdminPostReturnReasonsIdParams,
  AdminPostReturnReasonsParams,
  AdminPostReturnsConfirmRequestReqSchema,
  AdminPostReturnsDismissItemsActionReqSchema,
  AdminPostReturnsIdDismissItemsActionIdParams,
  AdminPostReturnsIdDismissItemsParams,
  AdminPostReturnsIdParams,
  AdminPostReturnsIdReceiveConfirmParams,
  AdminPostReturnsIdReceiveItemsActionIdParams,
  AdminPostReturnsIdReceiveItemsParams,
  AdminPostReturnsIdReceiveParams,
  AdminPostReturnsIdRequestItemsActionIdParams,
  AdminPostReturnsIdRequestItemsParams,
  AdminPostReturnsIdRequestParams,
  AdminPostReturnsIdShippingMethodActionIdParams,
  AdminPostReturnsIdShippingMethodParams,
  AdminPostReturnsParams,
  AdminPostReturnsReceiveItemsActionReqSchema,
  AdminPostReturnsReceiveItemsReqSchema,
  AdminPostReturnsReqSchema,
  AdminPostReturnsRequestItemsActionReqSchema,
  AdminPostReturnsRequestItemsReqSchema,
  AdminPostReturnsReturnReqSchema,
  AdminPostReturnsShippingActionReqSchema,
  AdminPostReturnsShippingReqSchema,
  AdminPostSalesChannelsIdParams,
  AdminPostSalesChannelsIdProductsBody,
  AdminPostSalesChannelsIdProductsParams,
  AdminPostSalesChannelsParams,
  AdminPostShippingOptionsIdBody,
  AdminPostShippingOptionsIdParams,
  AdminPostShippingOptionsIdRulesBatch200,
  AdminPostShippingOptionsIdRulesBatchBody,
  AdminPostShippingOptionsIdRulesBatchParams,
  AdminPostShippingOptionsParams,
  AdminPostShippingProfilesIdBody,
  AdminPostShippingProfilesIdParams,
  AdminPostShippingProfilesParams,
  AdminPostStockLocationsIdFulfillmentProvidersBody,
  AdminPostStockLocationsIdFulfillmentProvidersParams,
  AdminPostStockLocationsIdFulfillmentSetsBody,
  AdminPostStockLocationsIdFulfillmentSetsParams,
  AdminPostStockLocationsIdParams,
  AdminPostStockLocationsIdSalesChannelsBody,
  AdminPostStockLocationsIdSalesChannelsParams,
  AdminPostStockLocationsParams,
  AdminPostStoresIdParams,
  AdminPostTaxRatesIdParams,
  AdminPostTaxRatesIdRulesParams,
  AdminPostTaxRatesParams,
  AdminPostTaxRegionsIdParams,
  AdminPostTaxRegionsParams,
  AdminPostUploadsBody,
  AdminPostUsersIdParams,
  AdminPostWorkflowsExecutionsWorkflowIdRun200,
  AdminPostWorkflowsExecutionsWorkflowIdStepsFailure200,
  AdminPostWorkflowsExecutionsWorkflowIdStepsSuccess200,
  AdminPriceListBatchResponse,
  AdminPriceListDeleteResponse,
  AdminPriceListListResponse,
  AdminPriceListResponse,
  AdminPricePreferenceDeleteResponse,
  AdminPricePreferenceListResponse,
  AdminPricePreferenceResponse,
  AdminProductCategoryDeleteResponse,
  AdminProductCategoryListResponse,
  AdminProductCategoryResponse,
  AdminProductDeleteResponse,
  AdminProductOptionDeleteResponse,
  AdminProductOptionResponse,
  AdminProductResponse,
  AdminProductTagDeleteResponse,
  AdminProductTagListResponse,
  AdminProductTagResponse,
  AdminProductTypeDeleteResponse,
  AdminProductTypeListResponse,
  AdminProductTypeResponse,
  AdminProductVariantDeleteResponse,
  AdminProductVariantInventoryBatchResponse,
  AdminProductVariantInventoryLinkDeleteResponse,
  AdminProductVariantResponse,
  AdminPromotionResponse,
  AdminRegionResponse,
  AdminReservationResponse,
  AdminReturnPreviewResponse,
  AdminReturnReasonDeleteResponse,
  AdminReturnReasonListResponse,
  AdminReturnReasonResponse,
  AdminReturnResponse,
  AdminRevokeApiKey,
  AdminSalesChannelDeleteResponse,
  AdminSalesChannelResponse,
  AdminServiceZoneDeleteResponse,
  AdminServiceZoneResponse,
  AdminShippingOptionDeleteResponse,
  AdminShippingOptionResponse,
  AdminShippingProfileDeleteResponse,
  AdminShippingProfileResponse,
  AdminStockLocationDeleteResponse,
  AdminStockLocationListResponse,
  AdminStockLocationResponse,
  AdminStoreListResponse,
  AdminStoreResponse,
  AdminTaxRateDeleteResponse,
  AdminTaxRateResponse,
  AdminTaxRegionDeleteResponse,
  AdminTaxRegionResponse,
  AdminTransferOrder,
  AdminUpdateApiKey,
  AdminUpdateCollection,
  AdminUpdateCustomerGroup,
  AdminUpdateOrder,
  AdminUpdatePriceList,
  AdminUpdatePricePreference,
  AdminUpdateReturnReason,
  AdminUpdateSalesChannel,
  AdminUpdateStockLocation,
  AdminUpdateStore,
  AdminUpdateTaxRate,
  AdminUpdateTaxRegion,
  AdminUpdateUser,
  AdminUpdateVariantInventoryItem,
  AdminUserDeleteResponse,
  AdminUserListResponse,
  AdminUserResponse,
  AdminWorkflowExecutionResponse,
  AuthResponse,
  AuthStoreSessionResponse,
  PostSellerTypeAuthProvider200,
  PostSellerTypeAuthProviderBody,
  PostSellerTypeAuthProviderRegisterBody,
  RefundReasonResponse,
  StoreAcceptOrderTransfer,
  StoreAddCartLineItem,
  StoreCartResponse,
  StoreCollectionResponse,
  StoreCreateCustomer,
  StoreCreatePaymentCollection,
  StoreCreateReturn,
  StoreCurrencyListResponse,
  StoreCurrencyResponse,
  StoreCustomerAddressListResponse,
  StoreCustomerAddressResponse,
  StoreCustomerResponse,
  StoreDeclineOrderTransferRequest,
  StoreDeleteCartsIdLineItemsLineId200,
  StoreDeleteCartsIdLineItemsLineIdParams,
  StoreDeleteCartsIdPromotions200,
  StoreDeleteCartsIdPromotionsParams,
  StoreDeleteCustomersMeAddressesAddressId200,
  StoreDeleteCustomersMeAddressesAddressIdParams,
  StoreDeleteSession200,
  StoreGetCartsIdParams,
  StoreGetCollections200,
  StoreGetCollectionsIdParams,
  StoreGetCollectionsParams,
  StoreGetCurrenciesCodeParams,
  StoreGetCurrenciesParams,
  StoreGetCustomersMeAddressesAddressIdParams,
  StoreGetCustomersMeAddressesParams,
  StoreGetCustomersMeParams,
  StoreGetOrders200,
  StoreGetOrdersIdParams,
  StoreGetOrdersParams,
  StoreGetPaymentProviders200,
  StoreGetPaymentProvidersParams,
  StoreGetProductCategoriesIdParams,
  StoreGetProductCategoriesParams,
  StoreGetProducts200,
  StoreGetProductsIdParams,
  StoreGetProductsParams,
  StoreGetRegions200,
  StoreGetRegionsId200,
  StoreGetRegionsIdParams,
  StoreGetRegionsParams,
  StoreGetReturnReasons200,
  StoreGetReturnReasonsIdParams,
  StoreGetReturnReasonsParams,
  StoreGetShippingOptionsParams,
  StoreInitializePaymentSession,
  StoreOrderResponse,
  StorePaymentCollectionResponse,
  StorePostActorTypeAuthProvider200,
  StorePostActorTypeAuthProviderBody,
  StorePostActorTypeAuthProviderRegisterBody,
  StorePostActorTypeAuthProviderResetPasswordBody,
  StorePostActorTypeAuthProviderUpdate200,
  StorePostActorTypeAuthProviderUpdateBody,
  StorePostActorTypeAuthProviderUpdateParams,
  StorePostCartsBody,
  StorePostCartsId200,
  StorePostCartsIdBody,
  StorePostCartsIdComplete200,
  StorePostCartsIdCompleteParams,
  StorePostCartsIdCustomerParams,
  StorePostCartsIdLineItemsLineIdParams,
  StorePostCartsIdLineItemsParams,
  StorePostCartsIdParams,
  StorePostCartsIdPromotionsBody,
  StorePostCartsIdPromotionsParams,
  StorePostCartsIdShippingMethodsBody,
  StorePostCartsIdShippingMethodsParams,
  StorePostCartsIdTaxesParams,
  StorePostCartsParams,
  StorePostCustomersMeAddressesAddressIdBody,
  StorePostCustomersMeAddressesAddressIdParams,
  StorePostCustomersMeAddressesBody,
  StorePostCustomersMeAddressesParams,
  StorePostCustomersMeParams,
  StorePostCustomersParams,
  StorePostOrdersIdTransferAcceptParams,
  StorePostOrdersIdTransferCancelParams,
  StorePostOrdersIdTransferDeclineParams,
  StorePostOrdersIdTransferRequestParams,
  StorePostPaymentCollectionsIdPaymentSessionsParams,
  StorePostPaymentCollectionsParams,
  StorePostShippingOptionsIdCalculateBody,
  StorePostShippingOptionsIdCalculateParams,
  StoreProductCategoryListResponse,
  StoreProductCategoryResponse,
  StoreProductResponse,
  StoreRequestOrderTransfer,
  StoreReturnReasonResponse,
  StoreReturnResponse,
  StoreShippingOptionListResponse,
  StoreShippingOptionResponse,
  StoreUpdateCartLineItem,
  StoreUpdateCustomer,
  VendorAcceptInvite200,
  VendorAcceptMemberInvite,
  VendorCancelOrder200,
  VendorCompleteOrder200,
  VendorCreateFulfillment,
  VendorCreateFulfillment200,
  VendorCreateInventoryLevel,
  VendorCreateInvite201,
  VendorCreateOnboarding,
  VendorCreateOnboarding200,
  VendorCreatePayoutAccount,
  VendorCreatePayoutAccount201,
  VendorCreateProduct,
  VendorCreateProduct201,
  VendorCreateSeller,
  VendorCreateSeller201,
  VendorCreateServiceZone,
  VendorCreateServiceZone200,
  VendorCreateShippingOption,
  VendorCreateShippingOption201,
  VendorCreateStockLocation,
  VendorCreateStockLocation201,
  VendorCreateStockLocationFulfillmentSet,
  VendorCreateStockLocationFulfillmentSet200,
  VendorCreateStockLocationFulfillmentSetParams,
  VendorCreateStockLocationParams,
  VendorDeleteFulfillmentSet200,
  VendorDeleteMemberById200,
  VendorDeleteProductById200,
  VendorDeleteServiceZoneById200,
  VendorDeleteShippingOptionById200,
  VendorGetMemberById200,
  VendorGetMemberMe200,
  VendorGetOrder200,
  VendorGetPayoutAccount200,
  VendorGetPayoutAccountParams,
  VendorGetProductById200,
  VendorGetProductByIdParams,
  VendorGetSellerMe200,
  VendorGetShippingOptionById200,
  VendorGetStockLocation200,
  VendorGetStockLocationParams,
  VendorInviteMember,
  VendorListInvites200,
  VendorListInvitesParams,
  VendorListMembers200,
  VendorListMembersParams,
  VendorListOrders200,
  VendorListOrdersParams,
  VendorListProducts200,
  VendorListProductsParams,
  VendorListShippingOptions200,
  VendorListStockLocations200,
  VendorListStockLocationsParams,
  VendorUpdateInventoryItem,
  VendorUpdateInventoryLevel,
  VendorUpdateMember,
  VendorUpdateMemberById200,
  VendorUpdateProduct,
  VendorUpdateProductById200,
  VendorUpdateProductByIdParams,
  VendorUpdateSeller,
  VendorUpdateSellerMe200,
  VendorUpdateServiceZone,
  VendorUpdateServiceZoneById200,
  VendorUpdateShippingOption,
  VendorUpdateShippingOptionById200,
  VendorUpdateStockLocation,
  VendorUpdateStockLocation200,
  VendorUpdateStockLocationFulfillmentProviders200,
  VendorUpdateStockLocationFulfillmentProvidersBody,
  VendorUpdateStockLocationFulfillmentProvidersParams,
  VendorUpdateStockLocationParams,
  VendorUpdateStockLocationSalesChannels200,
  VendorUpdateStockLocationSalesChannelsBody,
  VendorUpdateStockLocationSalesChannelsParams
} from './types'
import { customFetch } from '../src/index';


/**
 * Retrieve a list of API keys. The API keys can be filtered by fields such as `id`. The API keys can also be sorted or paginated.
 * @summary List API Keys
 */
export type adminGetApiKeysResponse = {
  data: AdminGetApiKeys200;
  status: number;
  headers: Headers;
}

export const getAdminGetApiKeysUrl = (params?: AdminGetApiKeysParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/api-keys?${normalizedParams.toString()}` : `http://localhost:9000/admin/api-keys`
}

export const adminGetApiKeys = async (params?: AdminGetApiKeysParams, options?: RequestInit): Promise<adminGetApiKeysResponse> => {
  
  return customFetch<Promise<adminGetApiKeysResponse>>(getAdminGetApiKeysUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a secret or publishable API key.
A secret API key is used for admin authentication.

A publishable API key is used by client applications to set the scope of the request.

 * @summary Create Api Key
 */
export type adminPostApiKeysResponse = {
  data: AdminApiKeyResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostApiKeysUrl = () => {


  return `http://localhost:9000/admin/api-keys`
}

export const adminPostApiKeys = async (adminCreateApiKey: AdminCreateApiKey, options?: RequestInit): Promise<adminPostApiKeysResponse> => {
  
  return customFetch<Promise<adminPostApiKeysResponse>>(getAdminPostApiKeysUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateApiKey,)
  }
);}



/**
 * Retrieve an API key by its ID. You can expand the API key's relations or select the fields that should be returned using the query parameters.
 * @summary Get API Key
 */
export type adminGetApiKeysIdResponse = {
  data: AdminApiKeyResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetApiKeysIdUrl = (id: string,
    params?: AdminGetApiKeysIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/api-keys/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/api-keys/${id}`
}

export const adminGetApiKeysId = async (id: string,
    params?: AdminGetApiKeysIdParams, options?: RequestInit): Promise<adminGetApiKeysIdResponse> => {
  
  return customFetch<Promise<adminGetApiKeysIdResponse>>(getAdminGetApiKeysIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update an API key's details.
 * @summary Update an API Key
 */
export type adminPostApiKeysIdResponse = {
  data: AdminApiKeyResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostApiKeysIdUrl = (id: string,
    params?: AdminPostApiKeysIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/api-keys/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/api-keys/${id}`
}

export const adminPostApiKeysId = async (id: string,
    adminUpdateApiKey: AdminUpdateApiKey,
    params?: AdminPostApiKeysIdParams, options?: RequestInit): Promise<adminPostApiKeysIdResponse> => {
  
  return customFetch<Promise<adminPostApiKeysIdResponse>>(getAdminPostApiKeysIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateApiKey,)
  }
);}



/**
 * Delete a publishable or secret API key.

 * @summary Delete an Api Key
 */
export type adminDeleteApiKeysIdResponse = {
  data: AdminDeleteApiKeysId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteApiKeysIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/api-keys/${id}`
}

export const adminDeleteApiKeysId = async (id: string, options?: RequestInit): Promise<adminDeleteApiKeysIdResponse> => {
  
  return customFetch<Promise<adminDeleteApiKeysIdResponse>>(getAdminDeleteApiKeysIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Revokes an API key. If the API key is a secret, it can't be used for authentication anymore. If it's publishable, it can't be used by client applications.

 * @summary Revoke API Key
 */
export type adminPostApiKeysIdRevokeResponse = {
  data: AdminApiKeyResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostApiKeysIdRevokeUrl = (id: string,
    params?: AdminPostApiKeysIdRevokeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/api-keys/${id}/revoke?${normalizedParams.toString()}` : `http://localhost:9000/admin/api-keys/${id}/revoke`
}

export const adminPostApiKeysIdRevoke = async (id: string,
    adminRevokeApiKey: AdminRevokeApiKey,
    params?: AdminPostApiKeysIdRevokeParams, options?: RequestInit): Promise<adminPostApiKeysIdRevokeResponse> => {
  
  return customFetch<Promise<adminPostApiKeysIdRevokeResponse>>(getAdminPostApiKeysIdRevokeUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminRevokeApiKey,)
  }
);}



/**
 * Manage the sales channels of a publishable API key, either to associate them or remove them from the API key.
 * @summary Manage Sales Channels of a Publishable API Key
 */
export type adminPostApiKeysIdSalesChannelsResponse = {
  data: AdminApiKeyResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostApiKeysIdSalesChannelsUrl = (id: string,
    params?: AdminPostApiKeysIdSalesChannelsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/api-keys/${id}/sales-channels?${normalizedParams.toString()}` : `http://localhost:9000/admin/api-keys/${id}/sales-channels`
}

export const adminPostApiKeysIdSalesChannels = async (id: string,
    adminPostApiKeysIdSalesChannelsBody: AdminPostApiKeysIdSalesChannelsBody,
    params?: AdminPostApiKeysIdSalesChannelsParams, options?: RequestInit): Promise<adminPostApiKeysIdSalesChannelsResponse> => {
  
  return customFetch<Promise<adminPostApiKeysIdSalesChannelsResponse>>(getAdminPostApiKeysIdSalesChannelsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostApiKeysIdSalesChannelsBody,)
  }
);}



/**
 * Retrieve a list of campaigns. The campaigns can be filtered by fields such as `id`. The campaigns can also be sorted or paginated.
 * @summary List Campaigns
 */
export type adminGetCampaignsResponse = {
  data: AdminGetCampaigns200;
  status: number;
  headers: Headers;
}

export const getAdminGetCampaignsUrl = (params?: AdminGetCampaignsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/campaigns?${normalizedParams.toString()}` : `http://localhost:9000/admin/campaigns`
}

export const adminGetCampaigns = async (params?: AdminGetCampaignsParams, options?: RequestInit): Promise<adminGetCampaignsResponse> => {
  
  return customFetch<Promise<adminGetCampaignsResponse>>(getAdminGetCampaignsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a campaign.
 * @summary Create Campaign
 */
export type adminPostCampaignsResponse = {
  data: AdminCampaignResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCampaignsUrl = (params?: AdminPostCampaignsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/campaigns?${normalizedParams.toString()}` : `http://localhost:9000/admin/campaigns`
}

export const adminPostCampaigns = async (adminPostCampaignsBody: AdminPostCampaignsBody,
    params?: AdminPostCampaignsParams, options?: RequestInit): Promise<adminPostCampaignsResponse> => {
  
  return customFetch<Promise<adminPostCampaignsResponse>>(getAdminPostCampaignsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCampaignsBody,)
  }
);}



/**
 * Retrieve a campaign by its ID. You can expand the campaign's relations or select the fields that should be returned using the query parameters.
 * @summary Get a Campaign
 */
export type adminGetCampaignsIdResponse = {
  data: AdminCampaignResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetCampaignsIdUrl = (id: string,
    params?: AdminGetCampaignsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/campaigns/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/campaigns/${id}`
}

export const adminGetCampaignsId = async (id: string,
    params?: AdminGetCampaignsIdParams, options?: RequestInit): Promise<adminGetCampaignsIdResponse> => {
  
  return customFetch<Promise<adminGetCampaignsIdResponse>>(getAdminGetCampaignsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a campaign's details.
 * @summary Update a Campaign
 */
export type adminPostCampaignsIdResponse = {
  data: AdminCampaignResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCampaignsIdUrl = (id: string,
    params?: AdminPostCampaignsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/campaigns/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/campaigns/${id}`
}

export const adminPostCampaignsId = async (id: string,
    adminPostCampaignsIdBody: AdminPostCampaignsIdBody,
    params?: AdminPostCampaignsIdParams, options?: RequestInit): Promise<adminPostCampaignsIdResponse> => {
  
  return customFetch<Promise<adminPostCampaignsIdResponse>>(getAdminPostCampaignsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCampaignsIdBody,)
  }
);}



/**
 * Delete a campaign by its ID. This doesn't delete promotions that belong to this campaign.

 * @summary Delete a Campaign
 */
export type adminDeleteCampaignsIdResponse = {
  data: AdminDeleteCampaignsId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteCampaignsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/campaigns/${id}`
}

export const adminDeleteCampaignsId = async (id: string, options?: RequestInit): Promise<adminDeleteCampaignsIdResponse> => {
  
  return customFetch<Promise<adminDeleteCampaignsIdResponse>>(getAdminDeleteCampaignsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Manage the promotions of a campaign, either by adding them or removing them from the campaign.
 * @summary Manage the Promotions of a Campaign
 */
export type adminPostCampaignsIdPromotionsResponse = {
  data: AdminCampaignResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCampaignsIdPromotionsUrl = (id: string,
    params?: AdminPostCampaignsIdPromotionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/campaigns/${id}/promotions?${normalizedParams.toString()}` : `http://localhost:9000/admin/campaigns/${id}/promotions`
}

export const adminPostCampaignsIdPromotions = async (id: string,
    adminPostCampaignsIdPromotionsBody: AdminPostCampaignsIdPromotionsBody,
    params?: AdminPostCampaignsIdPromotionsParams, options?: RequestInit): Promise<adminPostCampaignsIdPromotionsResponse> => {
  
  return customFetch<Promise<adminPostCampaignsIdPromotionsResponse>>(getAdminPostCampaignsIdPromotionsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCampaignsIdPromotionsBody,)
  }
);}



/**
 * Retrieve a list of claims. The claims can be filtered by fields such as `id`. The claims can also be sorted or paginated.
 * @summary List Claims
 */
export type adminGetClaimsResponse = {
  data: AdminClaimListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetClaimsUrl = (params?: AdminGetClaimsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims`
}

export const adminGetClaims = async (params?: AdminGetClaimsParams, options?: RequestInit): Promise<adminGetClaimsResponse> => {
  
  return customFetch<Promise<adminGetClaimsResponse>>(getAdminGetClaimsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a claim. The claim is still in the request state, and the changes are only applied on the order once the claim is confirmed.
 * @summary Create a Claim
 */
export type adminPostClaimsResponse = {
  data: AdminClaimOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsUrl = (params?: AdminPostClaimsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims`
}

export const adminPostClaims = async (adminPostOrderClaimsReqSchema: AdminPostOrderClaimsReqSchema,
    params?: AdminPostClaimsParams, options?: RequestInit): Promise<adminPostClaimsResponse> => {
  
  return customFetch<Promise<adminPostClaimsResponse>>(getAdminPostClaimsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrderClaimsReqSchema,)
  }
);}



/**
 * Retrieve a claim by its ID. You can expand the claim's relations or select the fields that should be returned using the query parameters.
 * @summary Get a Claim
 */
export type adminGetClaimsIdResponse = {
  data: AdminClaimResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetClaimsIdUrl = (id: string,
    params?: AdminGetClaimsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}`
}

export const adminGetClaimsId = async (id: string,
    params?: AdminGetClaimsIdParams, options?: RequestInit): Promise<adminGetClaimsIdResponse> => {
  
  return customFetch<Promise<adminGetClaimsIdResponse>>(getAdminGetClaimsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Cancel a claim and its associated return.
 * @summary Cancel a Claim
 */
export type adminPostClaimsIdCancelResponse = {
  data: AdminClaimResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdCancelUrl = (id: string,) => {


  return `http://localhost:9000/admin/claims/${id}/cancel`
}

export const adminPostClaimsIdCancel = async (id: string,
    adminPostCancelClaimReqSchema: AdminPostCancelClaimReqSchema, options?: RequestInit): Promise<adminPostClaimsIdCancelResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdCancelResponse>>(getAdminPostClaimsIdCancelUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCancelClaimReqSchema,)
  }
);}



/**
 * Add order items to a claim as claim items. These claim items will have the action `WRITE_OFF_ITEM`.
 * @summary Add Claim Items to a Claim
 */
export type adminPostClaimsIdClaimItemsResponse = {
  data: AdminClaimPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdClaimItemsUrl = (id: string,
    params?: AdminPostClaimsIdClaimItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}/claim-items?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}/claim-items`
}

export const adminPostClaimsIdClaimItems = async (id: string,
    adminPostClaimItemsReqSchema: AdminPostClaimItemsReqSchema,
    params?: AdminPostClaimsIdClaimItemsParams, options?: RequestInit): Promise<adminPostClaimsIdClaimItemsResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdClaimItemsResponse>>(getAdminPostClaimsIdClaimItemsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostClaimItemsReqSchema,)
  }
);}



/**
 * Update an order item in a claim by the ID of the item's `WRITE_OFF_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update a Claim Item
 */
export type adminPostClaimsIdClaimItemsActionIdResponse = {
  data: AdminClaimPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdClaimItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminPostClaimsIdClaimItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}/claim-items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}/claim-items/${actionId}`
}

export const adminPostClaimsIdClaimItemsActionId = async (id: string,
    actionId: string,
    adminPostClaimsItemsActionReqSchema: AdminPostClaimsItemsActionReqSchema,
    params?: AdminPostClaimsIdClaimItemsActionIdParams, options?: RequestInit): Promise<adminPostClaimsIdClaimItemsActionIdResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdClaimItemsActionIdResponse>>(getAdminPostClaimsIdClaimItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostClaimsItemsActionReqSchema,)
  }
);}



/**
 * Remove an order item from a claim by the ID of the item's `WRITE_OFF_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove a Claim Item from a Claim
 */
export type adminDeleteClaimsIdClaimItemsActionIdResponse = {
  data: AdminClaimPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteClaimsIdClaimItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminDeleteClaimsIdClaimItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}/claim-items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}/claim-items/${actionId}`
}

export const adminDeleteClaimsIdClaimItemsActionId = async (id: string,
    actionId: string,
    params?: AdminDeleteClaimsIdClaimItemsActionIdParams, options?: RequestInit): Promise<adminDeleteClaimsIdClaimItemsActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteClaimsIdClaimItemsActionIdResponse>>(getAdminDeleteClaimsIdClaimItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add inbound (or return) items to a claim. These inbound items will have a `RETURN_ITEM` action.

 * @summary Add Inbound Items to a Claim
 */
export type adminPostClaimsIdInboundItemsResponse = {
  data: AdminClaimReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdInboundItemsUrl = (id: string,) => {


  return `http://localhost:9000/admin/claims/${id}/inbound/items`
}

export const adminPostClaimsIdInboundItems = async (id: string,
    adminPostReturnsRequestItemsReqSchema: AdminPostReturnsRequestItemsReqSchema, options?: RequestInit): Promise<adminPostClaimsIdInboundItemsResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdInboundItemsResponse>>(getAdminPostClaimsIdInboundItemsUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsRequestItemsReqSchema,)
  }
);}



/**
 * Update an inbound (or return) item of a claim using the `ID` of the item's `RETURN_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update Inbound Items of a Claim
 */
export type adminPostClaimsIdInboundItemsActionIdResponse = {
  data: AdminClaimReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdInboundItemsActionIdUrl = (id: string,
    actionId: string,) => {


  return `http://localhost:9000/admin/claims/${id}/inbound/items/${actionId}`
}

export const adminPostClaimsIdInboundItemsActionId = async (id: string,
    actionId: string,
    adminPostReturnsRequestItemsActionReqSchema: AdminPostReturnsRequestItemsActionReqSchema, options?: RequestInit): Promise<adminPostClaimsIdInboundItemsActionIdResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdInboundItemsActionIdResponse>>(getAdminPostClaimsIdInboundItemsActionIdUrl(id,actionId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsRequestItemsActionReqSchema,)
  }
);}



/**
 * Remove an inbound (or return) item from a claim using the `ID` of the item's `RETURN_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove an Inbound Item from Claim
 */
export type adminDeleteClaimsIdInboundItemsActionIdResponse = {
  data: AdminClaimReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteClaimsIdInboundItemsActionIdUrl = (id: string,
    actionId: string,) => {


  return `http://localhost:9000/admin/claims/${id}/inbound/items/${actionId}`
}

export const adminDeleteClaimsIdInboundItemsActionId = async (id: string,
    actionId: string, options?: RequestInit): Promise<adminDeleteClaimsIdInboundItemsActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteClaimsIdInboundItemsActionIdResponse>>(getAdminDeleteClaimsIdInboundItemsActionIdUrl(id,actionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add an inbound (or return) shipping method to a claim. The inbound shipping method will have a `SHIPPING_ADD` action.

 * @summary Add an Inbound Shipping Method to a Claim
 */
export type adminPostClaimsIdInboundShippingMethodResponse = {
  data: AdminClaimReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdInboundShippingMethodUrl = (id: string,) => {


  return `http://localhost:9000/admin/claims/${id}/inbound/shipping-method`
}

export const adminPostClaimsIdInboundShippingMethod = async (id: string,
    adminPostReturnsShippingReqSchema: AdminPostReturnsShippingReqSchema, options?: RequestInit): Promise<adminPostClaimsIdInboundShippingMethodResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdInboundShippingMethodResponse>>(getAdminPostClaimsIdInboundShippingMethodUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsShippingReqSchema,)
  }
);}



/**
 * Update the shipping method for returning items in the claim using the `ID` of the method's `SHIPPING_ADD` action.

Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update Inbound Shipping Method of a Claim
 */
export type adminPostClaimsIdInboundShippingMethodActionIdResponse = {
  data: AdminClaimPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdInboundShippingMethodActionIdUrl = (id: string,
    actionId: string,
    params?: AdminPostClaimsIdInboundShippingMethodActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}/inbound/shipping-method/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}/inbound/shipping-method/${actionId}`
}

export const adminPostClaimsIdInboundShippingMethodActionId = async (id: string,
    actionId: string,
    adminPostClaimsShippingActionReqSchema: AdminPostClaimsShippingActionReqSchema,
    params?: AdminPostClaimsIdInboundShippingMethodActionIdParams, options?: RequestInit): Promise<adminPostClaimsIdInboundShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdInboundShippingMethodActionIdResponse>>(getAdminPostClaimsIdInboundShippingMethodActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostClaimsShippingActionReqSchema,)
  }
);}



/**
 * Remove the shipping method for returning items in the claim using the `ID` of the method's `SHIPPING_ADD` action.

Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove Inbound Shipping Method from Claim
 */
export type adminDeleteClaimsIdInboundShippingMethodActionIdResponse = {
  data: AdminClaimReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteClaimsIdInboundShippingMethodActionIdUrl = (id: string,
    actionId: string,) => {


  return `http://localhost:9000/admin/claims/${id}/inbound/shipping-method/${actionId}`
}

export const adminDeleteClaimsIdInboundShippingMethodActionId = async (id: string,
    actionId: string, options?: RequestInit): Promise<adminDeleteClaimsIdInboundShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteClaimsIdInboundShippingMethodActionIdResponse>>(getAdminDeleteClaimsIdInboundShippingMethodActionIdUrl(id,actionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add outbound (or new) items to a claim. These outbound items will have an `ITEM_ADD` action.

 * @summary Add Outbound Items to a Claim
 */
export type adminPostClaimsIdOutboundItemsResponse = {
  data: AdminClaimPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdOutboundItemsUrl = (id: string,
    params?: AdminPostClaimsIdOutboundItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}/outbound/items?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}/outbound/items`
}

export const adminPostClaimsIdOutboundItems = async (id: string,
    adminPostClaimsAddItemsReqSchema: AdminPostClaimsAddItemsReqSchema,
    params?: AdminPostClaimsIdOutboundItemsParams, options?: RequestInit): Promise<adminPostClaimsIdOutboundItemsResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdOutboundItemsResponse>>(getAdminPostClaimsIdOutboundItemsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostClaimsAddItemsReqSchema,)
  }
);}



/**
 * Update an outbound (or new) item of a claim using the `ID` of the item's `ITEM_ADD` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update Outbound Item of a Claim
 */
export type adminPostClaimsIdOutboundItemsActionIdResponse = {
  data: AdminClaimPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdOutboundItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminPostClaimsIdOutboundItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}/outbound/items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}/outbound/items/${actionId}`
}

export const adminPostClaimsIdOutboundItemsActionId = async (id: string,
    actionId: string,
    adminPostClaimsItemsActionReqSchema: AdminPostClaimsItemsActionReqSchema,
    params?: AdminPostClaimsIdOutboundItemsActionIdParams, options?: RequestInit): Promise<adminPostClaimsIdOutboundItemsActionIdResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdOutboundItemsActionIdResponse>>(getAdminPostClaimsIdOutboundItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostClaimsItemsActionReqSchema,)
  }
);}



/**
 * Remove an outbound (or new) item from a claim using the `ID` of the item's `ITEM_ADD` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove an Outbound Item from Claim
 */
export type adminDeleteClaimsIdOutboundItemsActionIdResponse = {
  data: AdminClaimPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteClaimsIdOutboundItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminDeleteClaimsIdOutboundItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}/outbound/items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}/outbound/items/${actionId}`
}

export const adminDeleteClaimsIdOutboundItemsActionId = async (id: string,
    actionId: string,
    params?: AdminDeleteClaimsIdOutboundItemsActionIdParams, options?: RequestInit): Promise<adminDeleteClaimsIdOutboundItemsActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteClaimsIdOutboundItemsActionIdResponse>>(getAdminDeleteClaimsIdOutboundItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add an outbound shipping method to a claim. The outbound shipping method will have a `SHIPPING_ADD` action.

 * @summary Add Outbound Shipping Methods to a Claim
 */
export type adminPostClaimsIdOutboundShippingMethodResponse = {
  data: AdminClaimPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdOutboundShippingMethodUrl = (id: string,
    params?: AdminPostClaimsIdOutboundShippingMethodParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}/outbound/shipping-method?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}/outbound/shipping-method`
}

export const adminPostClaimsIdOutboundShippingMethod = async (id: string,
    adminPostClaimsShippingReqSchema: AdminPostClaimsShippingReqSchema,
    params?: AdminPostClaimsIdOutboundShippingMethodParams, options?: RequestInit): Promise<adminPostClaimsIdOutboundShippingMethodResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdOutboundShippingMethodResponse>>(getAdminPostClaimsIdOutboundShippingMethodUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostClaimsShippingReqSchema,)
  }
);}



/**
 * Update the shipping method for delivering outbound items in a claim using the `ID` of the method's `SHIPPING_ADD` action.

Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update Outbound Shipping Method of a Claim
 */
export type adminPostClaimsIdOutboundShippingMethodActionIdResponse = {
  data: AdminClaimPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdOutboundShippingMethodActionIdUrl = (id: string,
    actionId: string,
    params?: AdminPostClaimsIdOutboundShippingMethodActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}/outbound/shipping-method/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}/outbound/shipping-method/${actionId}`
}

export const adminPostClaimsIdOutboundShippingMethodActionId = async (id: string,
    actionId: string,
    adminPostClaimsShippingActionReqSchema: AdminPostClaimsShippingActionReqSchema,
    params?: AdminPostClaimsIdOutboundShippingMethodActionIdParams, options?: RequestInit): Promise<adminPostClaimsIdOutboundShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdOutboundShippingMethodActionIdResponse>>(getAdminPostClaimsIdOutboundShippingMethodActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostClaimsShippingActionReqSchema,)
  }
);}



/**
 * Remove the shipping method for delivering outbound items in the claim using the `ID` of the method's `SHIPPING_ADD` action.

Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove Outbound Shipping Method from Claim
 */
export type adminDeleteClaimsIdOutboundShippingMethodActionIdResponse = {
  data: AdminClaimPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteClaimsIdOutboundShippingMethodActionIdUrl = (id: string,
    actionId: string,
    params?: AdminDeleteClaimsIdOutboundShippingMethodActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}/outbound/shipping-method/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}/outbound/shipping-method/${actionId}`
}

export const adminDeleteClaimsIdOutboundShippingMethodActionId = async (id: string,
    actionId: string,
    params?: AdminDeleteClaimsIdOutboundShippingMethodActionIdParams, options?: RequestInit): Promise<adminDeleteClaimsIdOutboundShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteClaimsIdOutboundShippingMethodActionIdResponse>>(getAdminDeleteClaimsIdOutboundShippingMethodActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Confirm a claim request, applying its changes on the associated order.
 * @summary Confirm a Claim Request
 */
export type adminPostClaimsIdRequestResponse = {
  data: AdminClaimRequestResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostClaimsIdRequestUrl = (id: string,
    params?: AdminPostClaimsIdRequestParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/claims/${id}/request?${normalizedParams.toString()}` : `http://localhost:9000/admin/claims/${id}/request`
}

export const adminPostClaimsIdRequest = async (id: string,
    params?: AdminPostClaimsIdRequestParams, options?: RequestInit): Promise<adminPostClaimsIdRequestResponse> => {
  
  return customFetch<Promise<adminPostClaimsIdRequestResponse>>(getAdminPostClaimsIdRequestUrl(id,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Cancel a requested claim.
 * @summary Cancel Claim Request
 */
export type adminDeleteClaimsIdRequestResponse = {
  data: AdminClaimDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteClaimsIdRequestUrl = (id: string,) => {


  return `http://localhost:9000/admin/claims/${id}/request`
}

export const adminDeleteClaimsIdRequest = async (id: string, options?: RequestInit): Promise<adminDeleteClaimsIdRequestResponse> => {
  
  return customFetch<Promise<adminDeleteClaimsIdRequestResponse>>(getAdminDeleteClaimsIdRequestUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of collections. The collections can be filtered by fields such as `id`. The collections can also be sorted or paginated.
 * @summary List Collections
 */
export type adminGetCollectionsResponse = {
  data: AdminCollectionListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetCollectionsUrl = (params?: AdminGetCollectionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/collections?${normalizedParams.toString()}` : `http://localhost:9000/admin/collections`
}

export const adminGetCollections = async (params?: AdminGetCollectionsParams, options?: RequestInit): Promise<adminGetCollectionsResponse> => {
  
  return customFetch<Promise<adminGetCollectionsResponse>>(getAdminGetCollectionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a collection.
 * @summary Create Collection
 */
export type adminPostCollectionsResponse = {
  data: AdminCollectionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCollectionsUrl = (params?: AdminPostCollectionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/collections?${normalizedParams.toString()}` : `http://localhost:9000/admin/collections`
}

export const adminPostCollections = async (adminCreateCollection: AdminCreateCollection,
    params?: AdminPostCollectionsParams, options?: RequestInit): Promise<adminPostCollectionsResponse> => {
  
  return customFetch<Promise<adminPostCollectionsResponse>>(getAdminPostCollectionsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateCollection,)
  }
);}



/**
 * Retrieve a collection by its ID. You can expand the collection's relations or select the fields that should be returned using the query parameters.
 * @summary Get a Collection
 */
export type adminGetCollectionsIdResponse = {
  data: AdminCollectionResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetCollectionsIdUrl = (id: string,
    params?: AdminGetCollectionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/collections/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/collections/${id}`
}

export const adminGetCollectionsId = async (id: string,
    params?: AdminGetCollectionsIdParams, options?: RequestInit): Promise<adminGetCollectionsIdResponse> => {
  
  return customFetch<Promise<adminGetCollectionsIdResponse>>(getAdminGetCollectionsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a collection's details.
 * @summary Update a Collection
 */
export type adminPostCollectionsIdResponse = {
  data: AdminCollectionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCollectionsIdUrl = (id: string,
    params?: AdminPostCollectionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/collections/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/collections/${id}`
}

export const adminPostCollectionsId = async (id: string,
    adminUpdateCollection: AdminUpdateCollection,
    params?: AdminPostCollectionsIdParams, options?: RequestInit): Promise<adminPostCollectionsIdResponse> => {
  
  return customFetch<Promise<adminPostCollectionsIdResponse>>(getAdminPostCollectionsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateCollection,)
  }
);}



/**
 * Delete a product collection.
 * @summary Delete a Collection
 */
export type adminDeleteCollectionsIdResponse = {
  data: AdminCollectionDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteCollectionsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/collections/${id}`
}

export const adminDeleteCollectionsId = async (id: string, options?: RequestInit): Promise<adminDeleteCollectionsIdResponse> => {
  
  return customFetch<Promise<adminDeleteCollectionsIdResponse>>(getAdminDeleteCollectionsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Manage the products of a collection by adding or removing them from the collection.
 * @summary Manage Products of a Collection
 */
export type adminPostCollectionsIdProductsResponse = {
  data: AdminCollectionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCollectionsIdProductsUrl = (id: string,
    params?: AdminPostCollectionsIdProductsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/collections/${id}/products?${normalizedParams.toString()}` : `http://localhost:9000/admin/collections/${id}/products`
}

export const adminPostCollectionsIdProducts = async (id: string,
    adminPostCollectionsIdProductsBody: AdminPostCollectionsIdProductsBody,
    params?: AdminPostCollectionsIdProductsParams, options?: RequestInit): Promise<adminPostCollectionsIdProductsResponse> => {
  
  return customFetch<Promise<adminPostCollectionsIdProductsResponse>>(getAdminPostCollectionsIdProductsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCollectionsIdProductsBody,)
  }
);}



/**
 * Retrieve a list of currencies. The currencies can be filtered by fields such as `id`. The currencies can also be sorted or paginated.
 * @summary List Currencies
 */
export type adminGetCurrenciesResponse = {
  data: AdminCurrencyListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetCurrenciesUrl = (params?: AdminGetCurrenciesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/currencies?${normalizedParams.toString()}` : `http://localhost:9000/admin/currencies`
}

export const adminGetCurrencies = async (params?: AdminGetCurrenciesParams, options?: RequestInit): Promise<adminGetCurrenciesResponse> => {
  
  return customFetch<Promise<adminGetCurrenciesResponse>>(getAdminGetCurrenciesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a currency by its code. You can expand the currency's relations or select the fields that should be returned using the query parameters.
 * @summary Get a Currency
 */
export type adminGetCurrenciesCodeResponse = {
  data: AdminCurrencyResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetCurrenciesCodeUrl = (code: string,
    params?: AdminGetCurrenciesCodeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/currencies/${code}?${normalizedParams.toString()}` : `http://localhost:9000/admin/currencies/${code}`
}

export const adminGetCurrenciesCode = async (code: string,
    params?: AdminGetCurrenciesCodeParams, options?: RequestInit): Promise<adminGetCurrenciesCodeResponse> => {
  
  return customFetch<Promise<adminGetCurrenciesCodeResponse>>(getAdminGetCurrenciesCodeUrl(code,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a list of customer groups. The customer groups can be filtered by fields such as `id`. The customer groups can also be sorted or paginated.
 * @summary List Customer Groups
 */
export type adminGetCustomerGroupsResponse = {
  data: AdminGetCustomerGroups200;
  status: number;
  headers: Headers;
}

export const getAdminGetCustomerGroupsUrl = (params?: AdminGetCustomerGroupsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customer-groups?${normalizedParams.toString()}` : `http://localhost:9000/admin/customer-groups`
}

export const adminGetCustomerGroups = async (params?: AdminGetCustomerGroupsParams, options?: RequestInit): Promise<adminGetCustomerGroupsResponse> => {
  
  return customFetch<Promise<adminGetCustomerGroupsResponse>>(getAdminGetCustomerGroupsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a customer group.
 * @summary Create Customer Group
 */
export type adminPostCustomerGroupsResponse = {
  data: AdminCustomerGroupResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCustomerGroupsUrl = (params?: AdminPostCustomerGroupsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customer-groups?${normalizedParams.toString()}` : `http://localhost:9000/admin/customer-groups`
}

export const adminPostCustomerGroups = async (adminCreateCustomerGroup: AdminCreateCustomerGroup,
    params?: AdminPostCustomerGroupsParams, options?: RequestInit): Promise<adminPostCustomerGroupsResponse> => {
  
  return customFetch<Promise<adminPostCustomerGroupsResponse>>(getAdminPostCustomerGroupsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateCustomerGroup,)
  }
);}



/**
 * Retrieve a customer group by its ID. You can expand the customer group's relations or select the fields that should be returned.
 * @summary Get a Customer Group
 */
export type adminGetCustomerGroupsIdResponse = {
  data: AdminCustomerGroupResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetCustomerGroupsIdUrl = (id: string,
    params?: AdminGetCustomerGroupsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customer-groups/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/customer-groups/${id}`
}

export const adminGetCustomerGroupsId = async (id: string,
    params?: AdminGetCustomerGroupsIdParams, options?: RequestInit): Promise<adminGetCustomerGroupsIdResponse> => {
  
  return customFetch<Promise<adminGetCustomerGroupsIdResponse>>(getAdminGetCustomerGroupsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a customer group's details.
 * @summary Update a Customer Group
 */
export type adminPostCustomerGroupsIdResponse = {
  data: AdminCustomerGroupResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCustomerGroupsIdUrl = (id: string,
    params?: AdminPostCustomerGroupsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customer-groups/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/customer-groups/${id}`
}

export const adminPostCustomerGroupsId = async (id: string,
    adminUpdateCustomerGroup: AdminUpdateCustomerGroup,
    params?: AdminPostCustomerGroupsIdParams, options?: RequestInit): Promise<adminPostCustomerGroupsIdResponse> => {
  
  return customFetch<Promise<adminPostCustomerGroupsIdResponse>>(getAdminPostCustomerGroupsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateCustomerGroup,)
  }
);}



/**
 * Delete a customer group. Customers in the group aren't deleted.

 * @summary Delete a Customer Group
 */
export type adminDeleteCustomerGroupsIdResponse = {
  data: AdminDeleteCustomerGroupsId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteCustomerGroupsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/customer-groups/${id}`
}

export const adminDeleteCustomerGroupsId = async (id: string, options?: RequestInit): Promise<adminDeleteCustomerGroupsIdResponse> => {
  
  return customFetch<Promise<adminDeleteCustomerGroupsIdResponse>>(getAdminDeleteCustomerGroupsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Manage the customers of a group to add or remove them from the group.
 * @summary Manage Customers of a Customer Group
 */
export type adminPostCustomerGroupsIdCustomersResponse = {
  data: AdminCustomerGroupResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCustomerGroupsIdCustomersUrl = (id: string,
    params?: AdminPostCustomerGroupsIdCustomersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customer-groups/${id}/customers?${normalizedParams.toString()}` : `http://localhost:9000/admin/customer-groups/${id}/customers`
}

export const adminPostCustomerGroupsIdCustomers = async (id: string,
    adminPostCustomerGroupsIdCustomersBody: AdminPostCustomerGroupsIdCustomersBody,
    params?: AdminPostCustomerGroupsIdCustomersParams, options?: RequestInit): Promise<adminPostCustomerGroupsIdCustomersResponse> => {
  
  return customFetch<Promise<adminPostCustomerGroupsIdCustomersResponse>>(getAdminPostCustomerGroupsIdCustomersUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCustomerGroupsIdCustomersBody,)
  }
);}



/**
 * Retrieve a list of customers. The customers can be filtered by fields such as `id`. The customers can also be sorted or paginated.
 * @summary List Customers
 */
export type adminGetCustomersResponse = {
  data: AdminGetCustomers200;
  status: number;
  headers: Headers;
}

export const getAdminGetCustomersUrl = (params?: AdminGetCustomersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customers?${normalizedParams.toString()}` : `http://localhost:9000/admin/customers`
}

export const adminGetCustomers = async (params?: AdminGetCustomersParams, options?: RequestInit): Promise<adminGetCustomersResponse> => {
  
  return customFetch<Promise<adminGetCustomersResponse>>(getAdminGetCustomersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a customer.
 * @summary Create Customer
 */
export type adminPostCustomersResponse = {
  data: AdminCustomerResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCustomersUrl = (params?: AdminPostCustomersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customers?${normalizedParams.toString()}` : `http://localhost:9000/admin/customers`
}

export const adminPostCustomers = async (adminPostCustomersBody: AdminPostCustomersBody,
    params?: AdminPostCustomersParams, options?: RequestInit): Promise<adminPostCustomersResponse> => {
  
  return customFetch<Promise<adminPostCustomersResponse>>(getAdminPostCustomersUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCustomersBody,)
  }
);}



/**
 * Retrieve a customer by its ID. You can expand the customer's relations or select the fields that should be returned.
 * @summary Get a Customer
 */
export type adminGetCustomersIdResponse = {
  data: AdminCustomerResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetCustomersIdUrl = (id: string,
    params?: AdminGetCustomersIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customers/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/customers/${id}`
}

export const adminGetCustomersId = async (id: string,
    params?: AdminGetCustomersIdParams, options?: RequestInit): Promise<adminGetCustomersIdResponse> => {
  
  return customFetch<Promise<adminGetCustomersIdResponse>>(getAdminGetCustomersIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a customer's details.
 * @summary Update a Customer
 */
export type adminPostCustomersIdResponse = {
  data: AdminCustomerResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCustomersIdUrl = (id: string,
    params?: AdminPostCustomersIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customers/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/customers/${id}`
}

export const adminPostCustomersId = async (id: string,
    adminPostCustomersIdBody: AdminPostCustomersIdBody,
    params?: AdminPostCustomersIdParams, options?: RequestInit): Promise<adminPostCustomersIdResponse> => {
  
  return customFetch<Promise<adminPostCustomersIdResponse>>(getAdminPostCustomersIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCustomersIdBody,)
  }
);}



/**
 * Delete a customer.
 * @summary Delete a Customer
 */
export type adminDeleteCustomersIdResponse = {
  data: AdminDeleteCustomersId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteCustomersIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/customers/${id}`
}

export const adminDeleteCustomersId = async (id: string, options?: RequestInit): Promise<adminDeleteCustomersIdResponse> => {
  
  return customFetch<Promise<adminDeleteCustomersIdResponse>>(getAdminDeleteCustomersIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of addresses in a customer. The addresses can be filtered by fields like `query`. The addresses can also be paginated.
 * @summary List Addresses
 */
export type adminGetCustomersIdAddressesResponse = {
  data: AdminGetCustomersIdAddresses200;
  status: number;
  headers: Headers;
}

export const getAdminGetCustomersIdAddressesUrl = (id: string,
    params?: AdminGetCustomersIdAddressesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customers/${id}/addresses?${normalizedParams.toString()}` : `http://localhost:9000/admin/customers/${id}/addresses`
}

export const adminGetCustomersIdAddresses = async (id: string,
    params?: AdminGetCustomersIdAddressesParams, options?: RequestInit): Promise<adminGetCustomersIdAddressesResponse> => {
  
  return customFetch<Promise<adminGetCustomersIdAddressesResponse>>(getAdminGetCustomersIdAddressesUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Add an address to a customer.
 * @summary Add a Customer Address
 */
export type adminPostCustomersIdAddressesResponse = {
  data: AdminCustomerResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCustomersIdAddressesUrl = (id: string,
    params?: AdminPostCustomersIdAddressesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customers/${id}/addresses?${normalizedParams.toString()}` : `http://localhost:9000/admin/customers/${id}/addresses`
}

export const adminPostCustomersIdAddresses = async (id: string,
    adminPostCustomersIdAddressesBody: AdminPostCustomersIdAddressesBody,
    params?: AdminPostCustomersIdAddressesParams, options?: RequestInit): Promise<adminPostCustomersIdAddressesResponse> => {
  
  return customFetch<Promise<adminPostCustomersIdAddressesResponse>>(getAdminPostCustomersIdAddressesUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCustomersIdAddressesBody,)
  }
);}



/**
 * Retrieve a list of a customer's addresses. The addresses can be filtered by fields like `company`. The addresses can also be paginated.
 * @summary List Addresses
 */
export type adminGetCustomersIdAddressesAddressIdResponse = {
  data: AdminCustomerAddressResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetCustomersIdAddressesAddressIdUrl = (id: string,
    addressId: string,
    params?: AdminGetCustomersIdAddressesAddressIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customers/${id}/addresses/${addressId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/customers/${id}/addresses/${addressId}`
}

export const adminGetCustomersIdAddressesAddressId = async (id: string,
    addressId: string,
    params?: AdminGetCustomersIdAddressesAddressIdParams, options?: RequestInit): Promise<adminGetCustomersIdAddressesAddressIdResponse> => {
  
  return customFetch<Promise<adminGetCustomersIdAddressesAddressIdResponse>>(getAdminGetCustomersIdAddressesAddressIdUrl(id,addressId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a customer address's details.
 * @summary Update a Customer's Address
 */
export type adminPostCustomersIdAddressesAddressIdResponse = {
  data: AdminCustomerResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCustomersIdAddressesAddressIdUrl = (id: string,
    addressId: string,
    params?: AdminPostCustomersIdAddressesAddressIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customers/${id}/addresses/${addressId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/customers/${id}/addresses/${addressId}`
}

export const adminPostCustomersIdAddressesAddressId = async (id: string,
    addressId: string,
    adminPostCustomersIdAddressesAddressIdBody: AdminPostCustomersIdAddressesAddressIdBody,
    params?: AdminPostCustomersIdAddressesAddressIdParams, options?: RequestInit): Promise<adminPostCustomersIdAddressesAddressIdResponse> => {
  
  return customFetch<Promise<adminPostCustomersIdAddressesAddressIdResponse>>(getAdminPostCustomersIdAddressesAddressIdUrl(id,addressId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCustomersIdAddressesAddressIdBody,)
  }
);}



/**
 * Remove a customer's address.
 * @summary Remove an Address from Customer
 */
export type adminDeleteCustomersIdAddressesAddressIdResponse = {
  data: AdminDeleteCustomersIdAddressesAddressId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteCustomersIdAddressesAddressIdUrl = (id: string,
    addressId: string,
    params?: AdminDeleteCustomersIdAddressesAddressIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customers/${id}/addresses/${addressId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/customers/${id}/addresses/${addressId}`
}

export const adminDeleteCustomersIdAddressesAddressId = async (id: string,
    addressId: string,
    params?: AdminDeleteCustomersIdAddressesAddressIdParams, options?: RequestInit): Promise<adminDeleteCustomersIdAddressesAddressIdResponse> => {
  
  return customFetch<Promise<adminDeleteCustomersIdAddressesAddressIdResponse>>(getAdminDeleteCustomersIdAddressesAddressIdUrl(id,addressId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add a Customer Group to a customer
 * @summary Add Customer Group to Customer
 */
export type adminPostCustomersIdCustomerGroupsResponse = {
  data: AdminCustomerResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostCustomersIdCustomerGroupsUrl = (id: string,
    params?: AdminPostCustomersIdCustomerGroupsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/customers/${id}/customer-groups?${normalizedParams.toString()}` : `http://localhost:9000/admin/customers/${id}/customer-groups`
}

export const adminPostCustomersIdCustomerGroups = async (id: string,
    adminPostCustomersIdCustomerGroupsBody: AdminPostCustomersIdCustomerGroupsBody,
    params?: AdminPostCustomersIdCustomerGroupsParams, options?: RequestInit): Promise<adminPostCustomersIdCustomerGroupsResponse> => {
  
  return customFetch<Promise<adminPostCustomersIdCustomerGroupsResponse>>(getAdminPostCustomersIdCustomerGroupsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCustomersIdCustomerGroupsBody,)
  }
);}



/**
 * Retrieve a list of draft orders. The draft orders can be filtered by fields such as `id`. The draft orders can also be sorted or paginated.
 * @summary List Draft Orders
 */
export type adminGetDraftOrdersResponse = {
  data: AdminGetDraftOrders200;
  status: number;
  headers: Headers;
}

export const getAdminGetDraftOrdersUrl = (params?: AdminGetDraftOrdersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/draft-orders?${normalizedParams.toString()}` : `http://localhost:9000/admin/draft-orders`
}

export const adminGetDraftOrders = async (params?: AdminGetDraftOrdersParams, options?: RequestInit): Promise<adminGetDraftOrdersResponse> => {
  
  return customFetch<Promise<adminGetDraftOrdersResponse>>(getAdminGetDraftOrdersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a draft order. This creates an order with the `is_draft_order` property enabled.
 * @summary Create Draft Order
 */
export type adminPostDraftOrdersResponse = {
  data: AdminDraftOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostDraftOrdersUrl = (params?: AdminPostDraftOrdersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/draft-orders?${normalizedParams.toString()}` : `http://localhost:9000/admin/draft-orders`
}

export const adminPostDraftOrders = async (adminPostDraftOrdersBody: AdminPostDraftOrdersBody,
    params?: AdminPostDraftOrdersParams, options?: RequestInit): Promise<adminPostDraftOrdersResponse> => {
  
  return customFetch<Promise<adminPostDraftOrdersResponse>>(getAdminPostDraftOrdersUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostDraftOrdersBody,)
  }
);}



/**
 * Retrieve a draft order by its ID. You can expand the draft order's relations or select the fields that should be returned using the query parameters.
 * @summary Get a Draft Order
 */
export type adminGetDraftOrdersIdResponse = {
  data: AdminDraftOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetDraftOrdersIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/draft-orders/${id}`
}

export const adminGetDraftOrdersId = async (id: string, options?: RequestInit): Promise<adminGetDraftOrdersIdResponse> => {
  
  return customFetch<Promise<adminGetDraftOrdersIdResponse>>(getAdminGetDraftOrdersIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a list of exchanges. The exchanges can be filtered by fields such as `id`. The exchanges can also be sorted or paginated.
 * @summary List Exchanges
 */
export type adminGetExchangesResponse = {
  data: AdminGetExchanges200;
  status: number;
  headers: Headers;
}

export const getAdminGetExchangesUrl = (params?: AdminGetExchangesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/exchanges?${normalizedParams.toString()}` : `http://localhost:9000/admin/exchanges`
}

export const adminGetExchanges = async (params?: AdminGetExchangesParams, options?: RequestInit): Promise<adminGetExchangesResponse> => {
  
  return customFetch<Promise<adminGetExchangesResponse>>(getAdminGetExchangesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create an exchange request. Its changes aren't applied on the order until the exchange is confirmed.
 * @summary Create Exchange
 */
export type adminPostExchangesResponse = {
  data: AdminExchangeOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostExchangesUrl = (params?: AdminPostExchangesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/exchanges?${normalizedParams.toString()}` : `http://localhost:9000/admin/exchanges`
}

export const adminPostExchanges = async (adminPostOrderExchangesReqSchema: AdminPostOrderExchangesReqSchema,
    params?: AdminPostExchangesParams, options?: RequestInit): Promise<adminPostExchangesResponse> => {
  
  return customFetch<Promise<adminPostExchangesResponse>>(getAdminPostExchangesUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrderExchangesReqSchema,)
  }
);}



/**
 * Retrieve an exchange by its ID. You can expand the exchange's relations or select the fields that should be returned using query parameters.
 * @summary Get an Exchange
 */
export type adminGetExchangesIdResponse = {
  data: AdminExchangeResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetExchangesIdUrl = (id: string,
    params?: AdminGetExchangesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/exchanges/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/exchanges/${id}`
}

export const adminGetExchangesId = async (id: string,
    params?: AdminGetExchangesIdParams, options?: RequestInit): Promise<adminGetExchangesIdResponse> => {
  
  return customFetch<Promise<adminGetExchangesIdResponse>>(getAdminGetExchangesIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Cancel an exchange and its associated return.
 * @summary Cancel an Exchange
 */
export type adminPostExchangesIdCancelResponse = {
  data: AdminExchangeResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostExchangesIdCancelUrl = (id: string,) => {


  return `http://localhost:9000/admin/exchanges/${id}/cancel`
}

export const adminPostExchangesIdCancel = async (id: string,
    adminPostCancelExchangeReqSchema: AdminPostCancelExchangeReqSchema, options?: RequestInit): Promise<adminPostExchangesIdCancelResponse> => {
  
  return customFetch<Promise<adminPostExchangesIdCancelResponse>>(getAdminPostExchangesIdCancelUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCancelExchangeReqSchema,)
  }
);}



/**
 * Add inbound (or return) items to an exchange. These inbound items will have the action `RETURN_ITEM`.
 * @summary Add Inbound Items to an Exchange
 */
export type adminPostExchangesIdInboundItemsResponse = {
  data: AdminExchangeReturnResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostExchangesIdInboundItemsUrl = (id: string,) => {


  return `http://localhost:9000/admin/exchanges/${id}/inbound/items`
}

export const adminPostExchangesIdInboundItems = async (id: string,
    adminPostExchangesReturnRequestItemsReqSchema: AdminPostExchangesReturnRequestItemsReqSchema, options?: RequestInit): Promise<adminPostExchangesIdInboundItemsResponse> => {
  
  return customFetch<Promise<adminPostExchangesIdInboundItemsResponse>>(getAdminPostExchangesIdInboundItemsUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostExchangesReturnRequestItemsReqSchema,)
  }
);}



/**
 * Update an inbound (or return) item from an exchange using the `ID` of the item's `RETURN_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update an Inbount Item of an Exchange
 */
export type adminPostExchangesIdInboundItemsActionIdResponse = {
  data: AdminExchangeReturnResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostExchangesIdInboundItemsActionIdUrl = (id: string,
    actionId: string,) => {


  return `http://localhost:9000/admin/exchanges/${id}/inbound/items/${actionId}`
}

export const adminPostExchangesIdInboundItemsActionId = async (id: string,
    actionId: string,
    adminPostExchangesRequestItemsReturnActionReqSchema: AdminPostExchangesRequestItemsReturnActionReqSchema, options?: RequestInit): Promise<adminPostExchangesIdInboundItemsActionIdResponse> => {
  
  return customFetch<Promise<adminPostExchangesIdInboundItemsActionIdResponse>>(getAdminPostExchangesIdInboundItemsActionIdUrl(id,actionId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostExchangesRequestItemsReturnActionReqSchema,)
  }
);}



/**
 * Remove an inbound (or return) item from an exchange using the `ID` of the item's `RETURN_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove Inbound Item from Exchange
 */
export type adminDeleteExchangesIdInboundItemsActionIdResponse = {
  data: AdminExchangeReturnResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteExchangesIdInboundItemsActionIdUrl = (id: string,
    actionId: string,) => {


  return `http://localhost:9000/admin/exchanges/${id}/inbound/items/${actionId}`
}

export const adminDeleteExchangesIdInboundItemsActionId = async (id: string,
    actionId: string, options?: RequestInit): Promise<adminDeleteExchangesIdInboundItemsActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteExchangesIdInboundItemsActionIdResponse>>(getAdminDeleteExchangesIdInboundItemsActionIdUrl(id,actionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add an inbound (or return) shipping method to an exchange. The inbound shipping method will have a `SHIPPING_ADD` action.
 * @summary Add an Inbound Shipping Method to an Exchange
 */
export type adminPostExchangesIdInboundShippingMethodResponse = {
  data: AdminExchangeReturnResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostExchangesIdInboundShippingMethodUrl = (id: string,) => {


  return `http://localhost:9000/admin/exchanges/${id}/inbound/shipping-method`
}

export const adminPostExchangesIdInboundShippingMethod = async (id: string,
    adminPostReturnsShippingReqSchema: AdminPostReturnsShippingReqSchema, options?: RequestInit): Promise<adminPostExchangesIdInboundShippingMethodResponse> => {
  
  return customFetch<Promise<adminPostExchangesIdInboundShippingMethodResponse>>(getAdminPostExchangesIdInboundShippingMethodUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsShippingReqSchema,)
  }
);}



/**
 * Update the shipping method for returning items in the exchange using the `ID` of the method's `SHIPPING_ADD` action.

Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update Inbound Shipping Method of an Exchange
 */
export type adminPostExchangesIdInboundShippingMethodActionIdResponse = {
  data: AdminExchangePreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostExchangesIdInboundShippingMethodActionIdUrl = (id: string,
    actionId: string,
    params?: AdminPostExchangesIdInboundShippingMethodActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/exchanges/${id}/inbound/shipping-method/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/exchanges/${id}/inbound/shipping-method/${actionId}`
}

export const adminPostExchangesIdInboundShippingMethodActionId = async (id: string,
    actionId: string,
    adminPostExchangesShippingActionReqSchema: AdminPostExchangesShippingActionReqSchema,
    params?: AdminPostExchangesIdInboundShippingMethodActionIdParams, options?: RequestInit): Promise<adminPostExchangesIdInboundShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminPostExchangesIdInboundShippingMethodActionIdResponse>>(getAdminPostExchangesIdInboundShippingMethodActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostExchangesShippingActionReqSchema,)
  }
);}



/**
 * Remove the shipping method for returning items in the exchange using the `ID` of the method's `SHIPPING_ADD` action.

Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove Inbound Shipping Method from Exchange
 */
export type adminDeleteExchangesIdInboundShippingMethodActionIdResponse = {
  data: AdminExchangeReturnResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteExchangesIdInboundShippingMethodActionIdUrl = (id: string,
    actionId: string,) => {


  return `http://localhost:9000/admin/exchanges/${id}/inbound/shipping-method/${actionId}`
}

export const adminDeleteExchangesIdInboundShippingMethodActionId = async (id: string,
    actionId: string, options?: RequestInit): Promise<adminDeleteExchangesIdInboundShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteExchangesIdInboundShippingMethodActionIdResponse>>(getAdminDeleteExchangesIdInboundShippingMethodActionIdUrl(id,actionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add outbound (or new) items to an exchange. These outbound items will have the action `ITEM_ADD`.
 * @summary Add Outbound Items to Exchange
 */
export type adminPostExchangesIdOutboundItemsResponse = {
  data: AdminExchangePreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostExchangesIdOutboundItemsUrl = (id: string,
    params?: AdminPostExchangesIdOutboundItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/exchanges/${id}/outbound/items?${normalizedParams.toString()}` : `http://localhost:9000/admin/exchanges/${id}/outbound/items`
}

export const adminPostExchangesIdOutboundItems = async (id: string,
    adminPostExchangesAddItemsReqSchema: AdminPostExchangesAddItemsReqSchema,
    params?: AdminPostExchangesIdOutboundItemsParams, options?: RequestInit): Promise<adminPostExchangesIdOutboundItemsResponse> => {
  
  return customFetch<Promise<adminPostExchangesIdOutboundItemsResponse>>(getAdminPostExchangesIdOutboundItemsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostExchangesAddItemsReqSchema,)
  }
);}



/**
 * Update an outbound (or new) item from an exchange using the `ID` of the item's `ITEM_ADD` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update Outbound Item of an Exchange
 */
export type adminPostExchangesIdOutboundItemsActionIdResponse = {
  data: AdminExchangePreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostExchangesIdOutboundItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminPostExchangesIdOutboundItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/exchanges/${id}/outbound/items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/exchanges/${id}/outbound/items/${actionId}`
}

export const adminPostExchangesIdOutboundItemsActionId = async (id: string,
    actionId: string,
    adminPostExchangesItemsActionReqSchema: AdminPostExchangesItemsActionReqSchema,
    params?: AdminPostExchangesIdOutboundItemsActionIdParams, options?: RequestInit): Promise<adminPostExchangesIdOutboundItemsActionIdResponse> => {
  
  return customFetch<Promise<adminPostExchangesIdOutboundItemsActionIdResponse>>(getAdminPostExchangesIdOutboundItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostExchangesItemsActionReqSchema,)
  }
);}



/**
 * Remove an outbound (or new) item from an exchange using the `ID` of the item's `ITEM_ADD` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove Outbound Item from Exchange
 */
export type adminDeleteExchangesIdOutboundItemsActionIdResponse = {
  data: AdminExchangePreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteExchangesIdOutboundItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminDeleteExchangesIdOutboundItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/exchanges/${id}/outbound/items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/exchanges/${id}/outbound/items/${actionId}`
}

export const adminDeleteExchangesIdOutboundItemsActionId = async (id: string,
    actionId: string,
    params?: AdminDeleteExchangesIdOutboundItemsActionIdParams, options?: RequestInit): Promise<adminDeleteExchangesIdOutboundItemsActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteExchangesIdOutboundItemsActionIdResponse>>(getAdminDeleteExchangesIdOutboundItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add an outbound shipping method to an exchange. The outbound shipping method will have a `SHIPPING_ADD` action.
 * @summary Add Outbound Shipping Method to Exchange
 */
export type adminPostExchangesIdOutboundShippingMethodResponse = {
  data: AdminExchangePreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostExchangesIdOutboundShippingMethodUrl = (id: string,
    params?: AdminPostExchangesIdOutboundShippingMethodParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/exchanges/${id}/outbound/shipping-method?${normalizedParams.toString()}` : `http://localhost:9000/admin/exchanges/${id}/outbound/shipping-method`
}

export const adminPostExchangesIdOutboundShippingMethod = async (id: string,
    adminPostExchangesShippingReqSchema: AdminPostExchangesShippingReqSchema,
    params?: AdminPostExchangesIdOutboundShippingMethodParams, options?: RequestInit): Promise<adminPostExchangesIdOutboundShippingMethodResponse> => {
  
  return customFetch<Promise<adminPostExchangesIdOutboundShippingMethodResponse>>(getAdminPostExchangesIdOutboundShippingMethodUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostExchangesShippingReqSchema,)
  }
);}



/**
 * Update the shipping method for delivering outbound items in the exchange using the `ID` of the method's `SHIPPING_ADD` action.

Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update Outbound Shipping Method of Exchange
 */
export type adminPostExchangesIdOutboundShippingMethodActionIdResponse = {
  data: AdminExchangePreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostExchangesIdOutboundShippingMethodActionIdUrl = (id: string,
    actionId: string,
    params?: AdminPostExchangesIdOutboundShippingMethodActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/exchanges/${id}/outbound/shipping-method/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/exchanges/${id}/outbound/shipping-method/${actionId}`
}

export const adminPostExchangesIdOutboundShippingMethodActionId = async (id: string,
    actionId: string,
    adminPostExchangesShippingActionReqSchema: AdminPostExchangesShippingActionReqSchema,
    params?: AdminPostExchangesIdOutboundShippingMethodActionIdParams, options?: RequestInit): Promise<adminPostExchangesIdOutboundShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminPostExchangesIdOutboundShippingMethodActionIdResponse>>(getAdminPostExchangesIdOutboundShippingMethodActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostExchangesShippingActionReqSchema,)
  }
);}



/**
 * Remove the shipping method for delivering outbound items in the exchange using the `ID` of the method's `SHIPPING_ADD` action.

Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove Outbound Shipping Method from Exchange
 */
export type adminDeleteExchangesIdOutboundShippingMethodActionIdResponse = {
  data: AdminExchangePreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteExchangesIdOutboundShippingMethodActionIdUrl = (id: string,
    actionId: string,
    params?: AdminDeleteExchangesIdOutboundShippingMethodActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/exchanges/${id}/outbound/shipping-method/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/exchanges/${id}/outbound/shipping-method/${actionId}`
}

export const adminDeleteExchangesIdOutboundShippingMethodActionId = async (id: string,
    actionId: string,
    params?: AdminDeleteExchangesIdOutboundShippingMethodActionIdParams, options?: RequestInit): Promise<adminDeleteExchangesIdOutboundShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteExchangesIdOutboundShippingMethodActionIdResponse>>(getAdminDeleteExchangesIdOutboundShippingMethodActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Confirm an exchange request, applying its changes on the associated order.
 * @summary Confirm an Exchange
 */
export type adminPostExchangesIdRequestResponse = {
  data: AdminExchangeRequestResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostExchangesIdRequestUrl = (id: string,
    params?: AdminPostExchangesIdRequestParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/exchanges/${id}/request?${normalizedParams.toString()}` : `http://localhost:9000/admin/exchanges/${id}/request`
}

export const adminPostExchangesIdRequest = async (id: string,
    params?: AdminPostExchangesIdRequestParams, options?: RequestInit): Promise<adminPostExchangesIdRequestResponse> => {
  
  return customFetch<Promise<adminPostExchangesIdRequestResponse>>(getAdminPostExchangesIdRequestUrl(id,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Cancel a requested exchange.
 * @summary Cancel Exchange Request
 */
export type adminDeleteExchangesIdRequestResponse = {
  data: AdminExchangeDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteExchangesIdRequestUrl = (id: string,) => {


  return `http://localhost:9000/admin/exchanges/${id}/request`
}

export const adminDeleteExchangesIdRequest = async (id: string, options?: RequestInit): Promise<adminDeleteExchangesIdRequestResponse> => {
  
  return customFetch<Promise<adminDeleteExchangesIdRequestResponse>>(getAdminDeleteExchangesIdRequestUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of fulfillment providers. The fulfillment providers can be filtered by fields such as `id`. The fulfillment providers can also be sorted or paginated.
 * @summary List Fulfillment Providers
 */
export type adminGetFulfillmentProvidersResponse = {
  data: AdminFulfillmentProviderListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetFulfillmentProvidersUrl = (params?: AdminGetFulfillmentProvidersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/fulfillment-providers?${normalizedParams.toString()}` : `http://localhost:9000/admin/fulfillment-providers`
}

export const adminGetFulfillmentProviders = async (params?: AdminGetFulfillmentProvidersParams, options?: RequestInit): Promise<adminGetFulfillmentProvidersResponse> => {
  
  return customFetch<Promise<adminGetFulfillmentProvidersResponse>>(getAdminGetFulfillmentProvidersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve the list of fulfillment options of a fulfillment provider. These options may be retrieved from an integrated third-party service.
 * @summary List Fulfillment Options
 */
export type adminGetFulfillmentProvidersIdOptionsResponse = {
  data: AdminFulfillmentProviderOptionsListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetFulfillmentProvidersIdOptionsUrl = (id: string,) => {


  return `http://localhost:9000/admin/fulfillment-providers/${id}/options`
}

export const adminGetFulfillmentProvidersIdOptions = async (id: string, options?: RequestInit): Promise<adminGetFulfillmentProvidersIdOptionsResponse> => {
  
  return customFetch<Promise<adminGetFulfillmentProvidersIdOptionsResponse>>(getAdminGetFulfillmentProvidersIdOptionsUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Delete a fulfillment set.
 * @summary Delete Fulfillment Set
 */
export type adminDeleteFulfillmentSetsIdResponse = {
  data: AdminFulfillmentSetDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteFulfillmentSetsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/fulfillment-sets/${id}`
}

export const adminDeleteFulfillmentSetsId = async (id: string, options?: RequestInit): Promise<adminDeleteFulfillmentSetsIdResponse> => {
  
  return customFetch<Promise<adminDeleteFulfillmentSetsIdResponse>>(getAdminDeleteFulfillmentSetsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add a service zone to a fulfillment set.
 * @summary Add a Service Zone to a Fulfillment Set
 */
export type adminPostFulfillmentSetsIdServiceZonesResponse = {
  data: AdminFulfillmentSetResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostFulfillmentSetsIdServiceZonesUrl = (id: string,
    params?: AdminPostFulfillmentSetsIdServiceZonesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/fulfillment-sets/${id}/service-zones?${normalizedParams.toString()}` : `http://localhost:9000/admin/fulfillment-sets/${id}/service-zones`
}

export const adminPostFulfillmentSetsIdServiceZones = async (id: string,
    adminPostFulfillmentSetsIdServiceZonesBody: AdminPostFulfillmentSetsIdServiceZonesBody,
    params?: AdminPostFulfillmentSetsIdServiceZonesParams, options?: RequestInit): Promise<adminPostFulfillmentSetsIdServiceZonesResponse> => {
  
  return customFetch<Promise<adminPostFulfillmentSetsIdServiceZonesResponse>>(getAdminPostFulfillmentSetsIdServiceZonesUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostFulfillmentSetsIdServiceZonesBody,)
  }
);}



/**
 * Retrieve a service zone that belongs to a fulfillment set. be paginated.
 * @summary Get a Service Zone in a Fulfillment Set
 */
export type adminGetFulfillmentSetsIdServiceZonesZoneIdResponse = {
  data: AdminServiceZoneResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetFulfillmentSetsIdServiceZonesZoneIdUrl = (id: string,
    zoneId: string,
    params?: AdminGetFulfillmentSetsIdServiceZonesZoneIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/fulfillment-sets/${id}/service-zones/${zoneId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/fulfillment-sets/${id}/service-zones/${zoneId}`
}

export const adminGetFulfillmentSetsIdServiceZonesZoneId = async (id: string,
    zoneId: string,
    params?: AdminGetFulfillmentSetsIdServiceZonesZoneIdParams, options?: RequestInit): Promise<adminGetFulfillmentSetsIdServiceZonesZoneIdResponse> => {
  
  return customFetch<Promise<adminGetFulfillmentSetsIdServiceZonesZoneIdResponse>>(getAdminGetFulfillmentSetsIdServiceZonesZoneIdUrl(id,zoneId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update the details of a service zone in a fulfillment set.
 * @summary Update the Service Zone of a Fulfillment Set
 */
export type adminPostFulfillmentSetsIdServiceZonesZoneIdResponse = {
  data: AdminFulfillmentSetResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostFulfillmentSetsIdServiceZonesZoneIdUrl = (id: string,
    zoneId: string,
    params?: AdminPostFulfillmentSetsIdServiceZonesZoneIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/fulfillment-sets/${id}/service-zones/${zoneId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/fulfillment-sets/${id}/service-zones/${zoneId}`
}

export const adminPostFulfillmentSetsIdServiceZonesZoneId = async (id: string,
    zoneId: string,
    adminPostFulfillmentSetsIdServiceZonesZoneIdBody: AdminPostFulfillmentSetsIdServiceZonesZoneIdBody,
    params?: AdminPostFulfillmentSetsIdServiceZonesZoneIdParams, options?: RequestInit): Promise<adminPostFulfillmentSetsIdServiceZonesZoneIdResponse> => {
  
  return customFetch<Promise<adminPostFulfillmentSetsIdServiceZonesZoneIdResponse>>(getAdminPostFulfillmentSetsIdServiceZonesZoneIdUrl(id,zoneId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostFulfillmentSetsIdServiceZonesZoneIdBody,)
  }
);}



/**
 * Remove a service zone that belongs to a fulfillment set.
 * @summary Remove a Service Zone from Fulfillment Set
 */
export type adminDeleteFulfillmentSetsIdServiceZonesZoneIdResponse = {
  data: AdminServiceZoneDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteFulfillmentSetsIdServiceZonesZoneIdUrl = (id: string,
    zoneId: string,) => {


  return `http://localhost:9000/admin/fulfillment-sets/${id}/service-zones/${zoneId}`
}

export const adminDeleteFulfillmentSetsIdServiceZonesZoneId = async (id: string,
    zoneId: string, options?: RequestInit): Promise<adminDeleteFulfillmentSetsIdServiceZonesZoneIdResponse> => {
  
  return customFetch<Promise<adminDeleteFulfillmentSetsIdServiceZonesZoneIdResponse>>(getAdminDeleteFulfillmentSetsIdServiceZonesZoneIdUrl(id,zoneId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Create a fulfillment for an order, return, exchange, and more.
 * @summary Create Fulfillment
 */
export type adminPostFulfillmentsResponse = {
  data: AdminFulfillmentResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostFulfillmentsUrl = (params?: AdminPostFulfillmentsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/fulfillments?${normalizedParams.toString()}` : `http://localhost:9000/admin/fulfillments`
}

export const adminPostFulfillments = async (adminCreateFulfillment: AdminCreateFulfillment,
    params?: AdminPostFulfillmentsParams, options?: RequestInit): Promise<adminPostFulfillmentsResponse> => {
  
  return customFetch<Promise<adminPostFulfillmentsResponse>>(getAdminPostFulfillmentsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateFulfillment,)
  }
);}



/**
 * Cancel a fulfillment. The fulfillment can't be shipped or delivered.

To cancel the fulfillment, the `cancelFulfillment` method of the associated fulfillment provider is used.

 * @summary Cancel a Fulfillment
 */
export type adminPostFulfillmentsIdCancelResponse = {
  data: AdminFulfillmentResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostFulfillmentsIdCancelUrl = (id: string,
    params?: AdminPostFulfillmentsIdCancelParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/fulfillments/${id}/cancel?${normalizedParams.toString()}` : `http://localhost:9000/admin/fulfillments/${id}/cancel`
}

export const adminPostFulfillmentsIdCancel = async (id: string,
    params?: AdminPostFulfillmentsIdCancelParams, options?: RequestInit): Promise<adminPostFulfillmentsIdCancelResponse> => {
  
  return customFetch<Promise<adminPostFulfillmentsIdCancelResponse>>(getAdminPostFulfillmentsIdCancelUrl(id,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Create a shipment for a fulfillment. The fulfillment must not be shipped or canceled.
 * @summary Create a Shipment for a Fulfillment
 */
export type adminPostFulfillmentsIdShipmentResponse = {
  data: AdminFulfillmentResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostFulfillmentsIdShipmentUrl = (id: string,
    params?: AdminPostFulfillmentsIdShipmentParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/fulfillments/${id}/shipment?${normalizedParams.toString()}` : `http://localhost:9000/admin/fulfillments/${id}/shipment`
}

export const adminPostFulfillmentsIdShipment = async (id: string,
    adminCreateShipment: AdminCreateShipment,
    params?: AdminPostFulfillmentsIdShipmentParams, options?: RequestInit): Promise<adminPostFulfillmentsIdShipmentResponse> => {
  
  return customFetch<Promise<adminPostFulfillmentsIdShipmentResponse>>(getAdminPostFulfillmentsIdShipmentUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateShipment,)
  }
);}



/**
 * Retrieve a list of inventory items. The inventory items can be filtered by fields such as `id`. The inventory items can also be sorted or paginated.
 * @summary List Inventory Items
 */
export type adminGetInventoryItemsResponse = {
  data: AdminGetInventoryItems200;
  status: number;
  headers: Headers;
}

export const getAdminGetInventoryItemsUrl = (params?: AdminGetInventoryItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/inventory-items?${normalizedParams.toString()}` : `http://localhost:9000/admin/inventory-items`
}

export const adminGetInventoryItems = async (params?: AdminGetInventoryItemsParams, options?: RequestInit): Promise<adminGetInventoryItemsResponse> => {
  
  return customFetch<Promise<adminGetInventoryItemsResponse>>(getAdminGetInventoryItemsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create an inventory item.
 * @summary Create Inventory Item
 */
export type adminPostInventoryItemsResponse = {
  data: AdminInventoryItemResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostInventoryItemsUrl = (params?: AdminPostInventoryItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/inventory-items?${normalizedParams.toString()}` : `http://localhost:9000/admin/inventory-items`
}

export const adminPostInventoryItems = async (adminCreateInventoryItem: AdminCreateInventoryItem,
    params?: AdminPostInventoryItemsParams, options?: RequestInit): Promise<adminPostInventoryItemsResponse> => {
  
  return customFetch<Promise<adminPostInventoryItemsResponse>>(getAdminPostInventoryItemsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateInventoryItem,)
  }
);}



/**
 * Retrieve a inventory item by its ID. You can expand the inventory item's relations or select the fields that should be returned.
 * @summary Get a Inventory Item
 */
export type adminGetInventoryItemsIdResponse = {
  data: AdminInventoryItemResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetInventoryItemsIdUrl = (id: string,
    params?: AdminGetInventoryItemsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/inventory-items/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/inventory-items/${id}`
}

export const adminGetInventoryItemsId = async (id: string,
    params?: AdminGetInventoryItemsIdParams, options?: RequestInit): Promise<adminGetInventoryItemsIdResponse> => {
  
  return customFetch<Promise<adminGetInventoryItemsIdResponse>>(getAdminGetInventoryItemsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update an inventory item's details.
 * @summary Update an Inventory Item
 */
export type adminPostInventoryItemsIdResponse = {
  data: AdminInventoryItemResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostInventoryItemsIdUrl = (id: string,
    params?: AdminPostInventoryItemsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/inventory-items/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/inventory-items/${id}`
}

export const adminPostInventoryItemsId = async (id: string,
    adminPostInventoryItemsIdBody: AdminPostInventoryItemsIdBody,
    params?: AdminPostInventoryItemsIdParams, options?: RequestInit): Promise<adminPostInventoryItemsIdResponse> => {
  
  return customFetch<Promise<adminPostInventoryItemsIdResponse>>(getAdminPostInventoryItemsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostInventoryItemsIdBody,)
  }
);}



/**
 * Delete an inventory item.
 * @summary Delete Inventory Item
 */
export type adminDeleteInventoryItemsIdResponse = {
  data: AdminDeleteInventoryItemsId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteInventoryItemsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/inventory-items/${id}`
}

export const adminDeleteInventoryItemsId = async (id: string, options?: RequestInit): Promise<adminDeleteInventoryItemsIdResponse> => {
  
  return customFetch<Promise<adminDeleteInventoryItemsIdResponse>>(getAdminDeleteInventoryItemsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of inventory levels associated with an inventory item. The inventory levels can be filtered by fields like `location_id`. The inventory levels can also be paginated.
 * @summary List Inventory Levels
 */
export type adminGetInventoryItemsIdLocationLevelsResponse = {
  data: AdminGetInventoryItemsIdLocationLevels200;
  status: number;
  headers: Headers;
}

export const getAdminGetInventoryItemsIdLocationLevelsUrl = (id: string,
    params?: AdminGetInventoryItemsIdLocationLevelsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/inventory-items/${id}/location-levels?${normalizedParams.toString()}` : `http://localhost:9000/admin/inventory-items/${id}/location-levels`
}

export const adminGetInventoryItemsIdLocationLevels = async (id: string,
    params?: AdminGetInventoryItemsIdLocationLevelsParams, options?: RequestInit): Promise<adminGetInventoryItemsIdLocationLevelsResponse> => {
  
  return customFetch<Promise<adminGetInventoryItemsIdLocationLevelsResponse>>(getAdminGetInventoryItemsIdLocationLevelsUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create an inventory level for an inventory item.
 * @summary Create Inventory Level for Inventory Item
 */
export type adminPostInventoryItemsIdLocationLevelsResponse = {
  data: AdminInventoryItemResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostInventoryItemsIdLocationLevelsUrl = (id: string,
    params?: AdminPostInventoryItemsIdLocationLevelsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/inventory-items/${id}/location-levels?${normalizedParams.toString()}` : `http://localhost:9000/admin/inventory-items/${id}/location-levels`
}

export const adminPostInventoryItemsIdLocationLevels = async (id: string,
    adminPostInventoryItemsIdLocationLevelsBody: AdminPostInventoryItemsIdLocationLevelsBody,
    params?: AdminPostInventoryItemsIdLocationLevelsParams, options?: RequestInit): Promise<adminPostInventoryItemsIdLocationLevelsResponse> => {
  
  return customFetch<Promise<adminPostInventoryItemsIdLocationLevelsResponse>>(getAdminPostInventoryItemsIdLocationLevelsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostInventoryItemsIdLocationLevelsBody,)
  }
);}



/**
 * Manage the inventory levels of an inventory item to create or delete them.
 * @summary Manage Inventory Levels of Inventory Item
 */
export type adminPostInventoryItemsIdLocationLevelsBatchResponse = {
  data: AdminPostInventoryItemsIdLocationLevelsBatch200;
  status: number;
  headers: Headers;
}

export const getAdminPostInventoryItemsIdLocationLevelsBatchUrl = (id: string,) => {


  return `http://localhost:9000/admin/inventory-items/${id}/location-levels/batch`
}

export const adminPostInventoryItemsIdLocationLevelsBatch = async (id: string,
    adminPostInventoryItemsIdLocationLevelsBatchBody: AdminPostInventoryItemsIdLocationLevelsBatchBody, options?: RequestInit): Promise<adminPostInventoryItemsIdLocationLevelsBatchResponse> => {
  
  return customFetch<Promise<adminPostInventoryItemsIdLocationLevelsBatchResponse>>(getAdminPostInventoryItemsIdLocationLevelsBatchUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostInventoryItemsIdLocationLevelsBatchBody,)
  }
);}



/**
 * Updates the details of an inventory item's inventory level using its associated location ID.
 * @summary Update an Inventory Level of an Inventory Item
 */
export type adminPostInventoryItemsIdLocationLevelsLocationIdResponse = {
  data: AdminInventoryItemResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostInventoryItemsIdLocationLevelsLocationIdUrl = (id: string,
    locationId: string,
    params?: AdminPostInventoryItemsIdLocationLevelsLocationIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/inventory-items/${id}/location-levels/${locationId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/inventory-items/${id}/location-levels/${locationId}`
}

export const adminPostInventoryItemsIdLocationLevelsLocationId = async (id: string,
    locationId: string,
    adminPostInventoryItemsIdLocationLevelsLocationIdBody: AdminPostInventoryItemsIdLocationLevelsLocationIdBody,
    params?: AdminPostInventoryItemsIdLocationLevelsLocationIdParams, options?: RequestInit): Promise<adminPostInventoryItemsIdLocationLevelsLocationIdResponse> => {
  
  return customFetch<Promise<adminPostInventoryItemsIdLocationLevelsLocationIdResponse>>(getAdminPostInventoryItemsIdLocationLevelsLocationIdUrl(id,locationId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostInventoryItemsIdLocationLevelsLocationIdBody,)
  }
);}



/**
 * Remove the inventory level of an inventory item.

If the inventory level has reserved quantity greater than `0`, an error is thrown.

 * @summary Remove Inventory Level of Inventory Item
 */
export type adminDeleteInventoryItemsIdLocationLevelsLocationIdResponse = {
  data: AdminDeleteInventoryItemsIdLocationLevelsLocationId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteInventoryItemsIdLocationLevelsLocationIdUrl = (id: string,
    locationId: string,
    params?: AdminDeleteInventoryItemsIdLocationLevelsLocationIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/inventory-items/${id}/location-levels/${locationId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/inventory-items/${id}/location-levels/${locationId}`
}

export const adminDeleteInventoryItemsIdLocationLevelsLocationId = async (id: string,
    locationId: string,
    params?: AdminDeleteInventoryItemsIdLocationLevelsLocationIdParams, options?: RequestInit): Promise<adminDeleteInventoryItemsIdLocationLevelsLocationIdResponse> => {
  
  return customFetch<Promise<adminDeleteInventoryItemsIdLocationLevelsLocationIdResponse>>(getAdminDeleteInventoryItemsIdLocationLevelsLocationIdUrl(id,locationId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of invites. The invites can be filtered by fields such as `id`. The invites can also be sorted or paginated.
 * @summary List Invites
 */
export type adminGetInvitesResponse = {
  data: AdminGetInvites200;
  status: number;
  headers: Headers;
}

export const getAdminGetInvitesUrl = (params?: AdminGetInvitesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/invites?${normalizedParams.toString()}` : `http://localhost:9000/admin/invites`
}

export const adminGetInvites = async (params?: AdminGetInvitesParams, options?: RequestInit): Promise<adminGetInvitesResponse> => {
  
  return customFetch<Promise<adminGetInvitesResponse>>(getAdminGetInvitesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a invite.
 * @summary Create Invite
 */
export type adminPostInvitesResponse = {
  data: AdminInviteResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostInvitesUrl = (params?: AdminPostInvitesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/invites?${normalizedParams.toString()}` : `http://localhost:9000/admin/invites`
}

export const adminPostInvites = async (adminPostInvitesBody: AdminPostInvitesBody,
    params?: AdminPostInvitesParams, options?: RequestInit): Promise<adminPostInvitesResponse> => {
  
  return customFetch<Promise<adminPostInvitesResponse>>(getAdminPostInvitesUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostInvitesBody,)
  }
);}



/**
 * Accept an invite and create a new user.
Since the user isn't created yet, the JWT token used in the authorization header is retrieved from the `/auth/user/emailpass/register` API route (or a provider other than `emailpass`). The user can then authenticate using the `/auth/user/emailpass` API route.

 * @summary Accept Invite
 */
export type adminPostInvitesAcceptResponse = {
  data: AdminPostInvitesAccept200;
  status: number;
  headers: Headers;
}

export const getAdminPostInvitesAcceptUrl = () => {


  return `http://localhost:9000/admin/invites/accept`
}

export const adminPostInvitesAccept = async (adminPostInvitesAcceptBody: AdminPostInvitesAcceptBody, options?: RequestInit): Promise<adminPostInvitesAcceptResponse> => {
  
  return customFetch<Promise<adminPostInvitesAcceptResponse>>(getAdminPostInvitesAcceptUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostInvitesAcceptBody,)
  }
);}



/**
 * Retrieve an invite by its ID. You can expand the invite's relations or select the fields that should be returned.
 * @summary Get an Invite
 */
export type adminGetInvitesIdResponse = {
  data: AdminInviteResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetInvitesIdUrl = (id: string,
    params?: AdminGetInvitesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/invites/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/invites/${id}`
}

export const adminGetInvitesId = async (id: string,
    params?: AdminGetInvitesIdParams, options?: RequestInit): Promise<adminGetInvitesIdResponse> => {
  
  return customFetch<Promise<adminGetInvitesIdResponse>>(getAdminGetInvitesIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Delete an invite.
 * @summary Delete Invite
 */
export type adminDeleteInvitesIdResponse = {
  data: AdminDeleteInvitesId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteInvitesIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/invites/${id}`
}

export const adminDeleteInvitesId = async (id: string, options?: RequestInit): Promise<adminDeleteInvitesIdResponse> => {
  
  return customFetch<Promise<adminDeleteInvitesIdResponse>>(getAdminDeleteInvitesIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Refresh the token of an invite.
 * @summary Refresh Invite Token
 */
export type adminPostInvitesIdResendResponse = {
  data: AdminInviteResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostInvitesIdResendUrl = (id: string,
    params?: AdminPostInvitesIdResendParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/invites/${id}/resend?${normalizedParams.toString()}` : `http://localhost:9000/admin/invites/${id}/resend`
}

export const adminPostInvitesIdResend = async (id: string,
    params?: AdminPostInvitesIdResendParams, options?: RequestInit): Promise<adminPostInvitesIdResendResponse> => {
  
  return customFetch<Promise<adminPostInvitesIdResendResponse>>(getAdminPostInvitesIdResendUrl(id,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Retrieve a list of notifications. The notifications can be filtered by fields such as `id`. The notifications can also be sorted or paginated.
 * @summary List Notifications
 */
export type adminGetNotificationsResponse = {
  data: AdminNotificationListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetNotificationsUrl = (params?: AdminGetNotificationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/notifications?${normalizedParams.toString()}` : `http://localhost:9000/admin/notifications`
}

export const adminGetNotifications = async (params?: AdminGetNotificationsParams, options?: RequestInit): Promise<adminGetNotificationsResponse> => {
  
  return customFetch<Promise<adminGetNotificationsResponse>>(getAdminGetNotificationsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a notification by its ID. You can expand the notification's relations or select the fields that should be returned.
 * @summary Get a Notification
 */
export type adminGetNotificationsIdResponse = {
  data: AdminNotificationResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetNotificationsIdUrl = (id: string,
    params?: AdminGetNotificationsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/notifications/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/notifications/${id}`
}

export const adminGetNotificationsId = async (id: string,
    params?: AdminGetNotificationsIdParams, options?: RequestInit): Promise<adminGetNotificationsIdResponse> => {
  
  return customFetch<Promise<adminGetNotificationsIdResponse>>(getAdminGetNotificationsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create an order edit.
 * @summary Create Order Edit
 */
export type adminPostOrderEditsResponse = {
  data: AdminOrderEditResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrderEditsUrl = () => {


  return `http://localhost:9000/admin/order-edits`
}

export const adminPostOrderEdits = async (adminPostOrderEditsReqSchema: AdminPostOrderEditsReqSchema, options?: RequestInit): Promise<adminPostOrderEditsResponse> => {
  
  return customFetch<Promise<adminPostOrderEditsResponse>>(getAdminPostOrderEditsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrderEditsReqSchema,)
  }
);}



/**
 * Cancel an order edit.
 * @summary Cancel Order Edit
 */
export type adminDeleteOrderEditsIdResponse = {
  data: AdminDeleteOrderEditsId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteOrderEditsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/order-edits/${id}`
}

export const adminDeleteOrderEditsId = async (id: string, options?: RequestInit): Promise<adminDeleteOrderEditsIdResponse> => {
  
  return customFetch<Promise<adminDeleteOrderEditsIdResponse>>(getAdminDeleteOrderEditsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Confirm an order edit request and apply the changes on the order.
 * @summary Confirm Order Edit
 */
export type adminPostOrderEditsIdConfirmResponse = {
  data: AdminOrderEditPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrderEditsIdConfirmUrl = (id: string,) => {


  return `http://localhost:9000/admin/order-edits/${id}/confirm`
}

export const adminPostOrderEditsIdConfirm = async (id: string, options?: RequestInit): Promise<adminPostOrderEditsIdConfirmResponse> => {
  
  return customFetch<Promise<adminPostOrderEditsIdConfirmResponse>>(getAdminPostOrderEditsIdConfirmUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Add new items to an order edit. These items will have the action `ITEM_ADD`.
 * @summary Add Items to Order Edit
 */
export type adminPostOrderEditsIdItemsResponse = {
  data: AdminOrderEditPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrderEditsIdItemsUrl = (id: string,) => {


  return `http://localhost:9000/admin/order-edits/${id}/items`
}

export const adminPostOrderEditsIdItems = async (id: string,
    adminPostOrderEditsAddItemsReqSchema: AdminPostOrderEditsAddItemsReqSchema, options?: RequestInit): Promise<adminPostOrderEditsIdItemsResponse> => {
  
  return customFetch<Promise<adminPostOrderEditsIdItemsResponse>>(getAdminPostOrderEditsIdItemsUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrderEditsAddItemsReqSchema,)
  }
);}



/**
 * Update an existing order item's quantity of an order edit.
 * @summary Update Order Item Quantity of Order Edit
 */
export type adminPostOrderEditsIdItemsItemItemIdResponse = {
  data: AdminOrderEditPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrderEditsIdItemsItemItemIdUrl = (id: string,
    itemId: string,) => {


  return `http://localhost:9000/admin/order-edits/${id}/items/item/${itemId}`
}

export const adminPostOrderEditsIdItemsItemItemId = async (id: string,
    itemId: string,
    adminPostOrderEditsUpdateItemQuantityReqSchema: AdminPostOrderEditsUpdateItemQuantityReqSchema, options?: RequestInit): Promise<adminPostOrderEditsIdItemsItemItemIdResponse> => {
  
  return customFetch<Promise<adminPostOrderEditsIdItemsItemItemIdResponse>>(getAdminPostOrderEditsIdItemsItemItemIdUrl(id,itemId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrderEditsUpdateItemQuantityReqSchema,)
  }
);}



/**
 * Update an added item in the order edit by the ID of the item's `ITEM_ADD` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update an Item in an Order Edit
 */
export type adminPostOrderEditsIdItemsActionIdResponse = {
  data: AdminOrderEditPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrderEditsIdItemsActionIdUrl = (id: string,
    actionId: string,) => {


  return `http://localhost:9000/admin/order-edits/${id}/items/${actionId}`
}

export const adminPostOrderEditsIdItemsActionId = async (id: string,
    actionId: string,
    adminPostOrderEditsItemsActionReqSchema: AdminPostOrderEditsItemsActionReqSchema, options?: RequestInit): Promise<adminPostOrderEditsIdItemsActionIdResponse> => {
  
  return customFetch<Promise<adminPostOrderEditsIdItemsActionIdResponse>>(getAdminPostOrderEditsIdItemsActionIdUrl(id,actionId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrderEditsItemsActionReqSchema,)
  }
);}



/**
 * Remove an added item in the order edit by the ID of the item's `ITEM_ADD` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove Item from Order Edit
 */
export type adminDeleteOrderEditsIdItemsActionIdResponse = {
  data: AdminOrderEditPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteOrderEditsIdItemsActionIdUrl = (id: string,
    actionId: string,) => {


  return `http://localhost:9000/admin/order-edits/${id}/items/${actionId}`
}

export const adminDeleteOrderEditsIdItemsActionId = async (id: string,
    actionId: string, options?: RequestInit): Promise<adminDeleteOrderEditsIdItemsActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteOrderEditsIdItemsActionIdResponse>>(getAdminDeleteOrderEditsIdItemsActionIdUrl(id,actionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Change the status of an active order edit to requested.
 * @summary Request Order Edit
 */
export type adminPostOrderEditsIdRequestResponse = {
  data: AdminOrderEditPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrderEditsIdRequestUrl = (id: string,) => {


  return `http://localhost:9000/admin/order-edits/${id}/request`
}

export const adminPostOrderEditsIdRequest = async (id: string, options?: RequestInit): Promise<adminPostOrderEditsIdRequestResponse> => {
  
  return customFetch<Promise<adminPostOrderEditsIdRequestResponse>>(getAdminPostOrderEditsIdRequestUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Add a shipping method to an exchange. The shipping method will have a `SHIPPING_ADD` action.
 * @summary Add Shipping Method to Order Edit
 */
export type adminPostOrderEditsIdShippingMethodResponse = {
  data: AdminOrderEditPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrderEditsIdShippingMethodUrl = (id: string,) => {


  return `http://localhost:9000/admin/order-edits/${id}/shipping-method`
}

export const adminPostOrderEditsIdShippingMethod = async (id: string,
    adminPostOrderEditsShippingReqSchema: AdminPostOrderEditsShippingReqSchema, options?: RequestInit): Promise<adminPostOrderEditsIdShippingMethodResponse> => {
  
  return customFetch<Promise<adminPostOrderEditsIdShippingMethodResponse>>(getAdminPostOrderEditsIdShippingMethodUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrderEditsShippingReqSchema,)
  }
);}



/**
 * Update a shipping method in the order edit by the ID of the method's `SHIPPING_ADD` action.

Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update Shipping Method of an Order Edit
 */
export type adminPostOrderEditsIdShippingMethodActionIdResponse = {
  data: AdminOrderEditPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrderEditsIdShippingMethodActionIdUrl = (id: string,
    actionId: string,) => {


  return `http://localhost:9000/admin/order-edits/${id}/shipping-method/${actionId}`
}

export const adminPostOrderEditsIdShippingMethodActionId = async (id: string,
    actionId: string,
    adminPostOrderEditsShippingActionReqSchema: AdminPostOrderEditsShippingActionReqSchema, options?: RequestInit): Promise<adminPostOrderEditsIdShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminPostOrderEditsIdShippingMethodActionIdResponse>>(getAdminPostOrderEditsIdShippingMethodActionIdUrl(id,actionId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrderEditsShippingActionReqSchema,)
  }
);}



/**
 * Remove a shipping method in the order edit by the ID of the method's `SHIPPING_ADD` action.

Every shipping method has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove Shipping Method from Order Edit
 */
export type adminDeleteOrderEditsIdShippingMethodActionIdResponse = {
  data: AdminOrderEditPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteOrderEditsIdShippingMethodActionIdUrl = (id: string,
    actionId: string,) => {


  return `http://localhost:9000/admin/order-edits/${id}/shipping-method/${actionId}`
}

export const adminDeleteOrderEditsIdShippingMethodActionId = async (id: string,
    actionId: string, options?: RequestInit): Promise<adminDeleteOrderEditsIdShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteOrderEditsIdShippingMethodActionIdResponse>>(getAdminDeleteOrderEditsIdShippingMethodActionIdUrl(id,actionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of orders. The orders can be filtered by fields such as `id`. The orders can also be sorted or paginated.
 * @summary List Orders
 */
export type adminGetOrdersResponse = {
  data: AdminGetOrders200;
  status: number;
  headers: Headers;
}

export const getAdminGetOrdersUrl = (params?: AdminGetOrdersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders`
}

export const adminGetOrders = async (params?: AdminGetOrdersParams, options?: RequestInit): Promise<adminGetOrdersResponse> => {
  
  return customFetch<Promise<adminGetOrdersResponse>>(getAdminGetOrdersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve an order by its ID. You can expand the order's relations or select the fields that should be returned.
 * @summary Get an Order
 */
export type adminGetOrdersIdResponse = {
  data: AdminOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetOrdersIdUrl = (id: string,
    params?: AdminGetOrdersIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}`
}

export const adminGetOrdersId = async (id: string,
    params?: AdminGetOrdersIdParams, options?: RequestInit): Promise<adminGetOrdersIdResponse> => {
  
  return customFetch<Promise<adminGetOrdersIdResponse>>(getAdminGetOrdersIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update an order's details.
 * @summary Update Order
 */
export type adminPostOrdersIdResponse = {
  data: AdminOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrdersIdUrl = (id: string,
    params?: AdminPostOrdersIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}`
}

export const adminPostOrdersId = async (id: string,
    adminUpdateOrder: AdminUpdateOrder,
    params?: AdminPostOrdersIdParams, options?: RequestInit): Promise<adminPostOrdersIdResponse> => {
  
  return customFetch<Promise<adminPostOrdersIdResponse>>(getAdminPostOrdersIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateOrder,)
  }
);}



/**
 * Change the status of an order to archived.
 * @summary Archive an Order
 */
export type adminPostOrdersIdArchiveResponse = {
  data: AdminOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrdersIdArchiveUrl = (id: string,
    params?: AdminPostOrdersIdArchiveParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}/archive?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}/archive`
}

export const adminPostOrdersIdArchive = async (id: string,
    params?: AdminPostOrdersIdArchiveParams, options?: RequestInit): Promise<adminPostOrdersIdArchiveResponse> => {
  
  return customFetch<Promise<adminPostOrdersIdArchiveResponse>>(getAdminPostOrdersIdArchiveUrl(id,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Cancel an order. The cancelation fails if:
- The order has captured payments.


- The order has refund payments.


- The order has fulfillments that aren't canceled.

 * @summary Cancel Order
 */
export type adminPostOrdersIdCancelResponse = {
  data: AdminOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrdersIdCancelUrl = (id: string,
    params?: AdminPostOrdersIdCancelParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}/cancel?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}/cancel`
}

export const adminPostOrdersIdCancel = async (id: string,
    params?: AdminPostOrdersIdCancelParams, options?: RequestInit): Promise<adminPostOrdersIdCancelResponse> => {
  
  return customFetch<Promise<adminPostOrdersIdCancelResponse>>(getAdminPostOrdersIdCancelUrl(id,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Retrieve a list of changes made on an order, including returns, exchanges, etc...

The changes can be filtered by fields like FILTER FIELDS. The changes can also be paginated.

 * @summary List Changes on an Order
 */
export type adminGetOrdersIdChangesResponse = {
  data: AdminOrderChangesResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetOrdersIdChangesUrl = (id: string,
    params?: AdminGetOrdersIdChangesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}/changes?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}/changes`
}

export const adminGetOrdersIdChanges = async (id: string,
    params?: AdminGetOrdersIdChangesParams, options?: RequestInit): Promise<adminGetOrdersIdChangesResponse> => {
  
  return customFetch<Promise<adminGetOrdersIdChangesResponse>>(getAdminGetOrdersIdChangesUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Mark an order as completed.
 * @summary Complete Order
 */
export type adminPostOrdersIdCompleteResponse = {
  data: AdminOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrdersIdCompleteUrl = (id: string,
    params?: AdminPostOrdersIdCompleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}/complete?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}/complete`
}

export const adminPostOrdersIdComplete = async (id: string,
    adminPostOrdersIdCompleteBody: AdminPostOrdersIdCompleteBody,
    params?: AdminPostOrdersIdCompleteParams, options?: RequestInit): Promise<adminPostOrdersIdCompleteResponse> => {
  
  return customFetch<Promise<adminPostOrdersIdCompleteResponse>>(getAdminPostOrdersIdCompleteUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrdersIdCompleteBody,)
  }
);}



/**
 * Create a fulfillment for an order. The creation fails if the order is canceled.
 * @summary Create an Order Fulfillment
 */
export type adminPostOrdersIdFulfillmentsResponse = {
  data: AdminOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrdersIdFulfillmentsUrl = (id: string,
    params?: AdminPostOrdersIdFulfillmentsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}/fulfillments?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}/fulfillments`
}

export const adminPostOrdersIdFulfillments = async (id: string,
    adminPostOrdersIdFulfillmentsBody: AdminPostOrdersIdFulfillmentsBody,
    params?: AdminPostOrdersIdFulfillmentsParams, options?: RequestInit): Promise<adminPostOrdersIdFulfillmentsResponse> => {
  
  return customFetch<Promise<adminPostOrdersIdFulfillmentsResponse>>(getAdminPostOrdersIdFulfillmentsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrdersIdFulfillmentsBody,)
  }
);}



/**
 * Cancel an order's fulfillment. The fulfillment can't be canceled if it's shipped.
 * @summary Cancel Fulfillment
 */
export type adminPostOrdersIdFulfillmentsFulfillmentIdCancelResponse = {
  data: AdminOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrdersIdFulfillmentsFulfillmentIdCancelUrl = (id: string,
    fulfillmentId: string,
    params?: AdminPostOrdersIdFulfillmentsFulfillmentIdCancelParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}/fulfillments/${fulfillmentId}/cancel?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}/fulfillments/${fulfillmentId}/cancel`
}

export const adminPostOrdersIdFulfillmentsFulfillmentIdCancel = async (id: string,
    fulfillmentId: string,
    adminPostOrdersIdFulfillmentsFulfillmentIdCancelBody: AdminPostOrdersIdFulfillmentsFulfillmentIdCancelBody,
    params?: AdminPostOrdersIdFulfillmentsFulfillmentIdCancelParams, options?: RequestInit): Promise<adminPostOrdersIdFulfillmentsFulfillmentIdCancelResponse> => {
  
  return customFetch<Promise<adminPostOrdersIdFulfillmentsFulfillmentIdCancelResponse>>(getAdminPostOrdersIdFulfillmentsFulfillmentIdCancelUrl(id,fulfillmentId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrdersIdFulfillmentsFulfillmentIdCancelBody,)
  }
);}



/**
 * Mark an order's fulfillment as delivered.
 * @summary Mark a Fulfillment as Delivered.
 */
export type adminPostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse = {
  data: AdminOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredUrl = (id: string,
    fulfillmentId: string,
    params?: AdminPostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}/fulfillments/${fulfillmentId}/mark-as-delivered?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}/fulfillments/${fulfillmentId}/mark-as-delivered`
}

export const adminPostOrdersIdFulfillmentsFulfillmentIdMarkAsDelivered = async (id: string,
    fulfillmentId: string,
    params?: AdminPostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredParams, options?: RequestInit): Promise<adminPostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse> => {
  
  return customFetch<Promise<adminPostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse>>(getAdminPostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredUrl(id,fulfillmentId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Create a shipment for an order's fulfillment.
 * @summary Create Shipment for an Order's Fulfillment
 */
export type adminPostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse = {
  data: AdminOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrdersIdFulfillmentsFulfillmentIdShipmentsUrl = (id: string,
    fulfillmentId: string,
    params?: AdminPostOrdersIdFulfillmentsFulfillmentIdShipmentsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}/fulfillments/${fulfillmentId}/shipments?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}/fulfillments/${fulfillmentId}/shipments`
}

export const adminPostOrdersIdFulfillmentsFulfillmentIdShipments = async (id: string,
    fulfillmentId: string,
    adminPostOrdersIdFulfillmentsFulfillmentIdShipmentsBody: AdminPostOrdersIdFulfillmentsFulfillmentIdShipmentsBody,
    params?: AdminPostOrdersIdFulfillmentsFulfillmentIdShipmentsParams, options?: RequestInit): Promise<adminPostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse> => {
  
  return customFetch<Promise<adminPostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse>>(getAdminPostOrdersIdFulfillmentsFulfillmentIdShipmentsUrl(id,fulfillmentId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostOrdersIdFulfillmentsFulfillmentIdShipmentsBody,)
  }
);}



/**
 * Retrieve a list of line items in a order. The line items can be filtered by fields like FILTER FIELDS. The line items can also be paginated.
 * @summary List Line Items
 */
export type adminGetOrdersIdLineItemsResponse = {
  data: AdminGetOrdersIdLineItems200;
  status: number;
  headers: Headers;
}

export const getAdminGetOrdersIdLineItemsUrl = (id: string,
    params?: AdminGetOrdersIdLineItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}/line-items?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}/line-items`
}

export const adminGetOrdersIdLineItems = async (id: string,
    params?: AdminGetOrdersIdLineItemsParams, options?: RequestInit): Promise<adminGetOrdersIdLineItemsResponse> => {
  
  return customFetch<Promise<adminGetOrdersIdLineItemsResponse>>(getAdminGetOrdersIdLineItemsUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a preview of an order using its associated change, such as an edit.
 * @summary Get Preview
 */
export type adminGetOrdersIdPreviewResponse = {
  data: AdminOrderPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetOrdersIdPreviewUrl = (id: string,) => {


  return `http://localhost:9000/admin/orders/${id}/preview`
}

export const adminGetOrdersIdPreview = async (id: string, options?: RequestInit): Promise<adminGetOrdersIdPreviewResponse> => {
  
  return customFetch<Promise<adminGetOrdersIdPreviewResponse>>(getAdminGetOrdersIdPreviewUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Request an order to be transfered to another customer. The transfer is confirmed by sending a request to the [Accept Order Transfer](https://docs.medusajs.com/api/store#orders_postordersidtransferaccept) Store API route.
 * @summary Request Order Transfer
 */
export type adminPostOrdersIdTransferResponse = {
  data: AdminOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrdersIdTransferUrl = (id: string,
    params?: AdminPostOrdersIdTransferParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}/transfer?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}/transfer`
}

export const adminPostOrdersIdTransfer = async (id: string,
    adminTransferOrder: AdminTransferOrder,
    params?: AdminPostOrdersIdTransferParams, options?: RequestInit): Promise<adminPostOrdersIdTransferResponse> => {
  
  return customFetch<Promise<adminPostOrdersIdTransferResponse>>(getAdminPostOrdersIdTransferUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminTransferOrder,)
  }
);}



/**
 * Cancel a request to transfer an order to another customer.
 * @summary Cancel Transfer Request
 */
export type adminPostOrdersIdTransferCancelResponse = {
  data: AdminOrderResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostOrdersIdTransferCancelUrl = (id: string,
    params?: AdminPostOrdersIdTransferCancelParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/orders/${id}/transfer/cancel?${normalizedParams.toString()}` : `http://localhost:9000/admin/orders/${id}/transfer/cancel`
}

export const adminPostOrdersIdTransferCancel = async (id: string,
    params?: AdminPostOrdersIdTransferCancelParams, options?: RequestInit): Promise<adminPostOrdersIdTransferCancelResponse> => {
  
  return customFetch<Promise<adminPostOrdersIdTransferCancelResponse>>(getAdminPostOrdersIdTransferCancelUrl(id,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Create a payment collection.
 * @summary Create Payment Collection
 */
export type adminPostPaymentCollectionsResponse = {
  data: AdminPaymentCollectionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPaymentCollectionsUrl = (params?: AdminPostPaymentCollectionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/payment-collections?${normalizedParams.toString()}` : `http://localhost:9000/admin/payment-collections`
}

export const adminPostPaymentCollections = async (adminPostPaymentCollectionsBody: AdminPostPaymentCollectionsBody,
    params?: AdminPostPaymentCollectionsParams, options?: RequestInit): Promise<adminPostPaymentCollectionsResponse> => {
  
  return customFetch<Promise<adminPostPaymentCollectionsResponse>>(getAdminPostPaymentCollectionsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostPaymentCollectionsBody,)
  }
);}



/**
 * Delete a payment collection.
 * @summary Delete a Payment Collection
 */
export type adminDeletePaymentCollectionsIdResponse = {
  data: AdminDeletePaymentCollectionResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeletePaymentCollectionsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/payment-collections/${id}`
}

export const adminDeletePaymentCollectionsId = async (id: string, options?: RequestInit): Promise<adminDeletePaymentCollectionsIdResponse> => {
  
  return customFetch<Promise<adminDeletePaymentCollectionsIdResponse>>(getAdminDeletePaymentCollectionsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Mark a payment collection as paid. This creates and authorizes a payment session, then capture its payment, using the manual payment provider.
 * @summary Mark a Payment Collection as Paid
 */
export type adminPostPaymentCollectionsIdMarkAsPaidResponse = {
  data: AdminPaymentCollectionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPaymentCollectionsIdMarkAsPaidUrl = (id: string,
    params?: AdminPostPaymentCollectionsIdMarkAsPaidParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/payment-collections/${id}/mark-as-paid?${normalizedParams.toString()}` : `http://localhost:9000/admin/payment-collections/${id}/mark-as-paid`
}

export const adminPostPaymentCollectionsIdMarkAsPaid = async (id: string,
    adminPostPaymentCollectionsIdMarkAsPaidBody: AdminPostPaymentCollectionsIdMarkAsPaidBody,
    params?: AdminPostPaymentCollectionsIdMarkAsPaidParams, options?: RequestInit): Promise<adminPostPaymentCollectionsIdMarkAsPaidResponse> => {
  
  return customFetch<Promise<adminPostPaymentCollectionsIdMarkAsPaidResponse>>(getAdminPostPaymentCollectionsIdMarkAsPaidUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostPaymentCollectionsIdMarkAsPaidBody,)
  }
);}



/**
 * Retrieve a list of payments. The payments can be filtered by fields such as `id`. The payments can also be sorted or paginated.
 * @summary List Payments
 */
export type adminGetPaymentsResponse = {
  data: AdminGetPayments200;
  status: number;
  headers: Headers;
}

export const getAdminGetPaymentsUrl = (params?: AdminGetPaymentsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/payments?${normalizedParams.toString()}` : `http://localhost:9000/admin/payments`
}

export const adminGetPayments = async (params?: AdminGetPaymentsParams, options?: RequestInit): Promise<adminGetPaymentsResponse> => {
  
  return customFetch<Promise<adminGetPaymentsResponse>>(getAdminGetPaymentsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a list of payment providers. The payment providers can be filtered by fields such as `id`. The payment providers can also be sorted or paginated.
 * @summary List Payment Providers
 */
export type adminGetPaymentsPaymentProvidersResponse = {
  data: AdminGetPaymentsPaymentProviders200;
  status: number;
  headers: Headers;
}

export const getAdminGetPaymentsPaymentProvidersUrl = (params: AdminGetPaymentsPaymentProvidersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/payments/payment-providers?${normalizedParams.toString()}` : `http://localhost:9000/admin/payments/payment-providers`
}

export const adminGetPaymentsPaymentProviders = async (params: AdminGetPaymentsPaymentProvidersParams, options?: RequestInit): Promise<adminGetPaymentsPaymentProvidersResponse> => {
  
  return customFetch<Promise<adminGetPaymentsPaymentProvidersResponse>>(getAdminGetPaymentsPaymentProvidersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a payment by its ID. You can expand the payment's relations or select the fields that should be returned.
 * @summary Get a Payment
 */
export type adminGetPaymentsIdResponse = {
  data: AdminPaymentResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetPaymentsIdUrl = (id: string,
    params?: AdminGetPaymentsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/payments/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/payments/${id}`
}

export const adminGetPaymentsId = async (id: string,
    params?: AdminGetPaymentsIdParams, options?: RequestInit): Promise<adminGetPaymentsIdResponse> => {
  
  return customFetch<Promise<adminGetPaymentsIdResponse>>(getAdminGetPaymentsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Capture an amount of a payment. This uses the `capturePayment` method of the payment provider associated with the payment's collection.
 * @summary Capture Payment
 */
export type adminPostPaymentsIdCaptureResponse = {
  data: AdminPaymentResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPaymentsIdCaptureUrl = (id: string,
    params?: AdminPostPaymentsIdCaptureParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/payments/${id}/capture?${normalizedParams.toString()}` : `http://localhost:9000/admin/payments/${id}/capture`
}

export const adminPostPaymentsIdCapture = async (id: string,
    adminPostPaymentsIdCaptureBody: AdminPostPaymentsIdCaptureBody,
    params?: AdminPostPaymentsIdCaptureParams, options?: RequestInit): Promise<adminPostPaymentsIdCaptureResponse> => {
  
  return customFetch<Promise<adminPostPaymentsIdCaptureResponse>>(getAdminPostPaymentsIdCaptureUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostPaymentsIdCaptureBody,)
  }
);}



/**
 * Refund an amount of a payment. This uses the `refundPayment` method of the payment provider associated with the payment's collection.
 * @summary Refund Payment
 */
export type adminPostPaymentsIdRefundResponse = {
  data: AdminPaymentResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPaymentsIdRefundUrl = (id: string,
    params?: AdminPostPaymentsIdRefundParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/payments/${id}/refund?${normalizedParams.toString()}` : `http://localhost:9000/admin/payments/${id}/refund`
}

export const adminPostPaymentsIdRefund = async (id: string,
    adminPostPaymentsIdRefundBody: AdminPostPaymentsIdRefundBody,
    params?: AdminPostPaymentsIdRefundParams, options?: RequestInit): Promise<adminPostPaymentsIdRefundResponse> => {
  
  return customFetch<Promise<adminPostPaymentsIdRefundResponse>>(getAdminPostPaymentsIdRefundUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostPaymentsIdRefundBody,)
  }
);}



/**
 * Retrieve a list of price lists. The price lists can be filtered by fields such as `id`. The price lists can also be sorted or paginated.
 * @summary List Price Lists
 */
export type adminGetPriceListsResponse = {
  data: AdminPriceListListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetPriceListsUrl = (params?: AdminGetPriceListsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/price-lists?${normalizedParams.toString()}` : `http://localhost:9000/admin/price-lists`
}

export const adminGetPriceLists = async (params?: AdminGetPriceListsParams, options?: RequestInit): Promise<adminGetPriceListsResponse> => {
  
  return customFetch<Promise<adminGetPriceListsResponse>>(getAdminGetPriceListsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a price list.
 * @summary Create Price List
 */
export type adminPostPriceListsResponse = {
  data: AdminPriceListResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPriceListsUrl = (params?: AdminPostPriceListsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/price-lists?${normalizedParams.toString()}` : `http://localhost:9000/admin/price-lists`
}

export const adminPostPriceLists = async (adminCreatePriceList: AdminCreatePriceList,
    params?: AdminPostPriceListsParams, options?: RequestInit): Promise<adminPostPriceListsResponse> => {
  
  return customFetch<Promise<adminPostPriceListsResponse>>(getAdminPostPriceListsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreatePriceList,)
  }
);}



/**
 * Retrieve a price list by its ID. You can expand the price list's relations or select the fields that should be returned.
 * @summary Get a Price List
 */
export type adminGetPriceListsIdResponse = {
  data: AdminPriceListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetPriceListsIdUrl = (id: string,
    params?: AdminGetPriceListsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/price-lists/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/price-lists/${id}`
}

export const adminGetPriceListsId = async (id: string,
    params?: AdminGetPriceListsIdParams, options?: RequestInit): Promise<adminGetPriceListsIdResponse> => {
  
  return customFetch<Promise<adminGetPriceListsIdResponse>>(getAdminGetPriceListsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a price list's details.
 * @summary Update a Price List
 */
export type adminPostPriceListsIdResponse = {
  data: AdminPriceListResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPriceListsIdUrl = (id: string,
    params?: AdminPostPriceListsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/price-lists/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/price-lists/${id}`
}

export const adminPostPriceListsId = async (id: string,
    adminUpdatePriceList: AdminUpdatePriceList,
    params?: AdminPostPriceListsIdParams, options?: RequestInit): Promise<adminPostPriceListsIdResponse> => {
  
  return customFetch<Promise<adminPostPriceListsIdResponse>>(getAdminPostPriceListsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdatePriceList,)
  }
);}



/**
 * Delete a price list.
 * @summary Delete a Price List
 */
export type adminDeletePriceListsIdResponse = {
  data: AdminPriceListDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeletePriceListsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/price-lists/${id}`
}

export const adminDeletePriceListsId = async (id: string, options?: RequestInit): Promise<adminDeletePriceListsIdResponse> => {
  
  return customFetch<Promise<adminDeletePriceListsIdResponse>>(getAdminDeletePriceListsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Manage the prices of a price list to create, update, or delete them.
 * @summary Manage Prices in Price List
 */
export type adminPostPriceListsIdPricesBatchResponse = {
  data: AdminPriceListBatchResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPriceListsIdPricesBatchUrl = (id: string,) => {


  return `http://localhost:9000/admin/price-lists/${id}/prices/batch`
}

export const adminPostPriceListsIdPricesBatch = async (id: string,
    adminPostPriceListsIdPricesBatchBody: AdminPostPriceListsIdPricesBatchBody, options?: RequestInit): Promise<adminPostPriceListsIdPricesBatchResponse> => {
  
  return customFetch<Promise<adminPostPriceListsIdPricesBatchResponse>>(getAdminPostPriceListsIdPricesBatchUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostPriceListsIdPricesBatchBody,)
  }
);}



/**
 * Remove products from a price list.
 * @summary Remove Products from Price List
 */
export type adminPostPriceListsIdProductsResponse = {
  data: AdminPriceListResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPriceListsIdProductsUrl = (id: string,
    params?: AdminPostPriceListsIdProductsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/price-lists/${id}/products?${normalizedParams.toString()}` : `http://localhost:9000/admin/price-lists/${id}/products`
}

export const adminPostPriceListsIdProducts = async (id: string,
    adminLinkPriceListProducts: AdminLinkPriceListProducts,
    params?: AdminPostPriceListsIdProductsParams, options?: RequestInit): Promise<adminPostPriceListsIdProductsResponse> => {
  
  return customFetch<Promise<adminPostPriceListsIdProductsResponse>>(getAdminPostPriceListsIdProductsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminLinkPriceListProducts,)
  }
);}



/**
 * Retrieve a list of price preferences. The price preferences can be filtered by fields such as `id`. The price preferences can also be sorted or paginated.
 * @summary List Price Preferences
 */
export type adminGetPricePreferencesResponse = {
  data: AdminPricePreferenceListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetPricePreferencesUrl = (params?: AdminGetPricePreferencesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/price-preferences?${normalizedParams.toString()}` : `http://localhost:9000/admin/price-preferences`
}

export const adminGetPricePreferences = async (params?: AdminGetPricePreferencesParams, options?: RequestInit): Promise<adminGetPricePreferencesResponse> => {
  
  return customFetch<Promise<adminGetPricePreferencesResponse>>(getAdminGetPricePreferencesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a price preference.
 * @summary Create Price Preference
 */
export type adminPostPricePreferencesResponse = {
  data: AdminPricePreferenceResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPricePreferencesUrl = (params?: AdminPostPricePreferencesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/price-preferences?${normalizedParams.toString()}` : `http://localhost:9000/admin/price-preferences`
}

export const adminPostPricePreferences = async (adminCreatePricePreference: AdminCreatePricePreference,
    params?: AdminPostPricePreferencesParams, options?: RequestInit): Promise<adminPostPricePreferencesResponse> => {
  
  return customFetch<Promise<adminPostPricePreferencesResponse>>(getAdminPostPricePreferencesUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreatePricePreference,)
  }
);}



/**
 * Retrieve a price preference by its ID. You can expand the price preference's relations or select the fields that should be returned.
 * @summary Get a Price Preference
 */
export type adminGetPricePreferencesIdResponse = {
  data: AdminPricePreferenceResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetPricePreferencesIdUrl = (id: string,
    params?: AdminGetPricePreferencesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/price-preferences/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/price-preferences/${id}`
}

export const adminGetPricePreferencesId = async (id: string,
    params?: AdminGetPricePreferencesIdParams, options?: RequestInit): Promise<adminGetPricePreferencesIdResponse> => {
  
  return customFetch<Promise<adminGetPricePreferencesIdResponse>>(getAdminGetPricePreferencesIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a price preference's details.
 * @summary Update a Price Preference
 */
export type adminPostPricePreferencesIdResponse = {
  data: AdminPricePreferenceResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPricePreferencesIdUrl = (id: string,
    params?: AdminPostPricePreferencesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/price-preferences/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/price-preferences/${id}`
}

export const adminPostPricePreferencesId = async (id: string,
    adminUpdatePricePreference: AdminUpdatePricePreference,
    params?: AdminPostPricePreferencesIdParams, options?: RequestInit): Promise<adminPostPricePreferencesIdResponse> => {
  
  return customFetch<Promise<adminPostPricePreferencesIdResponse>>(getAdminPostPricePreferencesIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdatePricePreference,)
  }
);}



/**
 * Delete a price preference.
 * @summary Delete a Price Preference
 */
export type adminDeletePricePreferencesIdResponse = {
  data: AdminPricePreferenceDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeletePricePreferencesIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/price-preferences/${id}`
}

export const adminDeletePricePreferencesId = async (id: string, options?: RequestInit): Promise<adminDeletePricePreferencesIdResponse> => {
  
  return customFetch<Promise<adminDeletePricePreferencesIdResponse>>(getAdminDeletePricePreferencesIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of product categories. The product categories can be filtered by fields such as `id`. The product categories can also be sorted or paginated.
 * @summary List Product Categories
 */
export type adminGetProductCategoriesResponse = {
  data: AdminProductCategoryListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetProductCategoriesUrl = (params?: AdminGetProductCategoriesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-categories?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-categories`
}

export const adminGetProductCategories = async (params?: AdminGetProductCategoriesParams, options?: RequestInit): Promise<adminGetProductCategoriesResponse> => {
  
  return customFetch<Promise<adminGetProductCategoriesResponse>>(getAdminGetProductCategoriesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a product category.
 * @summary Create Product Category
 */
export type adminPostProductCategoriesResponse = {
  data: AdminProductCategoryResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductCategoriesUrl = (params?: AdminPostProductCategoriesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-categories?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-categories`
}

export const adminPostProductCategories = async (adminCreateProductCategory: AdminCreateProductCategory,
    params?: AdminPostProductCategoriesParams, options?: RequestInit): Promise<adminPostProductCategoriesResponse> => {
  
  return customFetch<Promise<adminPostProductCategoriesResponse>>(getAdminPostProductCategoriesUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateProductCategory,)
  }
);}



/**
 * Retrieve a product category by its ID. You can expand the product category's relations or select the fields that should be returned.
 * @summary Get a Product Category
 */
export type adminGetProductCategoriesIdResponse = {
  data: AdminProductCategoryResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetProductCategoriesIdUrl = (id: string,
    params?: AdminGetProductCategoriesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-categories/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-categories/${id}`
}

export const adminGetProductCategoriesId = async (id: string,
    params?: AdminGetProductCategoriesIdParams, options?: RequestInit): Promise<adminGetProductCategoriesIdResponse> => {
  
  return customFetch<Promise<adminGetProductCategoriesIdResponse>>(getAdminGetProductCategoriesIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a product category's details.
 * @summary Update a Product Category
 */
export type adminPostProductCategoriesIdResponse = {
  data: AdminProductCategoryResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductCategoriesIdUrl = (id: string,
    params?: AdminPostProductCategoriesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-categories/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-categories/${id}`
}

export const adminPostProductCategoriesId = async (id: string,
    adminPostProductCategoriesIdBody: AdminPostProductCategoriesIdBody,
    params?: AdminPostProductCategoriesIdParams, options?: RequestInit): Promise<adminPostProductCategoriesIdResponse> => {
  
  return customFetch<Promise<adminPostProductCategoriesIdResponse>>(getAdminPostProductCategoriesIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostProductCategoriesIdBody,)
  }
);}



/**
 * Delete a product category. This doesn't deleted products in that category.
 * @summary Delete a Product Category
 */
export type adminDeleteProductCategoriesIdResponse = {
  data: AdminProductCategoryDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteProductCategoriesIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/product-categories/${id}`
}

export const adminDeleteProductCategoriesId = async (id: string, options?: RequestInit): Promise<adminDeleteProductCategoriesIdResponse> => {
  
  return customFetch<Promise<adminDeleteProductCategoriesIdResponse>>(getAdminDeleteProductCategoriesIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Manage products of a category to add or remove them.
 * @summary Manage Products in Product Category
 */
export type adminPostProductCategoriesIdProductsResponse = {
  data: AdminProductCategoryResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductCategoriesIdProductsUrl = (id: string,
    params?: AdminPostProductCategoriesIdProductsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-categories/${id}/products?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-categories/${id}/products`
}

export const adminPostProductCategoriesIdProducts = async (id: string,
    adminPostProductCategoriesIdProductsBody: AdminPostProductCategoriesIdProductsBody,
    params?: AdminPostProductCategoriesIdProductsParams, options?: RequestInit): Promise<adminPostProductCategoriesIdProductsResponse> => {
  
  return customFetch<Promise<adminPostProductCategoriesIdProductsResponse>>(getAdminPostProductCategoriesIdProductsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostProductCategoriesIdProductsBody,)
  }
);}



/**
 * Retrieve a list of product tags. The product tags can be filtered by fields such as `id`. The product tags can also be sorted or paginated.
 * @summary List Product Tags
 */
export type adminGetProductTagsResponse = {
  data: AdminProductTagListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetProductTagsUrl = (params?: AdminGetProductTagsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-tags?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-tags`
}

export const adminGetProductTags = async (params?: AdminGetProductTagsParams, options?: RequestInit): Promise<adminGetProductTagsResponse> => {
  
  return customFetch<Promise<adminGetProductTagsResponse>>(getAdminGetProductTagsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a product tag.
 * @summary Create Product Tag
 */
export type adminPostProductTagsResponse = {
  data: AdminProductTagResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductTagsUrl = (params?: AdminPostProductTagsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-tags?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-tags`
}

export const adminPostProductTags = async (adminCreateProductTag: AdminCreateProductTag,
    params?: AdminPostProductTagsParams, options?: RequestInit): Promise<adminPostProductTagsResponse> => {
  
  return customFetch<Promise<adminPostProductTagsResponse>>(getAdminPostProductTagsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateProductTag,)
  }
);}



/**
 * Retrieve a product tag by its ID. You can expand the product tag's relations or select the fields that should be returned.
 * @summary Get a Product Tag
 */
export type adminGetProductTagsIdResponse = {
  data: AdminProductTagResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetProductTagsIdUrl = (id: string,
    params?: AdminGetProductTagsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-tags/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-tags/${id}`
}

export const adminGetProductTagsId = async (id: string,
    params?: AdminGetProductTagsIdParams, options?: RequestInit): Promise<adminGetProductTagsIdResponse> => {
  
  return customFetch<Promise<adminGetProductTagsIdResponse>>(getAdminGetProductTagsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a product tag's details.
 * @summary Update a Product Tag
 */
export type adminPostProductTagsIdResponse = {
  data: AdminProductTagResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductTagsIdUrl = (id: string,
    params?: AdminPostProductTagsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-tags/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-tags/${id}`
}

export const adminPostProductTagsId = async (id: string,
    adminPostProductTagsIdBody: AdminPostProductTagsIdBody,
    params?: AdminPostProductTagsIdParams, options?: RequestInit): Promise<adminPostProductTagsIdResponse> => {
  
  return customFetch<Promise<adminPostProductTagsIdResponse>>(getAdminPostProductTagsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostProductTagsIdBody,)
  }
);}



/**
 * Delete a product tag. This doesn't delete products using the tag.
 * @summary Delete a Product Tag
 */
export type adminDeleteProductTagsIdResponse = {
  data: AdminProductTagDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteProductTagsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/product-tags/${id}`
}

export const adminDeleteProductTagsId = async (id: string, options?: RequestInit): Promise<adminDeleteProductTagsIdResponse> => {
  
  return customFetch<Promise<adminDeleteProductTagsIdResponse>>(getAdminDeleteProductTagsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of product types. The product types can be filtered by fields such as `id`. The product types can also be sorted or paginated.
 * @summary List Product Types
 */
export type adminGetProductTypesResponse = {
  data: AdminProductTypeListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetProductTypesUrl = (params?: AdminGetProductTypesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-types?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-types`
}

export const adminGetProductTypes = async (params?: AdminGetProductTypesParams, options?: RequestInit): Promise<adminGetProductTypesResponse> => {
  
  return customFetch<Promise<adminGetProductTypesResponse>>(getAdminGetProductTypesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a product type.
 * @summary Create Product Type
 */
export type adminPostProductTypesResponse = {
  data: AdminProductTypeResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductTypesUrl = (params?: AdminPostProductTypesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-types?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-types`
}

export const adminPostProductTypes = async (adminCreateProductType: AdminCreateProductType,
    params?: AdminPostProductTypesParams, options?: RequestInit): Promise<adminPostProductTypesResponse> => {
  
  return customFetch<Promise<adminPostProductTypesResponse>>(getAdminPostProductTypesUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateProductType,)
  }
);}



/**
 * Retrieve a product type by its ID. You can expand the product type's relations or select the fields that should be returned.
 * @summary Get a Product Type
 */
export type adminGetProductTypesIdResponse = {
  data: AdminProductTypeResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetProductTypesIdUrl = (id: string,
    params?: AdminGetProductTypesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-types/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-types/${id}`
}

export const adminGetProductTypesId = async (id: string,
    params?: AdminGetProductTypesIdParams, options?: RequestInit): Promise<adminGetProductTypesIdResponse> => {
  
  return customFetch<Promise<adminGetProductTypesIdResponse>>(getAdminGetProductTypesIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a product type's details.
 * @summary Update a Product Type
 */
export type adminPostProductTypesIdResponse = {
  data: AdminProductTypeResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductTypesIdUrl = (id: string,
    params?: AdminPostProductTypesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-types/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-types/${id}`
}

export const adminPostProductTypesId = async (id: string,
    adminPostProductTypesIdBody: AdminPostProductTypesIdBody,
    params?: AdminPostProductTypesIdParams, options?: RequestInit): Promise<adminPostProductTypesIdResponse> => {
  
  return customFetch<Promise<adminPostProductTypesIdResponse>>(getAdminPostProductTypesIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostProductTypesIdBody,)
  }
);}



/**
 * Delete a product type. This doesn't delete products of this type.
 * @summary Delete a Product Type
 */
export type adminDeleteProductTypesIdResponse = {
  data: AdminProductTypeDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteProductTypesIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/product-types/${id}`
}

export const adminDeleteProductTypesId = async (id: string, options?: RequestInit): Promise<adminDeleteProductTypesIdResponse> => {
  
  return customFetch<Promise<adminDeleteProductTypesIdResponse>>(getAdminDeleteProductTypesIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of product variants. The product variants can be filtered by fields such as `id`. The product variants can also be sorted or paginated.
 * @summary List Product Variants
 */
export type adminGetProductVariantsResponse = {
  data: AdminGetProductVariants200;
  status: number;
  headers: Headers;
}

export const getAdminGetProductVariantsUrl = (params?: AdminGetProductVariantsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/product-variants?${normalizedParams.toString()}` : `http://localhost:9000/admin/product-variants`
}

export const adminGetProductVariants = async (params?: AdminGetProductVariantsParams, options?: RequestInit): Promise<adminGetProductVariantsResponse> => {
  
  return customFetch<Promise<adminGetProductVariantsResponse>>(getAdminGetProductVariantsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a list of products. The products can be filtered by fields such as `id`. The products can also be sorted or paginated.
 * @summary List Products
 */
export type adminGetProductsResponse = {
  data: AdminGetProducts200;
  status: number;
  headers: Headers;
}

export const getAdminGetProductsUrl = (params?: AdminGetProductsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products?${normalizedParams.toString()}` : `http://localhost:9000/admin/products`
}

export const adminGetProducts = async (params?: AdminGetProductsParams, options?: RequestInit): Promise<adminGetProductsResponse> => {
  
  return customFetch<Promise<adminGetProductsResponse>>(getAdminGetProductsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a product.
 * @summary Create Product
 */
export type adminPostProductsResponse = {
  data: AdminProductResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsUrl = (params?: AdminPostProductsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products?${normalizedParams.toString()}` : `http://localhost:9000/admin/products`
}

export const adminPostProducts = async (adminPostProductsBody: AdminPostProductsBody,
    params?: AdminPostProductsParams, options?: RequestInit): Promise<adminPostProductsResponse> => {
  
  return customFetch<Promise<adminPostProductsResponse>>(getAdminPostProductsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostProductsBody,)
  }
);}



/**
 * Manage products to create, update, or delete them.
 * @summary Manage Products
 */
export type adminPostProductsBatchResponse = {
  data: AdminBatchProductResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsBatchUrl = (params?: AdminPostProductsBatchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/batch?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/batch`
}

export const adminPostProductsBatch = async (adminBatchProductRequest: AdminBatchProductRequest,
    params?: AdminPostProductsBatchParams, options?: RequestInit): Promise<adminPostProductsBatchResponse> => {
  
  return customFetch<Promise<adminPostProductsBatchResponse>>(getAdminPostProductsBatchUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminBatchProductRequest,)
  }
);}



/**
 * Start a product export process to retrieve a CSV of exported products.

You'll receive in the response the transaction ID of the workflow generating the CSV file. To check the status of the execution, send a GET request to `/admin/workflows-executions/export-products/:transaction-id`.
Once the execution finishes successfully, a notification is created for the export. You can retrieve the notifications using the `/admin/notification` API route to retrieve the file's download URL.

 * @summary Export Products
 */
export type adminPostProductsExportResponse = {
  data: AdminExportProductResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsExportUrl = (params?: AdminPostProductsExportParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/export?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/export`
}

export const adminPostProductsExport = async (params?: AdminPostProductsExportParams, options?: RequestInit): Promise<adminPostProductsExportResponse> => {
  
  return customFetch<Promise<adminPostProductsExportResponse>>(getAdminPostProductsExportUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Create a new product import process. The products aren't imported until the import is confirmed with the `/admin/products/:transaction-id/import` API route.
 * @summary Create Product Import
 */
export type adminPostProductsImportResponse = {
  data: AdminImportProductResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsImportUrl = () => {


  return `http://localhost:9000/admin/products/import`
}

export const adminPostProductsImport = async (adminImportProductRequest: AdminImportProductRequest, options?: RequestInit): Promise<adminPostProductsImportResponse> => {
  
  return customFetch<Promise<adminPostProductsImportResponse>>(getAdminPostProductsImportUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminImportProductRequest,)
  }
);}



/**
 * Confirm that a created product import should start importing the products into Medusa.
 * @summary Confirm Product Import
 */
export type adminPostProductsImportTransactionIdConfirmResponse = {
  data: unknown;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsImportTransactionIdConfirmUrl = (transactionId: string,) => {


  return `http://localhost:9000/admin/products/import/${transactionId}/confirm`
}

export const adminPostProductsImportTransactionIdConfirm = async (transactionId: string, options?: RequestInit): Promise<adminPostProductsImportTransactionIdConfirmResponse> => {
  
  return customFetch<Promise<adminPostProductsImportTransactionIdConfirmResponse>>(getAdminPostProductsImportTransactionIdConfirmUrl(transactionId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Retrieve a product by its ID. You can expand the product's relations or select the fields that should be returned.
 * @summary Get a Product
 */
export type adminGetProductsIdResponse = {
  data: AdminProductResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetProductsIdUrl = (id: string,
    params?: AdminGetProductsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}`
}

export const adminGetProductsId = async (id: string,
    params?: AdminGetProductsIdParams, options?: RequestInit): Promise<adminGetProductsIdResponse> => {
  
  return customFetch<Promise<adminGetProductsIdResponse>>(getAdminGetProductsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a product's details.
 * @summary Update a Product
 */
export type adminPostProductsIdResponse = {
  data: AdminProductResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsIdUrl = (id: string,
    params?: AdminPostProductsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}`
}

export const adminPostProductsId = async (id: string,
    adminPostProductsIdBody: AdminPostProductsIdBody,
    params?: AdminPostProductsIdParams, options?: RequestInit): Promise<adminPostProductsIdResponse> => {
  
  return customFetch<Promise<adminPostProductsIdResponse>>(getAdminPostProductsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostProductsIdBody,)
  }
);}



/**
 * Delete a product.
 * @summary Delete a Product
 */
export type adminDeleteProductsIdResponse = {
  data: AdminProductDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteProductsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/products/${id}`
}

export const adminDeleteProductsId = async (id: string, options?: RequestInit): Promise<adminDeleteProductsIdResponse> => {
  
  return customFetch<Promise<adminDeleteProductsIdResponse>>(getAdminDeleteProductsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of options of a product. The options can be filtered by fields like `id`. The options can also be paginated.
 * @summary List a Product's Options
 */
export type adminGetProductsIdOptionsResponse = {
  data: AdminGetProductsIdOptions200;
  status: number;
  headers: Headers;
}

export const getAdminGetProductsIdOptionsUrl = (id: string,
    params?: AdminGetProductsIdOptionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/options?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/options`
}

export const adminGetProductsIdOptions = async (id: string,
    params?: AdminGetProductsIdOptionsParams, options?: RequestInit): Promise<adminGetProductsIdOptionsResponse> => {
  
  return customFetch<Promise<adminGetProductsIdOptionsResponse>>(getAdminGetProductsIdOptionsUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create an option for a product.
 * @summary Create a Product Option
 */
export type adminPostProductsIdOptionsResponse = {
  data: AdminProductResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsIdOptionsUrl = (id: string,
    params?: AdminPostProductsIdOptionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/options?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/options`
}

export const adminPostProductsIdOptions = async (id: string,
    adminPostProductsIdOptionsBody: AdminPostProductsIdOptionsBody,
    params?: AdminPostProductsIdOptionsParams, options?: RequestInit): Promise<adminPostProductsIdOptionsResponse> => {
  
  return customFetch<Promise<adminPostProductsIdOptionsResponse>>(getAdminPostProductsIdOptionsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostProductsIdOptionsBody,)
  }
);}



/**
 * Retrieve a product's option by its ID.
 * @summary Get a Product's Option
 */
export type adminGetProductsIdOptionsOptionIdResponse = {
  data: AdminProductOptionResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetProductsIdOptionsOptionIdUrl = (id: string,
    optionId: string,
    params?: AdminGetProductsIdOptionsOptionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/options/${optionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/options/${optionId}`
}

export const adminGetProductsIdOptionsOptionId = async (id: string,
    optionId: string,
    params?: AdminGetProductsIdOptionsOptionIdParams, options?: RequestInit): Promise<adminGetProductsIdOptionsOptionIdResponse> => {
  
  return customFetch<Promise<adminGetProductsIdOptionsOptionIdResponse>>(getAdminGetProductsIdOptionsOptionIdUrl(id,optionId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update the details of a product option.
 * @summary Update a Product's Option
 */
export type adminPostProductsIdOptionsOptionIdResponse = {
  data: AdminProductResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsIdOptionsOptionIdUrl = (id: string,
    optionId: string,
    params?: AdminPostProductsIdOptionsOptionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/options/${optionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/options/${optionId}`
}

export const adminPostProductsIdOptionsOptionId = async (id: string,
    optionId: string,
    adminPostProductsIdOptionsOptionIdBody: AdminPostProductsIdOptionsOptionIdBody,
    params?: AdminPostProductsIdOptionsOptionIdParams, options?: RequestInit): Promise<adminPostProductsIdOptionsOptionIdResponse> => {
  
  return customFetch<Promise<adminPostProductsIdOptionsOptionIdResponse>>(getAdminPostProductsIdOptionsOptionIdUrl(id,optionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostProductsIdOptionsOptionIdBody,)
  }
);}



/**
 * Delete an option from a product.

Values of this option in the product's variants are removed.

 * @summary Delete an Option from Product
 */
export type adminDeleteProductsIdOptionsOptionIdResponse = {
  data: AdminProductOptionDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteProductsIdOptionsOptionIdUrl = (id: string,
    optionId: string,
    params?: AdminDeleteProductsIdOptionsOptionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/options/${optionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/options/${optionId}`
}

export const adminDeleteProductsIdOptionsOptionId = async (id: string,
    optionId: string,
    params?: AdminDeleteProductsIdOptionsOptionIdParams, options?: RequestInit): Promise<adminDeleteProductsIdOptionsOptionIdResponse> => {
  
  return customFetch<Promise<adminDeleteProductsIdOptionsOptionIdResponse>>(getAdminDeleteProductsIdOptionsOptionIdUrl(id,optionId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of variants in a product. The variants can be filtered by fields like FILTER FIELDS. The variants can also be paginated.
 * @summary List Variants of a Product
 */
export type adminGetProductsIdVariantsResponse = {
  data: AdminGetProductsIdVariants200;
  status: number;
  headers: Headers;
}

export const getAdminGetProductsIdVariantsUrl = (id: string,
    params?: AdminGetProductsIdVariantsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/variants?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/variants`
}

export const adminGetProductsIdVariants = async (id: string,
    params?: AdminGetProductsIdVariantsParams, options?: RequestInit): Promise<adminGetProductsIdVariantsResponse> => {
  
  return customFetch<Promise<adminGetProductsIdVariantsResponse>>(getAdminGetProductsIdVariantsUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a variant for a product.
 * @summary Create a Product Variant
 */
export type adminPostProductsIdVariantsResponse = {
  data: AdminProductResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsIdVariantsUrl = (id: string,
    params?: AdminPostProductsIdVariantsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/variants?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/variants`
}

export const adminPostProductsIdVariants = async (id: string,
    adminPostProductsIdVariantsBody: AdminPostProductsIdVariantsBody,
    params?: AdminPostProductsIdVariantsParams, options?: RequestInit): Promise<adminPostProductsIdVariantsResponse> => {
  
  return customFetch<Promise<adminPostProductsIdVariantsResponse>>(getAdminPostProductsIdVariantsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostProductsIdVariantsBody,)
  }
);}



/**
 * Manage variants in a product to create, update, or delete them.
 * @summary Manage Variants in a Product
 */
export type adminPostProductsIdVariantsBatchResponse = {
  data: AdminBatchProductVariantResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsIdVariantsBatchUrl = (id: string,
    params?: AdminPostProductsIdVariantsBatchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/variants/batch?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/variants/batch`
}

export const adminPostProductsIdVariantsBatch = async (id: string,
    adminBatchProductVariantRequest: AdminBatchProductVariantRequest,
    params?: AdminPostProductsIdVariantsBatchParams, options?: RequestInit): Promise<adminPostProductsIdVariantsBatchResponse> => {
  
  return customFetch<Promise<adminPostProductsIdVariantsBatchResponse>>(getAdminPostProductsIdVariantsBatchUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminBatchProductVariantRequest,)
  }
);}



/**
 * Manage a product's variant's inventoris to associate them with inventory items, update their inventory items, or delete their association with inventory items.
 * @summary Manage Variants Inventory in a Product
 */
export type adminPostProductsIdVariantsInventoryItemsBatchResponse = {
  data: AdminProductVariantInventoryBatchResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsIdVariantsInventoryItemsBatchUrl = (id: string,) => {


  return `http://localhost:9000/admin/products/${id}/variants/inventory-items/batch`
}

export const adminPostProductsIdVariantsInventoryItemsBatch = async (id: string,
    adminPostProductsIdVariantsInventoryItemsBatchBody: AdminPostProductsIdVariantsInventoryItemsBatchBody, options?: RequestInit): Promise<adminPostProductsIdVariantsInventoryItemsBatchResponse> => {
  
  return customFetch<Promise<adminPostProductsIdVariantsInventoryItemsBatchResponse>>(getAdminPostProductsIdVariantsInventoryItemsBatchUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostProductsIdVariantsInventoryItemsBatchBody,)
  }
);}



/**
 * Retrieve a product's variant by its ID.
 * @summary Get Variant of a Product
 */
export type adminGetProductsIdVariantsVariantIdResponse = {
  data: AdminProductVariantResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetProductsIdVariantsVariantIdUrl = (id: string,
    variantId: string,
    params?: AdminGetProductsIdVariantsVariantIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/variants/${variantId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/variants/${variantId}`
}

export const adminGetProductsIdVariantsVariantId = async (id: string,
    variantId: string,
    params?: AdminGetProductsIdVariantsVariantIdParams, options?: RequestInit): Promise<adminGetProductsIdVariantsVariantIdResponse> => {
  
  return customFetch<Promise<adminGetProductsIdVariantsVariantIdResponse>>(getAdminGetProductsIdVariantsVariantIdUrl(id,variantId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a variant's details.
 * @summary Update a Product Variant
 */
export type adminPostProductsIdVariantsVariantIdResponse = {
  data: AdminProductResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsIdVariantsVariantIdUrl = (id: string,
    variantId: string,
    params?: AdminPostProductsIdVariantsVariantIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/variants/${variantId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/variants/${variantId}`
}

export const adminPostProductsIdVariantsVariantId = async (id: string,
    variantId: string,
    adminPostProductsIdVariantsVariantIdBody: AdminPostProductsIdVariantsVariantIdBody,
    params?: AdminPostProductsIdVariantsVariantIdParams, options?: RequestInit): Promise<adminPostProductsIdVariantsVariantIdResponse> => {
  
  return customFetch<Promise<adminPostProductsIdVariantsVariantIdResponse>>(getAdminPostProductsIdVariantsVariantIdUrl(id,variantId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostProductsIdVariantsVariantIdBody,)
  }
);}



/**
 * Delete a variant of a product.
 * @summary Delete Product Variant
 */
export type adminDeleteProductsIdVariantsVariantIdResponse = {
  data: AdminProductVariantDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteProductsIdVariantsVariantIdUrl = (id: string,
    variantId: string,
    params?: AdminDeleteProductsIdVariantsVariantIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/variants/${variantId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/variants/${variantId}`
}

export const adminDeleteProductsIdVariantsVariantId = async (id: string,
    variantId: string,
    params?: AdminDeleteProductsIdVariantsVariantIdParams, options?: RequestInit): Promise<adminDeleteProductsIdVariantsVariantIdResponse> => {
  
  return customFetch<Promise<adminDeleteProductsIdVariantsVariantIdResponse>>(getAdminDeleteProductsIdVariantsVariantIdUrl(id,variantId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Associate with a product variant an inventory item that manages its inventory details.
 * @summary Associate Variant with Inventory Item
 */
export type adminPostProductsIdVariantsVariantIdInventoryItemsResponse = {
  data: AdminProductVariantResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsIdVariantsVariantIdInventoryItemsUrl = (id: string,
    variantId: string,
    params?: AdminPostProductsIdVariantsVariantIdInventoryItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/variants/${variantId}/inventory-items?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/variants/${variantId}/inventory-items`
}

export const adminPostProductsIdVariantsVariantIdInventoryItems = async (id: string,
    variantId: string,
    adminCreateVariantInventoryItem: AdminCreateVariantInventoryItem,
    params?: AdminPostProductsIdVariantsVariantIdInventoryItemsParams, options?: RequestInit): Promise<adminPostProductsIdVariantsVariantIdInventoryItemsResponse> => {
  
  return customFetch<Promise<adminPostProductsIdVariantsVariantIdInventoryItemsResponse>>(getAdminPostProductsIdVariantsVariantIdInventoryItemsUrl(id,variantId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateVariantInventoryItem,)
  }
);}



/**
 * Update the inventory item that manages the inventory details of a product variant.
 * @summary Update Product Variant's Inventory Details
 */
export type adminPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse = {
  data: AdminProductVariantResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdUrl = (id: string,
    variantId: string,
    inventoryItemId: string,
    params?: AdminPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/variants/${variantId}/inventory-items/${inventoryItemId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/variants/${variantId}/inventory-items/${inventoryItemId}`
}

export const adminPostProductsIdVariantsVariantIdInventoryItemsInventoryItemId = async (id: string,
    variantId: string,
    inventoryItemId: string,
    adminUpdateVariantInventoryItem: AdminUpdateVariantInventoryItem,
    params?: AdminPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, options?: RequestInit): Promise<adminPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse> => {
  
  return customFetch<Promise<adminPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse>>(getAdminPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdUrl(id,variantId,inventoryItemId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateVariantInventoryItem,)
  }
);}



/**
 * Remove the association between an inventory item and its product variant.
 * @summary Remove Inventory Item Association with Product Variant
 */
export type adminDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse = {
  data: AdminProductVariantInventoryLinkDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdUrl = (id: string,
    variantId: string,
    inventoryItemId: string,
    params?: AdminDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/products/${id}/variants/${variantId}/inventory-items/${inventoryItemId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/products/${id}/variants/${variantId}/inventory-items/${inventoryItemId}`
}

export const adminDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemId = async (id: string,
    variantId: string,
    inventoryItemId: string,
    params?: AdminDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, options?: RequestInit): Promise<adminDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse> => {
  
  return customFetch<Promise<adminDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse>>(getAdminDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdUrl(id,variantId,inventoryItemId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of promotions. The promotions can be filtered by fields such as `id`. The promotions can also be sorted or paginated.
 * @summary List Promotions
 */
export type adminGetPromotionsResponse = {
  data: AdminGetPromotions200;
  status: number;
  headers: Headers;
}

export const getAdminGetPromotionsUrl = (params?: AdminGetPromotionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/promotions?${normalizedParams.toString()}` : `http://localhost:9000/admin/promotions`
}

export const adminGetPromotions = async (params?: AdminGetPromotionsParams, options?: RequestInit): Promise<adminGetPromotionsResponse> => {
  
  return customFetch<Promise<adminGetPromotionsResponse>>(getAdminGetPromotionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a promotion.
 * @summary Create Promotion
 */
export type adminPostPromotionsResponse = {
  data: AdminPromotionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPromotionsUrl = (params?: AdminPostPromotionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/promotions?${normalizedParams.toString()}` : `http://localhost:9000/admin/promotions`
}

export const adminPostPromotions = async (adminPostPromotionsBody: AdminPostPromotionsBody,
    params?: AdminPostPromotionsParams, options?: RequestInit): Promise<adminPostPromotionsResponse> => {
  
  return customFetch<Promise<adminPostPromotionsResponse>>(getAdminPostPromotionsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostPromotionsBody,)
  }
);}



/**
 * Retrieve a list of potential rule attributes for the promotion and application method types specified in the query parameters.
Only the attributes of the rule type specified in the path parameter are retrieved:
- If `rule_type` is `rules`, the attributes of the promotion's type are retrieved.

- If `rule_type` is `target-rules`, the target rules' attributes of the application method's type are retrieved.

- If `rule_type` is `buy-rules`, the buy rules' attributes of the application method's type are retrieved.

 * @summary List Rule Attribute Options of a Rule Type
 */
export type adminGetPromotionsRuleAttributeOptionsRuleTypeResponse = {
  data: AdminGetPromotionsRuleAttributeOptionsRuleType200;
  status: number;
  headers: Headers;
}

export const getAdminGetPromotionsRuleAttributeOptionsRuleTypeUrl = (ruleType: 'rules' | 'target-rules' | 'buy-rules',
    params?: AdminGetPromotionsRuleAttributeOptionsRuleTypeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/promotions/rule-attribute-options/${ruleType}?${normalizedParams.toString()}` : `http://localhost:9000/admin/promotions/rule-attribute-options/${ruleType}`
}

export const adminGetPromotionsRuleAttributeOptionsRuleType = async (ruleType: 'rules' | 'target-rules' | 'buy-rules',
    params?: AdminGetPromotionsRuleAttributeOptionsRuleTypeParams, options?: RequestInit): Promise<adminGetPromotionsRuleAttributeOptionsRuleTypeResponse> => {
  
  return customFetch<Promise<adminGetPromotionsRuleAttributeOptionsRuleTypeResponse>>(getAdminGetPromotionsRuleAttributeOptionsRuleTypeUrl(ruleType,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve all potential values for promotion rules and target and buy rules based on the specified rule attribute and type.
For example, if you provide the ID of the `currency_code` rule attribute, and set `rule_type` to `rules`, a list of currencies are retrieved in label-value pairs.

 * @summary List Rule Values Given a Rule Attribute
 */
export type adminGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse = {
  data: AdminGetPromotionsRuleValueOptionsRuleTypeRuleAttributeId200;
  status: number;
  headers: Headers;
}

export const getAdminGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdUrl = (ruleType: 'rules' | 'target-rules' | 'buy-rules',
    ruleAttributeId: string,
    params?: AdminGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/promotions/rule-value-options/${ruleType}/${ruleAttributeId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/promotions/rule-value-options/${ruleType}/${ruleAttributeId}`
}

export const adminGetPromotionsRuleValueOptionsRuleTypeRuleAttributeId = async (ruleType: 'rules' | 'target-rules' | 'buy-rules',
    ruleAttributeId: string,
    params?: AdminGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParams, options?: RequestInit): Promise<adminGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse> => {
  
  return customFetch<Promise<adminGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse>>(getAdminGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdUrl(ruleType,ruleAttributeId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a promotion by its ID. You can expand the promotion's relations or select the fields that should be returned.
 * @summary Get a Promotion
 */
export type adminGetPromotionsIdResponse = {
  data: AdminPromotionResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetPromotionsIdUrl = (id: string,
    params?: AdminGetPromotionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/promotions/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/promotions/${id}`
}

export const adminGetPromotionsId = async (id: string,
    params?: AdminGetPromotionsIdParams, options?: RequestInit): Promise<adminGetPromotionsIdResponse> => {
  
  return customFetch<Promise<adminGetPromotionsIdResponse>>(getAdminGetPromotionsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a promotion's details.
 * @summary Update a Promotion
 */
export type adminPostPromotionsIdResponse = {
  data: AdminPromotionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostPromotionsIdUrl = (id: string,
    params?: AdminPostPromotionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/promotions/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/promotions/${id}`
}

export const adminPostPromotionsId = async (id: string,
    adminPostPromotionsIdBody: AdminPostPromotionsIdBody,
    params?: AdminPostPromotionsIdParams, options?: RequestInit): Promise<adminPostPromotionsIdResponse> => {
  
  return customFetch<Promise<adminPostPromotionsIdResponse>>(getAdminPostPromotionsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostPromotionsIdBody,)
  }
);}



/**
 * Delete a promotion.
 * @summary Delete a Promotion
 */
export type adminDeletePromotionsIdResponse = {
  data: AdminDeletePromotionsId200;
  status: number;
  headers: Headers;
}

export const getAdminDeletePromotionsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/promotions/${id}`
}

export const adminDeletePromotionsId = async (id: string, options?: RequestInit): Promise<adminDeletePromotionsIdResponse> => {
  
  return customFetch<Promise<adminDeletePromotionsIdResponse>>(getAdminDeletePromotionsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Manage the buy rules of a `buyget` promotion to create, update, or delete them.
 * @summary Manage the Buy Rules of a Promotion
 */
export type adminPostPromotionsIdBuyRulesBatchResponse = {
  data: AdminPostPromotionsIdBuyRulesBatch200;
  status: number;
  headers: Headers;
}

export const getAdminPostPromotionsIdBuyRulesBatchUrl = (id: string,
    params?: AdminPostPromotionsIdBuyRulesBatchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/promotions/${id}/buy-rules/batch?${normalizedParams.toString()}` : `http://localhost:9000/admin/promotions/${id}/buy-rules/batch`
}

export const adminPostPromotionsIdBuyRulesBatch = async (id: string,
    adminPostPromotionsIdBuyRulesBatchBody: AdminPostPromotionsIdBuyRulesBatchBody,
    params?: AdminPostPromotionsIdBuyRulesBatchParams, options?: RequestInit): Promise<adminPostPromotionsIdBuyRulesBatchResponse> => {
  
  return customFetch<Promise<adminPostPromotionsIdBuyRulesBatchResponse>>(getAdminPostPromotionsIdBuyRulesBatchUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostPromotionsIdBuyRulesBatchBody,)
  }
);}



/**
 * Manage the rules of a promotion to create, update, or delete them.
 * @summary Manage a Promotion's Rules
 */
export type adminPostPromotionsIdRulesBatchResponse = {
  data: AdminPostPromotionsIdRulesBatch200;
  status: number;
  headers: Headers;
}

export const getAdminPostPromotionsIdRulesBatchUrl = (id: string,
    params?: AdminPostPromotionsIdRulesBatchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/promotions/${id}/rules/batch?${normalizedParams.toString()}` : `http://localhost:9000/admin/promotions/${id}/rules/batch`
}

export const adminPostPromotionsIdRulesBatch = async (id: string,
    adminPostPromotionsIdRulesBatchBody: AdminPostPromotionsIdRulesBatchBody,
    params?: AdminPostPromotionsIdRulesBatchParams, options?: RequestInit): Promise<adminPostPromotionsIdRulesBatchResponse> => {
  
  return customFetch<Promise<adminPostPromotionsIdRulesBatchResponse>>(getAdminPostPromotionsIdRulesBatchUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostPromotionsIdRulesBatchBody,)
  }
);}



/**
 * Manage the target rules of a promotion to create, update, or delete them.
 * @summary Manage Target Rules of a Promotion
 */
export type adminPostPromotionsIdTargetRulesBatchResponse = {
  data: AdminPostPromotionsIdTargetRulesBatch200;
  status: number;
  headers: Headers;
}

export const getAdminPostPromotionsIdTargetRulesBatchUrl = (id: string,
    params?: AdminPostPromotionsIdTargetRulesBatchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/promotions/${id}/target-rules/batch?${normalizedParams.toString()}` : `http://localhost:9000/admin/promotions/${id}/target-rules/batch`
}

export const adminPostPromotionsIdTargetRulesBatch = async (id: string,
    adminPostPromotionsIdTargetRulesBatchBody: AdminPostPromotionsIdTargetRulesBatchBody,
    params?: AdminPostPromotionsIdTargetRulesBatchParams, options?: RequestInit): Promise<adminPostPromotionsIdTargetRulesBatchResponse> => {
  
  return customFetch<Promise<adminPostPromotionsIdTargetRulesBatchResponse>>(getAdminPostPromotionsIdTargetRulesBatchUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostPromotionsIdTargetRulesBatchBody,)
  }
);}



/**
 * Retrieve a list of rules in a promotion. The type of rules retrieved depend on the value of the `rule_type` path parameter:
- If `rule_type` is `rules`, the promotion's rules are retrivied. - If `rule_type` is `target-rules`, the target rules of the promotion's application method are retrieved.

- If `rule_type` is `buy-rules`, the buy rules of the promotion's application method are retrieved.

 * @summary List Rules of a Promotion
 */
export type adminGetPromotionsIdRuleTypeResponse = {
  data: AdminGetPromotionsIdRuleType200;
  status: number;
  headers: Headers;
}

export const getAdminGetPromotionsIdRuleTypeUrl = (id: string,
    ruleType: 'rules' | 'target-rules' | 'buy-rules',
    params?: AdminGetPromotionsIdRuleTypeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/promotions/${id}/${ruleType}?${normalizedParams.toString()}` : `http://localhost:9000/admin/promotions/${id}/${ruleType}`
}

export const adminGetPromotionsIdRuleType = async (id: string,
    ruleType: 'rules' | 'target-rules' | 'buy-rules',
    params?: AdminGetPromotionsIdRuleTypeParams, options?: RequestInit): Promise<adminGetPromotionsIdRuleTypeResponse> => {
  
  return customFetch<Promise<adminGetPromotionsIdRuleTypeResponse>>(getAdminGetPromotionsIdRuleTypeUrl(id,ruleType,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a list of refund reasons. The refund reasons can be filtered by fields such as `id`. The refund reasons can also be sorted or paginated.
 * @summary List Refund Reasons
 */
export type adminGetRefundReasonsResponse = {
  data: AdminGetRefundReasons200;
  status: number;
  headers: Headers;
}

export const getAdminGetRefundReasonsUrl = (params?: AdminGetRefundReasonsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/refund-reasons?${normalizedParams.toString()}` : `http://localhost:9000/admin/refund-reasons`
}

export const adminGetRefundReasons = async (params?: AdminGetRefundReasonsParams, options?: RequestInit): Promise<adminGetRefundReasonsResponse> => {
  
  return customFetch<Promise<adminGetRefundReasonsResponse>>(getAdminGetRefundReasonsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a refund reason.
 * @summary Create Refund Reason
 */
export type adminPostRefundReasonsResponse = {
  data: RefundReasonResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostRefundReasonsUrl = (params?: AdminPostRefundReasonsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/refund-reasons?${normalizedParams.toString()}` : `http://localhost:9000/admin/refund-reasons`
}

export const adminPostRefundReasons = async (adminCreateRefundReason: AdminCreateRefundReason,
    params?: AdminPostRefundReasonsParams, options?: RequestInit): Promise<adminPostRefundReasonsResponse> => {
  
  return customFetch<Promise<adminPostRefundReasonsResponse>>(getAdminPostRefundReasonsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateRefundReason,)
  }
);}



/**
 * Retrieve a refund reason by its ID. You can expand the refund reason's relations or select the fields that should be returned.
 * @summary Get a Refund Reason
 */
export type adminGetRefundReasonsIdResponse = {
  data: RefundReasonResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetRefundReasonsIdUrl = (id: string,
    params?: AdminGetRefundReasonsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/refund-reasons/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/refund-reasons/${id}`
}

export const adminGetRefundReasonsId = async (id: string,
    params?: AdminGetRefundReasonsIdParams, options?: RequestInit): Promise<adminGetRefundReasonsIdResponse> => {
  
  return customFetch<Promise<adminGetRefundReasonsIdResponse>>(getAdminGetRefundReasonsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a refund reason's details.
 * @summary Update a Refund Reason
 */
export type adminPostRefundReasonsIdResponse = {
  data: RefundReasonResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostRefundReasonsIdUrl = (id: string,
    params?: AdminPostRefundReasonsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/refund-reasons/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/refund-reasons/${id}`
}

export const adminPostRefundReasonsId = async (id: string,
    adminPostRefundReasonsIdBody: AdminPostRefundReasonsIdBody,
    params?: AdminPostRefundReasonsIdParams, options?: RequestInit): Promise<adminPostRefundReasonsIdResponse> => {
  
  return customFetch<Promise<adminPostRefundReasonsIdResponse>>(getAdminPostRefundReasonsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostRefundReasonsIdBody,)
  }
);}



/**
 * Delete a refund reason.
 * @summary Delete a Refund Reason
 */
export type adminDeleteRefundReasonsIdResponse = {
  data: AdminDeleteRefundReasonsId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteRefundReasonsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/refund-reasons/${id}`
}

export const adminDeleteRefundReasonsId = async (id: string, options?: RequestInit): Promise<adminDeleteRefundReasonsIdResponse> => {
  
  return customFetch<Promise<adminDeleteRefundReasonsIdResponse>>(getAdminDeleteRefundReasonsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of regions. The regions can be filtered by fields such as `id`. The regions can also be sorted or paginated.
 * @summary List Regions
 */
export type adminGetRegionsResponse = {
  data: AdminGetRegions200;
  status: number;
  headers: Headers;
}

export const getAdminGetRegionsUrl = (params?: AdminGetRegionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/regions?${normalizedParams.toString()}` : `http://localhost:9000/admin/regions`
}

export const adminGetRegions = async (params?: AdminGetRegionsParams, options?: RequestInit): Promise<adminGetRegionsResponse> => {
  
  return customFetch<Promise<adminGetRegionsResponse>>(getAdminGetRegionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a region.
 * @summary Create Region
 */
export type adminPostRegionsResponse = {
  data: AdminRegionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostRegionsUrl = (params?: AdminPostRegionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/regions?${normalizedParams.toString()}` : `http://localhost:9000/admin/regions`
}

export const adminPostRegions = async (adminCreateRegion: AdminCreateRegion,
    params?: AdminPostRegionsParams, options?: RequestInit): Promise<adminPostRegionsResponse> => {
  
  return customFetch<Promise<adminPostRegionsResponse>>(getAdminPostRegionsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateRegion,)
  }
);}



/**
 * Retrieve a region by its ID. You can expand the region's relations or select the fields that should be returned.
 * @summary Get a Region
 */
export type adminGetRegionsIdResponse = {
  data: AdminRegionResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetRegionsIdUrl = (id: string,
    params?: AdminGetRegionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/regions/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/regions/${id}`
}

export const adminGetRegionsId = async (id: string,
    params?: AdminGetRegionsIdParams, options?: RequestInit): Promise<adminGetRegionsIdResponse> => {
  
  return customFetch<Promise<adminGetRegionsIdResponse>>(getAdminGetRegionsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a region's details.
 * @summary Update a Region
 */
export type adminPostRegionsIdResponse = {
  data: AdminRegionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostRegionsIdUrl = (id: string,
    params?: AdminPostRegionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/regions/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/regions/${id}`
}

export const adminPostRegionsId = async (id: string,
    adminPostRegionsIdBody: AdminPostRegionsIdBody,
    params?: AdminPostRegionsIdParams, options?: RequestInit): Promise<adminPostRegionsIdResponse> => {
  
  return customFetch<Promise<adminPostRegionsIdResponse>>(getAdminPostRegionsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostRegionsIdBody,)
  }
);}



/**
 * Delete a region.
 * @summary Delete a Region
 */
export type adminDeleteRegionsIdResponse = {
  data: AdminDeleteRegionsId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteRegionsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/regions/${id}`
}

export const adminDeleteRegionsId = async (id: string, options?: RequestInit): Promise<adminDeleteRegionsIdResponse> => {
  
  return customFetch<Promise<adminDeleteRegionsIdResponse>>(getAdminDeleteRegionsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of reservations. The reservations can be filtered by fields such as `id`. The reservations can also be sorted or paginated.
 * @summary List Reservations
 */
export type adminGetReservationsResponse = {
  data: AdminGetReservations200;
  status: number;
  headers: Headers;
}

export const getAdminGetReservationsUrl = (params?: AdminGetReservationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/reservations?${normalizedParams.toString()}` : `http://localhost:9000/admin/reservations`
}

export const adminGetReservations = async (params?: AdminGetReservationsParams, options?: RequestInit): Promise<adminGetReservationsResponse> => {
  
  return customFetch<Promise<adminGetReservationsResponse>>(getAdminGetReservationsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a reservation.
 * @summary Create Reservation
 */
export type adminPostReservationsResponse = {
  data: AdminReservationResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReservationsUrl = (params?: AdminPostReservationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/reservations?${normalizedParams.toString()}` : `http://localhost:9000/admin/reservations`
}

export const adminPostReservations = async (adminCreateReservation: AdminCreateReservation,
    params?: AdminPostReservationsParams, options?: RequestInit): Promise<adminPostReservationsResponse> => {
  
  return customFetch<Promise<adminPostReservationsResponse>>(getAdminPostReservationsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateReservation,)
  }
);}



/**
 * Retrieve a reservation by its ID. You can expand the reservation's relations or select the fields that should be returned.
 * @summary Get a Reservation
 */
export type adminGetReservationsIdResponse = {
  data: AdminReservationResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetReservationsIdUrl = (id: string,
    params?: AdminGetReservationsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/reservations/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/reservations/${id}`
}

export const adminGetReservationsId = async (id: string,
    params?: AdminGetReservationsIdParams, options?: RequestInit): Promise<adminGetReservationsIdResponse> => {
  
  return customFetch<Promise<adminGetReservationsIdResponse>>(getAdminGetReservationsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a reservation's details.
 * @summary Update a Reservation
 */
export type adminPostReservationsIdResponse = {
  data: AdminReservationResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReservationsIdUrl = (id: string,
    params?: AdminPostReservationsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/reservations/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/reservations/${id}`
}

export const adminPostReservationsId = async (id: string,
    adminPostReservationsIdBody: AdminPostReservationsIdBody,
    params?: AdminPostReservationsIdParams, options?: RequestInit): Promise<adminPostReservationsIdResponse> => {
  
  return customFetch<Promise<adminPostReservationsIdResponse>>(getAdminPostReservationsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReservationsIdBody,)
  }
);}



/**
 * Delete a reservation.
 * @summary Delete a Reservation
 */
export type adminDeleteReservationsIdResponse = {
  data: AdminDeleteReservationsId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteReservationsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/reservations/${id}`
}

export const adminDeleteReservationsId = async (id: string, options?: RequestInit): Promise<adminDeleteReservationsIdResponse> => {
  
  return customFetch<Promise<adminDeleteReservationsIdResponse>>(getAdminDeleteReservationsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of return reasons. The return reasons can be filtered by fields such as `id`. The return reasons can also be sorted or paginated.
 * @summary List Return Reasons
 */
export type adminGetReturnReasonsResponse = {
  data: AdminReturnReasonListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetReturnReasonsUrl = (params?: AdminGetReturnReasonsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/return-reasons?${normalizedParams.toString()}` : `http://localhost:9000/admin/return-reasons`
}

export const adminGetReturnReasons = async (params?: AdminGetReturnReasonsParams, options?: RequestInit): Promise<adminGetReturnReasonsResponse> => {
  
  return customFetch<Promise<adminGetReturnReasonsResponse>>(getAdminGetReturnReasonsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a return reason.
 * @summary Create Return Reason
 */
export type adminPostReturnReasonsResponse = {
  data: AdminReturnReasonResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnReasonsUrl = (params?: AdminPostReturnReasonsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/return-reasons?${normalizedParams.toString()}` : `http://localhost:9000/admin/return-reasons`
}

export const adminPostReturnReasons = async (adminCreateReturnReason: AdminCreateReturnReason,
    params?: AdminPostReturnReasonsParams, options?: RequestInit): Promise<adminPostReturnReasonsResponse> => {
  
  return customFetch<Promise<adminPostReturnReasonsResponse>>(getAdminPostReturnReasonsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateReturnReason,)
  }
);}



/**
 * Retrieve a return reason by its ID. You can expand the return reason's relations or select the fields that should be returned.
 * @summary Get a Return Reason
 */
export type adminGetReturnReasonsIdResponse = {
  data: AdminReturnReasonResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetReturnReasonsIdUrl = (id: string,
    params?: AdminGetReturnReasonsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/return-reasons/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/return-reasons/${id}`
}

export const adminGetReturnReasonsId = async (id: string,
    params?: AdminGetReturnReasonsIdParams, options?: RequestInit): Promise<adminGetReturnReasonsIdResponse> => {
  
  return customFetch<Promise<adminGetReturnReasonsIdResponse>>(getAdminGetReturnReasonsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a return reason's details.
 * @summary Update a Return Reason
 */
export type adminPostReturnReasonsIdResponse = {
  data: AdminReturnReasonResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnReasonsIdUrl = (id: string,
    params?: AdminPostReturnReasonsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/return-reasons/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/return-reasons/${id}`
}

export const adminPostReturnReasonsId = async (id: string,
    adminUpdateReturnReason: AdminUpdateReturnReason,
    params?: AdminPostReturnReasonsIdParams, options?: RequestInit): Promise<adminPostReturnReasonsIdResponse> => {
  
  return customFetch<Promise<adminPostReturnReasonsIdResponse>>(getAdminPostReturnReasonsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateReturnReason,)
  }
);}



/**
 * Delete a return reason.
 * @summary Delete a Return Reason
 */
export type adminDeleteReturnReasonsIdResponse = {
  data: AdminReturnReasonDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteReturnReasonsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/return-reasons/${id}`
}

export const adminDeleteReturnReasonsId = async (id: string, options?: RequestInit): Promise<adminDeleteReturnReasonsIdResponse> => {
  
  return customFetch<Promise<adminDeleteReturnReasonsIdResponse>>(getAdminDeleteReturnReasonsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of returns. The returns can be filtered by fields such as `id`. The returns can also be sorted or paginated.
 * @summary List Returns
 */
export type adminGetReturnsResponse = {
  data: AdminGetReturns200;
  status: number;
  headers: Headers;
}

export const getAdminGetReturnsUrl = (params?: AdminGetReturnsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns`
}

export const adminGetReturns = async (params?: AdminGetReturnsParams, options?: RequestInit): Promise<adminGetReturnsResponse> => {
  
  return customFetch<Promise<adminGetReturnsResponse>>(getAdminGetReturnsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a return. The return can later be requested or confirmed.
 * @summary Create Return
 */
export type adminPostReturnsResponse = {
  data: AdminOrderReturnResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsUrl = (params?: AdminPostReturnsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns`
}

export const adminPostReturns = async (adminPostReturnsReqSchema: AdminPostReturnsReqSchema,
    params?: AdminPostReturnsParams, options?: RequestInit): Promise<adminPostReturnsResponse> => {
  
  return customFetch<Promise<adminPostReturnsResponse>>(getAdminPostReturnsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsReqSchema,)
  }
);}



/**
 * Retrieve a return by its ID. You can expand the return's relations or select the fields that should be returned.
 * @summary Get a Return
 */
export type adminGetReturnsIdResponse = {
  data: AdminReturnResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetReturnsIdUrl = (id: string,
    params?: AdminGetReturnsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}`
}

export const adminGetReturnsId = async (id: string,
    params?: AdminGetReturnsIdParams, options?: RequestInit): Promise<adminGetReturnsIdResponse> => {
  
  return customFetch<Promise<adminGetReturnsIdResponse>>(getAdminGetReturnsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a return's details.
 * @summary Update a Return
 */
export type adminPostReturnsIdResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdUrl = (id: string,
    params?: AdminPostReturnsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}`
}

export const adminPostReturnsId = async (id: string,
    adminPostReturnsReturnReqSchema: AdminPostReturnsReturnReqSchema,
    params?: AdminPostReturnsIdParams, options?: RequestInit): Promise<adminPostReturnsIdResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdResponse>>(getAdminPostReturnsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsReturnReqSchema,)
  }
);}



/**
 * Cancel a return.
 * @summary Cancel a return.
 */
export type adminPostReturnsIdCancelResponse = {
  data: AdminReturnResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdCancelUrl = (id: string,) => {


  return `http://localhost:9000/admin/returns/${id}/cancel`
}

export const adminPostReturnsIdCancel = async (id: string,
    adminPostCancelReturnReqSchema: AdminPostCancelReturnReqSchema, options?: RequestInit): Promise<adminPostReturnsIdCancelResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdCancelResponse>>(getAdminPostReturnsIdCancelUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostCancelReturnReqSchema,)
  }
);}



/**
 * Add damaged items, whose quantity is to be dismissed, to a return. These items will have the action `RECEIVE_DAMAGED_RETURN_ITEM`.
 * @summary Add Damaged Items to Return
 */
export type adminPostReturnsIdDismissItemsResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdDismissItemsUrl = (id: string,
    params?: AdminPostReturnsIdDismissItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/dismiss-items?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/dismiss-items`
}

export const adminPostReturnsIdDismissItems = async (id: string,
    adminPostReturnsReceiveItemsReqSchema: AdminPostReturnsReceiveItemsReqSchema,
    params?: AdminPostReturnsIdDismissItemsParams, options?: RequestInit): Promise<adminPostReturnsIdDismissItemsResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdDismissItemsResponse>>(getAdminPostReturnsIdDismissItemsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsReceiveItemsReqSchema,)
  }
);}



/**
 * Update a damaged item, whose quantity is to be dismissed, in the return by the ID of the  item's `RECEIVE_DAMAGED_RETURN_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property. return.

 * @summary Update Damaged Item of Return
 */
export type adminPostReturnsIdDismissItemsActionIdResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdDismissItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminPostReturnsIdDismissItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/dismiss-items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/dismiss-items/${actionId}`
}

export const adminPostReturnsIdDismissItemsActionId = async (id: string,
    actionId: string,
    adminPostReturnsDismissItemsActionReqSchema: AdminPostReturnsDismissItemsActionReqSchema,
    params?: AdminPostReturnsIdDismissItemsActionIdParams, options?: RequestInit): Promise<adminPostReturnsIdDismissItemsActionIdResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdDismissItemsActionIdResponse>>(getAdminPostReturnsIdDismissItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsDismissItemsActionReqSchema,)
  }
);}



/**
 * Remove a damaged item, whose quantity is to be dismissed, in the return by the ID of the  item's `RECEIVE_DAMAGED_RETURN_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property. return.

 * @summary Remove Damaged Item from Return
 */
export type adminDeleteReturnsIdDismissItemsActionIdResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteReturnsIdDismissItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminDeleteReturnsIdDismissItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/dismiss-items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/dismiss-items/${actionId}`
}

export const adminDeleteReturnsIdDismissItemsActionId = async (id: string,
    actionId: string,
    params?: AdminDeleteReturnsIdDismissItemsActionIdParams, options?: RequestInit): Promise<adminDeleteReturnsIdDismissItemsActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteReturnsIdDismissItemsActionIdResponse>>(getAdminDeleteReturnsIdDismissItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Start a return receival process to be later confirmed using the `/admin/returns/:id/receive/confirm` API route.
 * @summary Start Return Receival
 */
export type adminPostReturnsIdReceiveResponse = {
  data: AdminOrderReturnResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdReceiveUrl = (id: string,
    params?: AdminPostReturnsIdReceiveParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/receive?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/receive`
}

export const adminPostReturnsIdReceive = async (id: string,
    adminPostReceiveReturnsReqSchema: AdminPostReceiveReturnsReqSchema,
    params?: AdminPostReturnsIdReceiveParams, options?: RequestInit): Promise<adminPostReturnsIdReceiveResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdReceiveResponse>>(getAdminPostReturnsIdReceiveUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReceiveReturnsReqSchema,)
  }
);}



/**
 * Cancel the receival process previously started, and hasn't been confirmed, of a return.
 * @summary Cancel Return Receival
 */
export type adminDeleteReturnsIdReceiveResponse = {
  data: AdminDeleteReturnsIdReceive200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteReturnsIdReceiveUrl = (id: string,) => {


  return `http://localhost:9000/admin/returns/${id}/receive`
}

export const adminDeleteReturnsIdReceive = async (id: string, options?: RequestInit): Promise<adminDeleteReturnsIdReceiveResponse> => {
  
  return customFetch<Promise<adminDeleteReturnsIdReceiveResponse>>(getAdminDeleteReturnsIdReceiveUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add received items in a return. These items will have the action `RECEIVE_RETURN_ITEM`.
 * @summary Add Received Items to Return
 */
export type adminPostReturnsIdReceiveItemsResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdReceiveItemsUrl = (id: string,
    params?: AdminPostReturnsIdReceiveItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/receive-items?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/receive-items`
}

export const adminPostReturnsIdReceiveItems = async (id: string,
    adminPostReturnsReceiveItemsReqSchema: AdminPostReturnsReceiveItemsReqSchema,
    params?: AdminPostReturnsIdReceiveItemsParams, options?: RequestInit): Promise<adminPostReturnsIdReceiveItemsResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdReceiveItemsResponse>>(getAdminPostReturnsIdReceiveItemsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsReceiveItemsReqSchema,)
  }
);}



/**
 * Update a received item in the return by the ID of the  item's `RECEIVE_RETURN_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property. return.

 * @summary Update a Received Item in a Return
 */
export type adminPostReturnsIdReceiveItemsActionIdResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdReceiveItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminPostReturnsIdReceiveItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/receive-items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/receive-items/${actionId}`
}

export const adminPostReturnsIdReceiveItemsActionId = async (id: string,
    actionId: string,
    adminPostReturnsReceiveItemsActionReqSchema: AdminPostReturnsReceiveItemsActionReqSchema,
    params?: AdminPostReturnsIdReceiveItemsActionIdParams, options?: RequestInit): Promise<adminPostReturnsIdReceiveItemsActionIdResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdReceiveItemsActionIdResponse>>(getAdminPostReturnsIdReceiveItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsReceiveItemsActionReqSchema,)
  }
);}



/**
 * Remove a received item in the return by the ID of the  item's `RECEIVE_RETURN_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property. return.

 * @summary Remove a Received Item from Return
 */
export type adminDeleteReturnsIdReceiveItemsActionIdResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteReturnsIdReceiveItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminDeleteReturnsIdReceiveItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/receive-items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/receive-items/${actionId}`
}

export const adminDeleteReturnsIdReceiveItemsActionId = async (id: string,
    actionId: string,
    params?: AdminDeleteReturnsIdReceiveItemsActionIdParams, options?: RequestInit): Promise<adminDeleteReturnsIdReceiveItemsActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteReturnsIdReceiveItemsActionIdResponse>>(getAdminDeleteReturnsIdReceiveItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Confirm that a return has been received. This updates the quantity of the items received, if not damaged, and  reflects the changes on the order.

 * @summary Confirm Return Receival
 */
export type adminPostReturnsIdReceiveConfirmResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdReceiveConfirmUrl = (id: string,
    params?: AdminPostReturnsIdReceiveConfirmParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/receive/confirm?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/receive/confirm`
}

export const adminPostReturnsIdReceiveConfirm = async (id: string,
    adminPostReturnsConfirmRequestReqSchema: AdminPostReturnsConfirmRequestReqSchema,
    params?: AdminPostReturnsIdReceiveConfirmParams, options?: RequestInit): Promise<adminPostReturnsIdReceiveConfirmResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdReceiveConfirmResponse>>(getAdminPostReturnsIdReceiveConfirmUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsConfirmRequestReqSchema,)
  }
);}



/**
 * Confirm a requested return. The changes are applied on the inventory quantity and the order only after the return has been confirmed as received using the `/admin/returns/:id/received/confirm`.

 * @summary Confirm Return Request
 */
export type adminPostReturnsIdRequestResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdRequestUrl = (id: string,
    params?: AdminPostReturnsIdRequestParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/request?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/request`
}

export const adminPostReturnsIdRequest = async (id: string,
    adminPostReturnsConfirmRequestReqSchema: AdminPostReturnsConfirmRequestReqSchema,
    params?: AdminPostReturnsIdRequestParams, options?: RequestInit): Promise<adminPostReturnsIdRequestResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdRequestResponse>>(getAdminPostReturnsIdRequestUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsConfirmRequestReqSchema,)
  }
);}



/**
 * Cancel a requested return.
 * @summary Cancel Return Request
 */
export type adminDeleteReturnsIdRequestResponse = {
  data: AdminDeleteReturnsIdRequest200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteReturnsIdRequestUrl = (id: string,) => {


  return `http://localhost:9000/admin/returns/${id}/request`
}

export const adminDeleteReturnsIdRequest = async (id: string, options?: RequestInit): Promise<adminDeleteReturnsIdRequestResponse> => {
  
  return customFetch<Promise<adminDeleteReturnsIdRequestResponse>>(getAdminDeleteReturnsIdRequestUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add items that are requested to be returned. These items will have the action `RETURN_ITEM`.
 * @summary Add Requested Items to Return
 */
export type adminPostReturnsIdRequestItemsResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdRequestItemsUrl = (id: string,
    params?: AdminPostReturnsIdRequestItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/request-items?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/request-items`
}

export const adminPostReturnsIdRequestItems = async (id: string,
    adminPostReturnsRequestItemsReqSchema: AdminPostReturnsRequestItemsReqSchema,
    params?: AdminPostReturnsIdRequestItemsParams, options?: RequestInit): Promise<adminPostReturnsIdRequestItemsResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdRequestItemsResponse>>(getAdminPostReturnsIdRequestItemsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsRequestItemsReqSchema,)
  }
);}



/**
 * Update a requested item to be returned by the ID of the  item's `RETURN_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property. return.

 * @summary Update Requested Item in Return
 */
export type adminPostReturnsIdRequestItemsActionIdResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdRequestItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminPostReturnsIdRequestItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/request-items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/request-items/${actionId}`
}

export const adminPostReturnsIdRequestItemsActionId = async (id: string,
    actionId: string,
    adminPostReturnsRequestItemsActionReqSchema: AdminPostReturnsRequestItemsActionReqSchema,
    params?: AdminPostReturnsIdRequestItemsActionIdParams, options?: RequestInit): Promise<adminPostReturnsIdRequestItemsActionIdResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdRequestItemsActionIdResponse>>(getAdminPostReturnsIdRequestItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsRequestItemsActionReqSchema,)
  }
);}



/**
 * Remove a requested item to be returned by the ID of the item's `RETURN_ITEM` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property. return.

 * @summary Remove Item from Return
 */
export type adminDeleteReturnsIdRequestItemsActionIdResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteReturnsIdRequestItemsActionIdUrl = (id: string,
    actionId: string,
    params?: AdminDeleteReturnsIdRequestItemsActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/request-items/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/request-items/${actionId}`
}

export const adminDeleteReturnsIdRequestItemsActionId = async (id: string,
    actionId: string,
    params?: AdminDeleteReturnsIdRequestItemsActionIdParams, options?: RequestInit): Promise<adminDeleteReturnsIdRequestItemsActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteReturnsIdRequestItemsActionIdResponse>>(getAdminDeleteReturnsIdRequestItemsActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add a shipping method to a return. The shipping method will have a `SHIPPING_ADD` action.
 * @summary Add a Shipping Method to a Return
 */
export type adminPostReturnsIdShippingMethodResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdShippingMethodUrl = (id: string,
    params?: AdminPostReturnsIdShippingMethodParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/shipping-method?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/shipping-method`
}

export const adminPostReturnsIdShippingMethod = async (id: string,
    adminPostReturnsShippingReqSchema: AdminPostReturnsShippingReqSchema,
    params?: AdminPostReturnsIdShippingMethodParams, options?: RequestInit): Promise<adminPostReturnsIdShippingMethodResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdShippingMethodResponse>>(getAdminPostReturnsIdShippingMethodUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsShippingReqSchema,)
  }
);}



/**
 * Update a shipping method of the return by the ID of the item's `SHIPPING_ADD` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Update a Shipping Method of a Return
 */
export type adminPostReturnsIdShippingMethodActionIdResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostReturnsIdShippingMethodActionIdUrl = (id: string,
    actionId: string,
    params?: AdminPostReturnsIdShippingMethodActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/shipping-method/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/shipping-method/${actionId}`
}

export const adminPostReturnsIdShippingMethodActionId = async (id: string,
    actionId: string,
    adminPostReturnsShippingActionReqSchema: AdminPostReturnsShippingActionReqSchema,
    params?: AdminPostReturnsIdShippingMethodActionIdParams, options?: RequestInit): Promise<adminPostReturnsIdShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminPostReturnsIdShippingMethodActionIdResponse>>(getAdminPostReturnsIdShippingMethodActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostReturnsShippingActionReqSchema,)
  }
);}



/**
 * Remove a shipping method of the return by the ID of the item's `SHIPPING_ADD` action.

Every item has an `actions` property, whose value is an array of actions. You can check the action's name using its `action` property, and use the value of the `id` property.

 * @summary Remove Shipping Method from Return
 */
export type adminDeleteReturnsIdShippingMethodActionIdResponse = {
  data: AdminReturnPreviewResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteReturnsIdShippingMethodActionIdUrl = (id: string,
    actionId: string,
    params?: AdminDeleteReturnsIdShippingMethodActionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/returns/${id}/shipping-method/${actionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/returns/${id}/shipping-method/${actionId}`
}

export const adminDeleteReturnsIdShippingMethodActionId = async (id: string,
    actionId: string,
    params?: AdminDeleteReturnsIdShippingMethodActionIdParams, options?: RequestInit): Promise<adminDeleteReturnsIdShippingMethodActionIdResponse> => {
  
  return customFetch<Promise<adminDeleteReturnsIdShippingMethodActionIdResponse>>(getAdminDeleteReturnsIdShippingMethodActionIdUrl(id,actionId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of sales channels. The sales channels can be filtered by fields such as `id`. The sales channels can also be sorted or paginated.
 * @summary List Sales Channels
 */
export type adminGetSalesChannelsResponse = {
  data: AdminGetSalesChannels200;
  status: number;
  headers: Headers;
}

export const getAdminGetSalesChannelsUrl = (params?: AdminGetSalesChannelsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/sales-channels?${normalizedParams.toString()}` : `http://localhost:9000/admin/sales-channels`
}

export const adminGetSalesChannels = async (params?: AdminGetSalesChannelsParams, options?: RequestInit): Promise<adminGetSalesChannelsResponse> => {
  
  return customFetch<Promise<adminGetSalesChannelsResponse>>(getAdminGetSalesChannelsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a sales channel.
 * @summary Create Sales Channel
 */
export type adminPostSalesChannelsResponse = {
  data: AdminSalesChannelResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostSalesChannelsUrl = (params?: AdminPostSalesChannelsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/sales-channels?${normalizedParams.toString()}` : `http://localhost:9000/admin/sales-channels`
}

export const adminPostSalesChannels = async (adminCreateSalesChannel: AdminCreateSalesChannel,
    params?: AdminPostSalesChannelsParams, options?: RequestInit): Promise<adminPostSalesChannelsResponse> => {
  
  return customFetch<Promise<adminPostSalesChannelsResponse>>(getAdminPostSalesChannelsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateSalesChannel,)
  }
);}



/**
 * Retrieve a sales channel by its ID. You can expand the sales channel's relations or select the fields that should be returned.
 * @summary Get a Sales Channel
 */
export type adminGetSalesChannelsIdResponse = {
  data: AdminSalesChannelResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetSalesChannelsIdUrl = (id: string,
    params?: AdminGetSalesChannelsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/sales-channels/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/sales-channels/${id}`
}

export const adminGetSalesChannelsId = async (id: string,
    params?: AdminGetSalesChannelsIdParams, options?: RequestInit): Promise<adminGetSalesChannelsIdResponse> => {
  
  return customFetch<Promise<adminGetSalesChannelsIdResponse>>(getAdminGetSalesChannelsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a sales channel's details.
 * @summary Update a Sales Channel
 */
export type adminPostSalesChannelsIdResponse = {
  data: AdminSalesChannelResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostSalesChannelsIdUrl = (id: string,
    params?: AdminPostSalesChannelsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/sales-channels/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/sales-channels/${id}`
}

export const adminPostSalesChannelsId = async (id: string,
    adminUpdateSalesChannel: AdminUpdateSalesChannel,
    params?: AdminPostSalesChannelsIdParams, options?: RequestInit): Promise<adminPostSalesChannelsIdResponse> => {
  
  return customFetch<Promise<adminPostSalesChannelsIdResponse>>(getAdminPostSalesChannelsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateSalesChannel,)
  }
);}



/**
 * Delete a sales channel.
 * @summary Delete a Sales Channel
 */
export type adminDeleteSalesChannelsIdResponse = {
  data: AdminSalesChannelDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteSalesChannelsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/sales-channels/${id}`
}

export const adminDeleteSalesChannelsId = async (id: string, options?: RequestInit): Promise<adminDeleteSalesChannelsIdResponse> => {
  
  return customFetch<Promise<adminDeleteSalesChannelsIdResponse>>(getAdminDeleteSalesChannelsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Manage products in a sales channel to add or remove them from the channel.
 * @summary Manage Products in Sales Channel
 */
export type adminPostSalesChannelsIdProductsResponse = {
  data: AdminSalesChannelResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostSalesChannelsIdProductsUrl = (id: string,
    params?: AdminPostSalesChannelsIdProductsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/sales-channels/${id}/products?${normalizedParams.toString()}` : `http://localhost:9000/admin/sales-channels/${id}/products`
}

export const adminPostSalesChannelsIdProducts = async (id: string,
    adminPostSalesChannelsIdProductsBody: AdminPostSalesChannelsIdProductsBody,
    params?: AdminPostSalesChannelsIdProductsParams, options?: RequestInit): Promise<adminPostSalesChannelsIdProductsResponse> => {
  
  return customFetch<Promise<adminPostSalesChannelsIdProductsResponse>>(getAdminPostSalesChannelsIdProductsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostSalesChannelsIdProductsBody,)
  }
);}



/**
 * Retrieve a list of shipping options. The shipping options can be filtered by fields such as `id`. The shipping options can also be sorted or paginated.
 * @summary List Shipping Options
 */
export type adminGetShippingOptionsResponse = {
  data: AdminGetShippingOptions200;
  status: number;
  headers: Headers;
}

export const getAdminGetShippingOptionsUrl = (params?: AdminGetShippingOptionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/shipping-options?${normalizedParams.toString()}` : `http://localhost:9000/admin/shipping-options`
}

export const adminGetShippingOptions = async (params?: AdminGetShippingOptionsParams, options?: RequestInit): Promise<adminGetShippingOptionsResponse> => {
  
  return customFetch<Promise<adminGetShippingOptionsResponse>>(getAdminGetShippingOptionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a shipping option.
 * @summary Create Shipping Option
 */
export type adminPostShippingOptionsResponse = {
  data: AdminShippingOptionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostShippingOptionsUrl = (params?: AdminPostShippingOptionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/shipping-options?${normalizedParams.toString()}` : `http://localhost:9000/admin/shipping-options`
}

export const adminPostShippingOptions = async (adminCreateShippingOption: AdminCreateShippingOption,
    params?: AdminPostShippingOptionsParams, options?: RequestInit): Promise<adminPostShippingOptionsResponse> => {
  
  return customFetch<Promise<adminPostShippingOptionsResponse>>(getAdminPostShippingOptionsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateShippingOption,)
  }
);}



/**
 * Retrieve a shipping option by its ID. You can expand the shipping option's relations or select the fields that should be returned.
 * @summary Get a Shipping Option
 */
export type adminGetShippingOptionsIdResponse = {
  data: AdminShippingOptionResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetShippingOptionsIdUrl = (id: string,
    params?: AdminGetShippingOptionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/shipping-options/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/shipping-options/${id}`
}

export const adminGetShippingOptionsId = async (id: string,
    params?: AdminGetShippingOptionsIdParams, options?: RequestInit): Promise<adminGetShippingOptionsIdResponse> => {
  
  return customFetch<Promise<adminGetShippingOptionsIdResponse>>(getAdminGetShippingOptionsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a shipping option's details.
 * @summary Update a Shipping Option
 */
export type adminPostShippingOptionsIdResponse = {
  data: AdminShippingOptionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostShippingOptionsIdUrl = (id: string,
    params?: AdminPostShippingOptionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/shipping-options/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/shipping-options/${id}`
}

export const adminPostShippingOptionsId = async (id: string,
    adminPostShippingOptionsIdBody: AdminPostShippingOptionsIdBody,
    params?: AdminPostShippingOptionsIdParams, options?: RequestInit): Promise<adminPostShippingOptionsIdResponse> => {
  
  return customFetch<Promise<adminPostShippingOptionsIdResponse>>(getAdminPostShippingOptionsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostShippingOptionsIdBody,)
  }
);}



/**
 * Delete a shipping option.
 * @summary Delete a Shipping Option
 */
export type adminDeleteShippingOptionsIdResponse = {
  data: AdminShippingOptionDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteShippingOptionsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/shipping-options/${id}`
}

export const adminDeleteShippingOptionsId = async (id: string, options?: RequestInit): Promise<adminDeleteShippingOptionsIdResponse> => {
  
  return customFetch<Promise<adminDeleteShippingOptionsIdResponse>>(getAdminDeleteShippingOptionsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Manage the rules of a shipping option to create, update, or delete them.
 * @summary Manage the Rules of a Shipping Option
 */
export type adminPostShippingOptionsIdRulesBatchResponse = {
  data: AdminPostShippingOptionsIdRulesBatch200;
  status: number;
  headers: Headers;
}

export const getAdminPostShippingOptionsIdRulesBatchUrl = (id: string,
    params?: AdminPostShippingOptionsIdRulesBatchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/shipping-options/${id}/rules/batch?${normalizedParams.toString()}` : `http://localhost:9000/admin/shipping-options/${id}/rules/batch`
}

export const adminPostShippingOptionsIdRulesBatch = async (id: string,
    adminPostShippingOptionsIdRulesBatchBody: AdminPostShippingOptionsIdRulesBatchBody,
    params?: AdminPostShippingOptionsIdRulesBatchParams, options?: RequestInit): Promise<adminPostShippingOptionsIdRulesBatchResponse> => {
  
  return customFetch<Promise<adminPostShippingOptionsIdRulesBatchResponse>>(getAdminPostShippingOptionsIdRulesBatchUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostShippingOptionsIdRulesBatchBody,)
  }
);}



/**
 * Retrieve a list of shipping profiles. The shipping profiles can be filtered by fields such as `id`. The shipping profiles can also be sorted or paginated.
 * @summary List Shipping Profiles
 */
export type adminGetShippingProfilesResponse = {
  data: AdminGetShippingProfiles200;
  status: number;
  headers: Headers;
}

export const getAdminGetShippingProfilesUrl = (params?: AdminGetShippingProfilesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/shipping-profiles?${normalizedParams.toString()}` : `http://localhost:9000/admin/shipping-profiles`
}

export const adminGetShippingProfiles = async (params?: AdminGetShippingProfilesParams, options?: RequestInit): Promise<adminGetShippingProfilesResponse> => {
  
  return customFetch<Promise<adminGetShippingProfilesResponse>>(getAdminGetShippingProfilesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a shipping profile.
 * @summary Create Shipping Profile
 */
export type adminPostShippingProfilesResponse = {
  data: AdminShippingProfileResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostShippingProfilesUrl = (params?: AdminPostShippingProfilesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/shipping-profiles?${normalizedParams.toString()}` : `http://localhost:9000/admin/shipping-profiles`
}

export const adminPostShippingProfiles = async (adminCreateShippingProfile: AdminCreateShippingProfile,
    params?: AdminPostShippingProfilesParams, options?: RequestInit): Promise<adminPostShippingProfilesResponse> => {
  
  return customFetch<Promise<adminPostShippingProfilesResponse>>(getAdminPostShippingProfilesUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateShippingProfile,)
  }
);}



/**
 * Retrieve a shipping profile by its ID. You can expand the shipping profile's relations or select the fields that should be returned.
 * @summary Get a Shipping Profile
 */
export type adminGetShippingProfilesIdResponse = {
  data: AdminShippingProfileResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetShippingProfilesIdUrl = (id: string,
    params?: AdminGetShippingProfilesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/shipping-profiles/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/shipping-profiles/${id}`
}

export const adminGetShippingProfilesId = async (id: string,
    params?: AdminGetShippingProfilesIdParams, options?: RequestInit): Promise<adminGetShippingProfilesIdResponse> => {
  
  return customFetch<Promise<adminGetShippingProfilesIdResponse>>(getAdminGetShippingProfilesIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a shipping profile's details.
 * @summary Update a Shipping Profile
 */
export type adminPostShippingProfilesIdResponse = {
  data: AdminShippingProfileResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostShippingProfilesIdUrl = (id: string,
    params?: AdminPostShippingProfilesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/shipping-profiles/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/shipping-profiles/${id}`
}

export const adminPostShippingProfilesId = async (id: string,
    adminPostShippingProfilesIdBody: AdminPostShippingProfilesIdBody,
    params?: AdminPostShippingProfilesIdParams, options?: RequestInit): Promise<adminPostShippingProfilesIdResponse> => {
  
  return customFetch<Promise<adminPostShippingProfilesIdResponse>>(getAdminPostShippingProfilesIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostShippingProfilesIdBody,)
  }
);}



/**
 * Delete a shipping profile.
 * @summary Delete a Shipping Profile
 */
export type adminDeleteShippingProfilesIdResponse = {
  data: AdminShippingProfileDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteShippingProfilesIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/shipping-profiles/${id}`
}

export const adminDeleteShippingProfilesId = async (id: string, options?: RequestInit): Promise<adminDeleteShippingProfilesIdResponse> => {
  
  return customFetch<Promise<adminDeleteShippingProfilesIdResponse>>(getAdminDeleteShippingProfilesIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of stock locations. The stock locations can be filtered by fields such as `id`. The stock locations can also be sorted or paginated.
 * @summary List Stock Locations
 */
export type adminGetStockLocationsResponse = {
  data: AdminStockLocationListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetStockLocationsUrl = (params?: AdminGetStockLocationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/stock-locations?${normalizedParams.toString()}` : `http://localhost:9000/admin/stock-locations`
}

export const adminGetStockLocations = async (params?: AdminGetStockLocationsParams, options?: RequestInit): Promise<adminGetStockLocationsResponse> => {
  
  return customFetch<Promise<adminGetStockLocationsResponse>>(getAdminGetStockLocationsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a stock location.
 * @summary Create Stock Location
 */
export type adminPostStockLocationsResponse = {
  data: AdminStockLocationResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostStockLocationsUrl = (params?: AdminPostStockLocationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/stock-locations?${normalizedParams.toString()}` : `http://localhost:9000/admin/stock-locations`
}

export const adminPostStockLocations = async (adminCreateStockLocation: AdminCreateStockLocation,
    params?: AdminPostStockLocationsParams, options?: RequestInit): Promise<adminPostStockLocationsResponse> => {
  
  return customFetch<Promise<adminPostStockLocationsResponse>>(getAdminPostStockLocationsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateStockLocation,)
  }
);}



/**
 * Retrieve a stock location by its ID. You can expand the stock location's relations or select the fields that should be returned.
 * @summary Get a Stock Location
 */
export type adminGetStockLocationsIdResponse = {
  data: AdminStockLocationResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetStockLocationsIdUrl = (id: string,
    params?: AdminGetStockLocationsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/stock-locations/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/stock-locations/${id}`
}

export const adminGetStockLocationsId = async (id: string,
    params?: AdminGetStockLocationsIdParams, options?: RequestInit): Promise<adminGetStockLocationsIdResponse> => {
  
  return customFetch<Promise<adminGetStockLocationsIdResponse>>(getAdminGetStockLocationsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a stock location's details.
 * @summary Update a Stock Location
 */
export type adminPostStockLocationsIdResponse = {
  data: AdminStockLocationResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostStockLocationsIdUrl = (id: string,
    params?: AdminPostStockLocationsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/stock-locations/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/stock-locations/${id}`
}

export const adminPostStockLocationsId = async (id: string,
    adminUpdateStockLocation: AdminUpdateStockLocation,
    params?: AdminPostStockLocationsIdParams, options?: RequestInit): Promise<adminPostStockLocationsIdResponse> => {
  
  return customFetch<Promise<adminPostStockLocationsIdResponse>>(getAdminPostStockLocationsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateStockLocation,)
  }
);}



/**
 * Delete a stock location.
 * @summary Delete a Stock Location
 */
export type adminDeleteStockLocationsIdResponse = {
  data: AdminStockLocationDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteStockLocationsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/stock-locations/${id}`
}

export const adminDeleteStockLocationsId = async (id: string, options?: RequestInit): Promise<adminDeleteStockLocationsIdResponse> => {
  
  return customFetch<Promise<adminDeleteStockLocationsIdResponse>>(getAdminDeleteStockLocationsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Manage the fulfillment providers to add or remove them from a stock location.
 * @summary Manage Fulfillment Providers of a Stock Location
 */
export type adminPostStockLocationsIdFulfillmentProvidersResponse = {
  data: AdminStockLocationResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostStockLocationsIdFulfillmentProvidersUrl = (id: string,
    params?: AdminPostStockLocationsIdFulfillmentProvidersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/stock-locations/${id}/fulfillment-providers?${normalizedParams.toString()}` : `http://localhost:9000/admin/stock-locations/${id}/fulfillment-providers`
}

export const adminPostStockLocationsIdFulfillmentProviders = async (id: string,
    adminPostStockLocationsIdFulfillmentProvidersBody: AdminPostStockLocationsIdFulfillmentProvidersBody,
    params?: AdminPostStockLocationsIdFulfillmentProvidersParams, options?: RequestInit): Promise<adminPostStockLocationsIdFulfillmentProvidersResponse> => {
  
  return customFetch<Promise<adminPostStockLocationsIdFulfillmentProvidersResponse>>(getAdminPostStockLocationsIdFulfillmentProvidersUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostStockLocationsIdFulfillmentProvidersBody,)
  }
);}



/**
 * Create and add a fulfillment set to a stock location.
 * @summary Add Fulfillment Set to Stock Location
 */
export type adminPostStockLocationsIdFulfillmentSetsResponse = {
  data: AdminStockLocationResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostStockLocationsIdFulfillmentSetsUrl = (id: string,
    params?: AdminPostStockLocationsIdFulfillmentSetsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/stock-locations/${id}/fulfillment-sets?${normalizedParams.toString()}` : `http://localhost:9000/admin/stock-locations/${id}/fulfillment-sets`
}

export const adminPostStockLocationsIdFulfillmentSets = async (id: string,
    adminPostStockLocationsIdFulfillmentSetsBody: AdminPostStockLocationsIdFulfillmentSetsBody,
    params?: AdminPostStockLocationsIdFulfillmentSetsParams, options?: RequestInit): Promise<adminPostStockLocationsIdFulfillmentSetsResponse> => {
  
  return customFetch<Promise<adminPostStockLocationsIdFulfillmentSetsResponse>>(getAdminPostStockLocationsIdFulfillmentSetsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostStockLocationsIdFulfillmentSetsBody,)
  }
);}



/**
 * Manage the sales channels in a stock location by adding or removing them.
 * @summary Manage Sales Channels of a Stock Location
 */
export type adminPostStockLocationsIdSalesChannelsResponse = {
  data: AdminStockLocationResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostStockLocationsIdSalesChannelsUrl = (id: string,
    params?: AdminPostStockLocationsIdSalesChannelsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/stock-locations/${id}/sales-channels?${normalizedParams.toString()}` : `http://localhost:9000/admin/stock-locations/${id}/sales-channels`
}

export const adminPostStockLocationsIdSalesChannels = async (id: string,
    adminPostStockLocationsIdSalesChannelsBody: AdminPostStockLocationsIdSalesChannelsBody,
    params?: AdminPostStockLocationsIdSalesChannelsParams, options?: RequestInit): Promise<adminPostStockLocationsIdSalesChannelsResponse> => {
  
  return customFetch<Promise<adminPostStockLocationsIdSalesChannelsResponse>>(getAdminPostStockLocationsIdSalesChannelsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostStockLocationsIdSalesChannelsBody,)
  }
);}



/**
 * Retrieve a list of stores. The stores can be filtered by fields such as `id`. The stores can also be sorted or paginated.
 * @summary List Stores
 */
export type adminGetStoresResponse = {
  data: AdminStoreListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetStoresUrl = (params?: AdminGetStoresParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/stores?${normalizedParams.toString()}` : `http://localhost:9000/admin/stores`
}

export const adminGetStores = async (params?: AdminGetStoresParams, options?: RequestInit): Promise<adminGetStoresResponse> => {
  
  return customFetch<Promise<adminGetStoresResponse>>(getAdminGetStoresUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a store by its ID. You can expand the store's relations or select the fields that should be returned.
 * @summary Get a Store
 */
export type adminGetStoresIdResponse = {
  data: AdminStoreResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetStoresIdUrl = (id: string,
    params?: AdminGetStoresIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/stores/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/stores/${id}`
}

export const adminGetStoresId = async (id: string,
    params?: AdminGetStoresIdParams, options?: RequestInit): Promise<adminGetStoresIdResponse> => {
  
  return customFetch<Promise<adminGetStoresIdResponse>>(getAdminGetStoresIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a store's details.
 * @summary Update a Store
 */
export type adminPostStoresIdResponse = {
  data: AdminStoreResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostStoresIdUrl = (id: string,
    params?: AdminPostStoresIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/stores/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/stores/${id}`
}

export const adminPostStoresId = async (id: string,
    adminUpdateStore: AdminUpdateStore,
    params?: AdminPostStoresIdParams, options?: RequestInit): Promise<adminPostStoresIdResponse> => {
  
  return customFetch<Promise<adminPostStoresIdResponse>>(getAdminPostStoresIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateStore,)
  }
);}



/**
 * Retrieve a list of tax rates. The tax rates can be filtered by fields such as `id`. The tax rates can also be sorted or paginated.
 * @summary List Tax Rates
 */
export type adminGetTaxRatesResponse = {
  data: AdminGetTaxRates200;
  status: number;
  headers: Headers;
}

export const getAdminGetTaxRatesUrl = (params?: AdminGetTaxRatesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/tax-rates?${normalizedParams.toString()}` : `http://localhost:9000/admin/tax-rates`
}

export const adminGetTaxRates = async (params?: AdminGetTaxRatesParams, options?: RequestInit): Promise<adminGetTaxRatesResponse> => {
  
  return customFetch<Promise<adminGetTaxRatesResponse>>(getAdminGetTaxRatesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a tax rate.
 * @summary Create Tax Rate
 */
export type adminPostTaxRatesResponse = {
  data: AdminTaxRateResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostTaxRatesUrl = (params?: AdminPostTaxRatesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/tax-rates?${normalizedParams.toString()}` : `http://localhost:9000/admin/tax-rates`
}

export const adminPostTaxRates = async (adminCreateTaxRate: AdminCreateTaxRate,
    params?: AdminPostTaxRatesParams, options?: RequestInit): Promise<adminPostTaxRatesResponse> => {
  
  return customFetch<Promise<adminPostTaxRatesResponse>>(getAdminPostTaxRatesUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateTaxRate,)
  }
);}



/**
 * Retrieve a tax rate by its ID. You can expand the tax rate's relations or select the fields that should be returned.
 * @summary Get a Tax Rate
 */
export type adminGetTaxRatesIdResponse = {
  data: AdminTaxRateResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetTaxRatesIdUrl = (id: string,
    params?: AdminGetTaxRatesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/tax-rates/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/tax-rates/${id}`
}

export const adminGetTaxRatesId = async (id: string,
    params?: AdminGetTaxRatesIdParams, options?: RequestInit): Promise<adminGetTaxRatesIdResponse> => {
  
  return customFetch<Promise<adminGetTaxRatesIdResponse>>(getAdminGetTaxRatesIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a tax rate's details.
 * @summary Update a Tax Rate
 */
export type adminPostTaxRatesIdResponse = {
  data: AdminTaxRateResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostTaxRatesIdUrl = (id: string,
    params?: AdminPostTaxRatesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/tax-rates/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/tax-rates/${id}`
}

export const adminPostTaxRatesId = async (id: string,
    adminUpdateTaxRate: AdminUpdateTaxRate,
    params?: AdminPostTaxRatesIdParams, options?: RequestInit): Promise<adminPostTaxRatesIdResponse> => {
  
  return customFetch<Promise<adminPostTaxRatesIdResponse>>(getAdminPostTaxRatesIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateTaxRate,)
  }
);}



/**
 * Delete a tax rate.
 * @summary Delete a Tax Rate
 */
export type adminDeleteTaxRatesIdResponse = {
  data: AdminTaxRateDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteTaxRatesIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/tax-rates/${id}`
}

export const adminDeleteTaxRatesId = async (id: string, options?: RequestInit): Promise<adminDeleteTaxRatesIdResponse> => {
  
  return customFetch<Promise<adminDeleteTaxRatesIdResponse>>(getAdminDeleteTaxRatesIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Create a tax rule for a rate.
 * @summary Create Tax Rule for a Rate
 */
export type adminPostTaxRatesIdRulesResponse = {
  data: AdminTaxRateResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostTaxRatesIdRulesUrl = (id: string,
    params?: AdminPostTaxRatesIdRulesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/tax-rates/${id}/rules?${normalizedParams.toString()}` : `http://localhost:9000/admin/tax-rates/${id}/rules`
}

export const adminPostTaxRatesIdRules = async (id: string,
    adminCreateTaxRateRule: AdminCreateTaxRateRule,
    params?: AdminPostTaxRatesIdRulesParams, options?: RequestInit): Promise<adminPostTaxRatesIdRulesResponse> => {
  
  return customFetch<Promise<adminPostTaxRatesIdRulesResponse>>(getAdminPostTaxRatesIdRulesUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateTaxRateRule,)
  }
);}



/**
 * Remove a tax rate's rule.
 * @summary Remove Rule of Tax Rate
 */
export type adminDeleteTaxRatesIdRulesRuleIdResponse = {
  data: AdminDeleteTaxRatesIdRulesRuleId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteTaxRatesIdRulesRuleIdUrl = (id: string,
    ruleId: string,
    params?: AdminDeleteTaxRatesIdRulesRuleIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/tax-rates/${id}/rules/${ruleId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/tax-rates/${id}/rules/${ruleId}`
}

export const adminDeleteTaxRatesIdRulesRuleId = async (id: string,
    ruleId: string,
    params?: AdminDeleteTaxRatesIdRulesRuleIdParams, options?: RequestInit): Promise<adminDeleteTaxRatesIdRulesRuleIdResponse> => {
  
  return customFetch<Promise<adminDeleteTaxRatesIdRulesRuleIdResponse>>(getAdminDeleteTaxRatesIdRulesRuleIdUrl(id,ruleId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of tax regions. The tax regions can be filtered by fields such as `id`. The tax regions can also be sorted or paginated.
 * @summary List Tax Regions
 */
export type adminGetTaxRegionsResponse = {
  data: AdminGetTaxRegions200;
  status: number;
  headers: Headers;
}

export const getAdminGetTaxRegionsUrl = (params?: AdminGetTaxRegionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/tax-regions?${normalizedParams.toString()}` : `http://localhost:9000/admin/tax-regions`
}

export const adminGetTaxRegions = async (params?: AdminGetTaxRegionsParams, options?: RequestInit): Promise<adminGetTaxRegionsResponse> => {
  
  return customFetch<Promise<adminGetTaxRegionsResponse>>(getAdminGetTaxRegionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a tax region.
 * @summary Create Tax Region
 */
export type adminPostTaxRegionsResponse = {
  data: AdminTaxRegionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostTaxRegionsUrl = (params?: AdminPostTaxRegionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/tax-regions?${normalizedParams.toString()}` : `http://localhost:9000/admin/tax-regions`
}

export const adminPostTaxRegions = async (adminCreateTaxRegion: AdminCreateTaxRegion,
    params?: AdminPostTaxRegionsParams, options?: RequestInit): Promise<adminPostTaxRegionsResponse> => {
  
  return customFetch<Promise<adminPostTaxRegionsResponse>>(getAdminPostTaxRegionsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateTaxRegion,)
  }
);}



/**
 * Retrieve a tax region by its ID. You can expand the tax region's relations or select the fields that should be returned.
 * @summary Get a Tax Region
 */
export type adminGetTaxRegionsIdResponse = {
  data: AdminTaxRegionResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetTaxRegionsIdUrl = (id: string,
    params?: AdminGetTaxRegionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/tax-regions/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/tax-regions/${id}`
}

export const adminGetTaxRegionsId = async (id: string,
    params?: AdminGetTaxRegionsIdParams, options?: RequestInit): Promise<adminGetTaxRegionsIdResponse> => {
  
  return customFetch<Promise<adminGetTaxRegionsIdResponse>>(getAdminGetTaxRegionsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a tax region's details.
 * @summary Update a Tax Region
 */
export type adminPostTaxRegionsIdResponse = {
  data: AdminTaxRegionResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostTaxRegionsIdUrl = (id: string,
    params?: AdminPostTaxRegionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/tax-regions/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/tax-regions/${id}`
}

export const adminPostTaxRegionsId = async (id: string,
    adminUpdateTaxRegion: AdminUpdateTaxRegion,
    params?: AdminPostTaxRegionsIdParams, options?: RequestInit): Promise<adminPostTaxRegionsIdResponse> => {
  
  return customFetch<Promise<adminPostTaxRegionsIdResponse>>(getAdminPostTaxRegionsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateTaxRegion,)
  }
);}



/**
 * Delete a tax region.
 * @summary Delete a Tax Region
 */
export type adminDeleteTaxRegionsIdResponse = {
  data: AdminTaxRegionDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteTaxRegionsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/tax-regions/${id}`
}

export const adminDeleteTaxRegionsId = async (id: string, options?: RequestInit): Promise<adminDeleteTaxRegionsIdResponse> => {
  
  return customFetch<Promise<adminDeleteTaxRegionsIdResponse>>(getAdminDeleteTaxRegionsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Upload files to the configured File Module Provider.
 * @summary Upload Files
 */
export type adminPostUploadsResponse = {
  data: AdminFileListResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostUploadsUrl = () => {


  return `http://localhost:9000/admin/uploads`
}

export const adminPostUploads = async (adminPostUploadsBody: AdminPostUploadsBody, options?: RequestInit): Promise<adminPostUploadsResponse> => {
  
  return customFetch<Promise<adminPostUploadsResponse>>(getAdminPostUploadsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostUploadsBody,)
  }
);}



/**
 * Retrieve an uploaded file by its ID. You can expand the file's relations or select the fields that should be returned.
 * @summary Get a File
 */
export type adminGetUploadsIdResponse = {
  data: AdminFileResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetUploadsIdUrl = (id: string,
    params?: AdminGetUploadsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/uploads/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/uploads/${id}`
}

export const adminGetUploadsId = async (id: string,
    params?: AdminGetUploadsIdParams, options?: RequestInit): Promise<adminGetUploadsIdResponse> => {
  
  return customFetch<Promise<adminGetUploadsIdResponse>>(getAdminGetUploadsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Delete a file. Uses the installed file module provider to delete the file.
 * @summary Delete a File
 */
export type adminDeleteUploadsIdResponse = {
  data: AdminDeleteUploadsId200;
  status: number;
  headers: Headers;
}

export const getAdminDeleteUploadsIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/uploads/${id}`
}

export const adminDeleteUploadsId = async (id: string, options?: RequestInit): Promise<adminDeleteUploadsIdResponse> => {
  
  return customFetch<Promise<adminDeleteUploadsIdResponse>>(getAdminDeleteUploadsIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of users. The users can be filtered by fields such as `id`. The users can also be sorted or paginated.
 * @summary List Users
 */
export type adminGetUsersResponse = {
  data: AdminUserListResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetUsersUrl = (params?: AdminGetUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/users?${normalizedParams.toString()}` : `http://localhost:9000/admin/users`
}

export const adminGetUsers = async (params?: AdminGetUsersParams, options?: RequestInit): Promise<adminGetUsersResponse> => {
  
  return customFetch<Promise<adminGetUsersResponse>>(getAdminGetUsersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve the logged-in user's details.
 * @summary Get Logged-In User
 */
export type adminGetUsersMeResponse = {
  data: AdminUserResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetUsersMeUrl = (params?: AdminGetUsersMeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/users/me?${normalizedParams.toString()}` : `http://localhost:9000/admin/users/me`
}

export const adminGetUsersMe = async (params?: AdminGetUsersMeParams, options?: RequestInit): Promise<adminGetUsersMeResponse> => {
  
  return customFetch<Promise<adminGetUsersMeResponse>>(getAdminGetUsersMeUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a user by its ID. You can expand the user's relations or select the fields that should be returned.
 * @summary Get a User
 */
export type adminGetUsersIdResponse = {
  data: AdminUserResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetUsersIdUrl = (id: string,
    params?: AdminGetUsersIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/users/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/users/${id}`
}

export const adminGetUsersId = async (id: string,
    params?: AdminGetUsersIdParams, options?: RequestInit): Promise<adminGetUsersIdResponse> => {
  
  return customFetch<Promise<adminGetUsersIdResponse>>(getAdminGetUsersIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a user's details.
 * @summary Update a User
 */
export type adminPostUsersIdResponse = {
  data: AdminUserResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostUsersIdUrl = (id: string,
    params?: AdminPostUsersIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/users/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/users/${id}`
}

export const adminPostUsersId = async (id: string,
    adminUpdateUser: AdminUpdateUser,
    params?: AdminPostUsersIdParams, options?: RequestInit): Promise<adminPostUsersIdResponse> => {
  
  return customFetch<Promise<adminPostUsersIdResponse>>(getAdminPostUsersIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateUser,)
  }
);}



/**
 * Delete a user.
 * @summary Delete a User
 */
export type adminDeleteUsersIdResponse = {
  data: AdminUserDeleteResponse;
  status: number;
  headers: Headers;
}

export const getAdminDeleteUsersIdUrl = (id: string,) => {


  return `http://localhost:9000/admin/users/${id}`
}

export const adminDeleteUsersId = async (id: string, options?: RequestInit): Promise<adminDeleteUsersIdResponse> => {
  
  return customFetch<Promise<adminDeleteUsersIdResponse>>(getAdminDeleteUsersIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve a list of workflows executions. The workflows executions can be filtered by fields such as `id`. The workflows executions can also be sorted or paginated.
 * @summary List Workflows Executions
 */
export type adminGetWorkflowsExecutionsResponse = {
  data: AdminGetWorkflowsExecutions200;
  status: number;
  headers: Headers;
}

export const getAdminGetWorkflowsExecutionsUrl = (params?: AdminGetWorkflowsExecutionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/workflows-executions?${normalizedParams.toString()}` : `http://localhost:9000/admin/workflows-executions`
}

export const adminGetWorkflowsExecutions = async (params?: AdminGetWorkflowsExecutionsParams, options?: RequestInit): Promise<adminGetWorkflowsExecutionsResponse> => {
  
  return customFetch<Promise<adminGetWorkflowsExecutionsResponse>>(getAdminGetWorkflowsExecutionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a workflows execution by its ID. You can expand the workflows execution's relations or select the fields that should be returned.
 * @summary Get a Workflows Execution
 */
export type adminGetWorkflowsExecutionsIdResponse = {
  data: AdminWorkflowExecutionResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetWorkflowsExecutionsIdUrl = (id: string,
    params?: AdminGetWorkflowsExecutionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/workflows-executions/${id}?${normalizedParams.toString()}` : `http://localhost:9000/admin/workflows-executions/${id}`
}

export const adminGetWorkflowsExecutionsId = async (id: string,
    params?: AdminGetWorkflowsExecutionsIdParams, options?: RequestInit): Promise<adminGetWorkflowsExecutionsIdResponse> => {
  
  return customFetch<Promise<adminGetWorkflowsExecutionsIdResponse>>(getAdminGetWorkflowsExecutionsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Execute a workflow by its ID.
 * @summary Execute a Workflow
 */
export type adminPostWorkflowsExecutionsWorkflowIdRunResponse = {
  data: AdminPostWorkflowsExecutionsWorkflowIdRun200;
  status: number;
  headers: Headers;
}

export const getAdminPostWorkflowsExecutionsWorkflowIdRunUrl = (workflowId: string,) => {


  return `http://localhost:9000/admin/workflows-executions/${workflowId}/run`
}

export const adminPostWorkflowsExecutionsWorkflowIdRun = async (workflowId: string,
    adminCreateWorkflowsRun: AdminCreateWorkflowsRun, options?: RequestInit): Promise<adminPostWorkflowsExecutionsWorkflowIdRunResponse> => {
  
  return customFetch<Promise<adminPostWorkflowsExecutionsWorkflowIdRunResponse>>(getAdminPostWorkflowsExecutionsWorkflowIdRunUrl(workflowId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateWorkflowsRun,)
  }
);}



/**
 * Set the status of a step in a workflow's execution as failed. This is useful for long-running workflows.
 * @summary Fail a Step in a Workflow's Execution
 */
export type adminPostWorkflowsExecutionsWorkflowIdStepsFailureResponse = {
  data: AdminPostWorkflowsExecutionsWorkflowIdStepsFailure200;
  status: number;
  headers: Headers;
}

export const getAdminPostWorkflowsExecutionsWorkflowIdStepsFailureUrl = (workflowId: string,) => {


  return `http://localhost:9000/admin/workflows-executions/${workflowId}/steps/failure`
}

export const adminPostWorkflowsExecutionsWorkflowIdStepsFailure = async (workflowId: string,
    adminCreateWorkflowsAsyncResponse: AdminCreateWorkflowsAsyncResponse, options?: RequestInit): Promise<adminPostWorkflowsExecutionsWorkflowIdStepsFailureResponse> => {
  
  return customFetch<Promise<adminPostWorkflowsExecutionsWorkflowIdStepsFailureResponse>>(getAdminPostWorkflowsExecutionsWorkflowIdStepsFailureUrl(workflowId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateWorkflowsAsyncResponse,)
  }
);}



/**
 * Set the status of a step in a workflow's execution as successful. This is useful for long-running workflows.
 * @summary Succeed a Step in a Workflow's Execution
 */
export type adminPostWorkflowsExecutionsWorkflowIdStepsSuccessResponse = {
  data: AdminPostWorkflowsExecutionsWorkflowIdStepsSuccess200;
  status: number;
  headers: Headers;
}

export const getAdminPostWorkflowsExecutionsWorkflowIdStepsSuccessUrl = (workflowId: string,) => {


  return `http://localhost:9000/admin/workflows-executions/${workflowId}/steps/success`
}

export const adminPostWorkflowsExecutionsWorkflowIdStepsSuccess = async (workflowId: string,
    adminCreateWorkflowsAsyncResponse: AdminCreateWorkflowsAsyncResponse, options?: RequestInit): Promise<adminPostWorkflowsExecutionsWorkflowIdStepsSuccessResponse> => {
  
  return customFetch<Promise<adminPostWorkflowsExecutionsWorkflowIdStepsSuccessResponse>>(getAdminPostWorkflowsExecutionsWorkflowIdStepsSuccessUrl(workflowId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminCreateWorkflowsAsyncResponse,)
  }
);}



/**
 * Subscribe to a workflow's execution to receive real-time information about its steps, status, and data.
This route returns an event stream that you can consume using the [EventSource API](https://developer.mozilla.org/en-US/docs/Web/API/EventSource).

 * @summary Subscribe to a Workflow's Execution
 */
export type adminGetWorkflowsExecutionsWorkflowIdSubscribeResponse = {
  data: string;
  status: number;
  headers: Headers;
}

export const getAdminGetWorkflowsExecutionsWorkflowIdSubscribeUrl = (workflowId: string,) => {


  return `http://localhost:9000/admin/workflows-executions/${workflowId}/subscribe`
}

export const adminGetWorkflowsExecutionsWorkflowIdSubscribe = async (workflowId: string, options?: RequestInit): Promise<adminGetWorkflowsExecutionsWorkflowIdSubscribeResponse> => {
  
  return customFetch<Promise<adminGetWorkflowsExecutionsWorkflowIdSubscribeResponse>>(getAdminGetWorkflowsExecutionsWorkflowIdSubscribeUrl(workflowId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Get the details of the workflow's execution.
 * @summary Get Workflow Execution's Details
 */
export type adminGetWorkflowsExecutionsWorkflowIdTransactionIdResponse = {
  data: AdminWorkflowExecutionResponse;
  status: number;
  headers: Headers;
}

export const getAdminGetWorkflowsExecutionsWorkflowIdTransactionIdUrl = (workflowId: string,
    transactionId: string,
    params?: AdminGetWorkflowsExecutionsWorkflowIdTransactionIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/admin/workflows-executions/${workflowId}/${transactionId}?${normalizedParams.toString()}` : `http://localhost:9000/admin/workflows-executions/${workflowId}/${transactionId}`
}

export const adminGetWorkflowsExecutionsWorkflowIdTransactionId = async (workflowId: string,
    transactionId: string,
    params?: AdminGetWorkflowsExecutionsWorkflowIdTransactionIdParams, options?: RequestInit): Promise<adminGetWorkflowsExecutionsWorkflowIdTransactionIdResponse> => {
  
  return customFetch<Promise<adminGetWorkflowsExecutionsWorkflowIdTransactionIdResponse>>(getAdminGetWorkflowsExecutionsWorkflowIdTransactionIdUrl(workflowId,transactionId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Subscribe to a step in a workflow's execution to receive real-time information about its status and data.
This route returns an event stream that you can consume using the [EventSource API](https://developer.mozilla.org/en-US/docs/Web/API/EventSource).

 * @summary Subscribe to Step of a Workflow's Execution
 */
export type adminGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse = {
  data: string;
  status: number;
  headers: Headers;
}

export const getAdminGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeUrl = (workflowId: string,
    transactionId: string,
    stepId: string,) => {


  return `http://localhost:9000/admin/workflows-executions/${workflowId}/${transactionId}/${stepId}/subscribe`
}

export const adminGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe = async (workflowId: string,
    transactionId: string,
    stepId: string, options?: RequestInit): Promise<adminGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse> => {
  
  return customFetch<Promise<adminGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse>>(getAdminGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeUrl(workflowId,transactionId,stepId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Set the cookie session ID of a customer. The customer must be previously authenticated with the `/auth/customer/{provider}` API route first, as the JWT token is required in the header of the request.
 * @summary Set Authentication Session
 */
export type storePostSessionResponse = {
  data: AuthStoreSessionResponse;
  status: number;
  headers: Headers;
}

export const getStorePostSessionUrl = () => {


  return `http://localhost:9000/auth/session`
}

export const storePostSession = async ( options?: RequestInit): Promise<storePostSessionResponse> => {
  
  return customFetch<Promise<storePostSessionResponse>>(getStorePostSessionUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Deletes the cookie session ID previously set for authentication.
 * @summary Delete Authentication Session
 */
export type storeDeleteSessionResponse = {
  data: StoreDeleteSession200;
  status: number;
  headers: Headers;
}

export const getStoreDeleteSessionUrl = () => {


  return `http://localhost:9000/auth/session`
}

export const storeDeleteSession = async ( options?: RequestInit): Promise<storeDeleteSessionResponse> => {
  
  return customFetch<Promise<storeDeleteSessionResponse>>(getStoreDeleteSessionUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Refresh the authentication token of a customer. This is useful after authenticating a customer with a third-party service to ensure the token holds the new user's details, or when you don't want customers to re-login every day.
 * @summary Refresh Authentication Token
 */
export type storePostAdminAuthTokenRefreshResponse = {
  data: AuthResponse;
  status: number;
  headers: Headers;
}

export const getStorePostAdminAuthTokenRefreshUrl = () => {


  return `http://localhost:9000/auth/token/refresh`
}

export const storePostAdminAuthTokenRefresh = async ( options?: RequestInit): Promise<storePostAdminAuthTokenRefreshResponse> => {
  
  return customFetch<Promise<storePostAdminAuthTokenRefreshResponse>>(getStorePostAdminAuthTokenRefreshUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Authenticate a user and receive the JWT token to be used in the header of subsequent requests.

When used with a third-party provider, such as Google, the request returns a `location` property. You redirect to the specified URL in your frontend to continue authentication with the third-party service.

 * @summary Authenticate User
 */
export type adminPostActorTypeAuthProviderResponse = {
  data: AdminPostActorTypeAuthProvider200;
  status: number;
  headers: Headers;
}

export const getAdminPostActorTypeAuthProviderUrl = (authProvider: string,) => {


  return `http://localhost:9000/auth/user/${authProvider}`
}

export const adminPostActorTypeAuthProvider = async (authProvider: string,
    adminPostActorTypeAuthProviderBody: AdminPostActorTypeAuthProviderBody, options?: RequestInit): Promise<adminPostActorTypeAuthProviderResponse> => {
  
  return customFetch<Promise<adminPostActorTypeAuthProviderResponse>>(getAdminPostActorTypeAuthProviderUrl(authProvider),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostActorTypeAuthProviderBody,)
  }
);}



/**
 * This API route is used by your dashboard or frontend application when a third-party provider redirects to it after authentication. 

It validates the authentication with the third-party provider and, if successful, returns an authentication token.

You can decode the JWT token using libraries like [react-jwt](https://www.npmjs.com/package/react-jwt) in the frontend. If the decoded data doesn't  have an `actor_id` property, then you must create a user, typically using the Accept Invite route passing the token in the request's Authorization header.

 * @summary Validate Authentication Callback
 */
export type adminPostActorTypeAuthProviderCallbackResponse = {
  data: AuthResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostActorTypeAuthProviderCallbackUrl = (authProvider: string,) => {


  return `http://localhost:9000/auth/user/${authProvider}/callback`
}

export const adminPostActorTypeAuthProviderCallback = async (authProvider: string, options?: RequestInit): Promise<adminPostActorTypeAuthProviderCallbackResponse> => {
  
  return customFetch<Promise<adminPostActorTypeAuthProviderCallbackResponse>>(getAdminPostActorTypeAuthProviderCallbackUrl(authProvider),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * This API route retrieves a registration JWT token of a user that hasn't been registered yet. The token is used in the header of requests that create a user, such as the Accept Invite API route.
 * @summary Retrieve Registration JWT Token
 */
export type adminPostActorTypeAuthProviderRegisterResponse = {
  data: AuthResponse;
  status: number;
  headers: Headers;
}

export const getAdminPostActorTypeAuthProviderRegisterUrl = (authProvider: string,) => {


  return `http://localhost:9000/auth/user/${authProvider}/register`
}

export const adminPostActorTypeAuthProviderRegister = async (authProvider: string,
    adminPostActorTypeAuthProviderRegisterBody: AdminPostActorTypeAuthProviderRegisterBody, options?: RequestInit): Promise<adminPostActorTypeAuthProviderRegisterResponse> => {
  
  return customFetch<Promise<adminPostActorTypeAuthProviderRegisterResponse>>(getAdminPostActorTypeAuthProviderRegisterUrl(authProvider),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostActorTypeAuthProviderRegisterBody,)
  }
);}



/**
 * Generate a reset password token for an admin user. This API route emits the `` event, passing it the token as a payload. You can listen to that event and send the user a notification. The notification should have a URL that accepts a `token` query parameter.


 Use the generated token to update the user's password using the Reset Password API route.

 * @summary Generate Reset Password Token for Admin User
 */
export type adminPostActorTypeAuthProviderResetPasswordResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getAdminPostActorTypeAuthProviderResetPasswordUrl = (authProvider: string,) => {


  return `http://localhost:9000/auth/user/${authProvider}/reset-password`
}

export const adminPostActorTypeAuthProviderResetPassword = async (authProvider: string,
    adminPostActorTypeAuthProviderResetPasswordBody: AdminPostActorTypeAuthProviderResetPasswordBody, options?: RequestInit): Promise<adminPostActorTypeAuthProviderResetPasswordResponse> => {
  
  return customFetch<Promise<adminPostActorTypeAuthProviderResetPasswordResponse>>(getAdminPostActorTypeAuthProviderResetPasswordUrl(authProvider),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostActorTypeAuthProviderResetPasswordBody,)
  }
);}



/**
 * Reset a user's password. Generate the reset password token first using the Get Reset Password Token API route.
 * @summary Reset an Admin User's Password
 */
export type adminPostActorTypeAuthProviderUpdateResponse = {
  data: AdminPostActorTypeAuthProviderUpdate200;
  status: number;
  headers: Headers;
}

export const getAdminPostActorTypeAuthProviderUpdateUrl = (authProvider: string,
    params: AdminPostActorTypeAuthProviderUpdateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/auth/user/${authProvider}/update?${normalizedParams.toString()}` : `http://localhost:9000/auth/user/${authProvider}/update`
}

export const adminPostActorTypeAuthProviderUpdate = async (authProvider: string,
    adminPostActorTypeAuthProviderUpdateBody: AdminPostActorTypeAuthProviderUpdateBody,
    params: AdminPostActorTypeAuthProviderUpdateParams, options?: RequestInit): Promise<adminPostActorTypeAuthProviderUpdateResponse> => {
  
  return customFetch<Promise<adminPostActorTypeAuthProviderUpdateResponse>>(getAdminPostActorTypeAuthProviderUpdateUrl(authProvider,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminPostActorTypeAuthProviderUpdateBody,)
  }
);}



/**
 * Authenticate a customer and receive the JWT token to be used in the header of subsequent requests.

When used with a third-party provider, such as Google, the request returns a `location` property. You redirect to the specified URL in your storefront to continue authentication with the third-party service.

 * @summary Authenticate Customer
 */
export type storePostActorTypeAuthProviderResponse = {
  data: StorePostActorTypeAuthProvider200;
  status: number;
  headers: Headers;
}

export const getStorePostActorTypeAuthProviderUrl = (authProvider: string,) => {


  return `http://localhost:9000/auth/customer/${authProvider}`
}

export const storePostActorTypeAuthProvider = async (authProvider: string,
    storePostActorTypeAuthProviderBody: StorePostActorTypeAuthProviderBody, options?: RequestInit): Promise<storePostActorTypeAuthProviderResponse> => {
  
  return customFetch<Promise<storePostActorTypeAuthProviderResponse>>(getStorePostActorTypeAuthProviderUrl(authProvider),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storePostActorTypeAuthProviderBody,)
  }
);}



/**
 * This API route is used by your storefront or frontend application when a third-party provider redirects to it after authentication. 

It validates the authentication with the third-party provider and, if successful, returns an authentication token.

You can decode the JWT token using libraries like [react-jwt](https://www.npmjs.com/package/react-jwt) in the storefront. If the decoded data doesn't  have an `actor_id` property, then you must register the customer using the Create Customer API route passing the token in the request's Authorization header.

 * @summary Validate Authentication Callback
 */
export type storePostActorTypeAuthProviderCallbackResponse = {
  data: AuthResponse;
  status: number;
  headers: Headers;
}

export const getStorePostActorTypeAuthProviderCallbackUrl = (authProvider: string,) => {


  return `http://localhost:9000/auth/customer/${authProvider}/callback`
}

export const storePostActorTypeAuthProviderCallback = async (authProvider: string, options?: RequestInit): Promise<storePostActorTypeAuthProviderCallbackResponse> => {
  
  return customFetch<Promise<storePostActorTypeAuthProviderCallbackResponse>>(getStorePostActorTypeAuthProviderCallbackUrl(authProvider),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * This API route retrieves a registration JWT token of a customer that hasn't been registered yet. The token is used in the header of requests that create a customer.
 * @summary Retrieve Registration JWT Token
 */
export type storePostActorTypeAuthProviderRegisterResponse = {
  data: AuthResponse;
  status: number;
  headers: Headers;
}

export const getStorePostActorTypeAuthProviderRegisterUrl = (authProvider: string,) => {


  return `http://localhost:9000/auth/customer/${authProvider}/register`
}

export const storePostActorTypeAuthProviderRegister = async (authProvider: string,
    storePostActorTypeAuthProviderRegisterBody: StorePostActorTypeAuthProviderRegisterBody, options?: RequestInit): Promise<storePostActorTypeAuthProviderRegisterResponse> => {
  
  return customFetch<Promise<storePostActorTypeAuthProviderRegisterResponse>>(getStorePostActorTypeAuthProviderRegisterUrl(authProvider),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storePostActorTypeAuthProviderRegisterBody,)
  }
);}



/**
 * Generate a reset password token for a customer. This API route emits the `auth.password_reset` event, passing it the token as a payload. You can listen to that event and send the user a notification. The notification should have a URL that accepts a `token` query parameter.


 Use the generated token to update the user's password using the Reset Password API route.

 * @summary Generate Reset Password Token for Customer
 */
export type storePostActorTypeAuthProviderResetPasswordResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getStorePostActorTypeAuthProviderResetPasswordUrl = (authProvider: string,) => {


  return `http://localhost:9000/auth/customer/${authProvider}/reset-password`
}

export const storePostActorTypeAuthProviderResetPassword = async (authProvider: string,
    storePostActorTypeAuthProviderResetPasswordBody: StorePostActorTypeAuthProviderResetPasswordBody, options?: RequestInit): Promise<storePostActorTypeAuthProviderResetPasswordResponse> => {
  
  return customFetch<Promise<storePostActorTypeAuthProviderResetPasswordResponse>>(getStorePostActorTypeAuthProviderResetPasswordUrl(authProvider),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storePostActorTypeAuthProviderResetPasswordBody,)
  }
);}



/**
 * Reset a customer's password. Generate the reset password token first using the Get Reset Password Token API route.
 * @summary Reset a Customer's Password
 */
export type storePostActorTypeAuthProviderUpdateResponse = {
  data: StorePostActorTypeAuthProviderUpdate200;
  status: number;
  headers: Headers;
}

export const getStorePostActorTypeAuthProviderUpdateUrl = (authProvider: string,
    params: StorePostActorTypeAuthProviderUpdateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/auth/customer/${authProvider}/update?${normalizedParams.toString()}` : `http://localhost:9000/auth/customer/${authProvider}/update`
}

export const storePostActorTypeAuthProviderUpdate = async (authProvider: string,
    storePostActorTypeAuthProviderUpdateBody: StorePostActorTypeAuthProviderUpdateBody,
    params: StorePostActorTypeAuthProviderUpdateParams, options?: RequestInit): Promise<storePostActorTypeAuthProviderUpdateResponse> => {
  
  return customFetch<Promise<storePostActorTypeAuthProviderUpdateResponse>>(getStorePostActorTypeAuthProviderUpdateUrl(authProvider,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storePostActorTypeAuthProviderUpdateBody,)
  }
);}



/**
 * Create a cart.
 * @summary Create Cart
 */
export type storePostCartsResponse = {
  data: StoreCartResponse;
  status: number;
  headers: Headers;
}

export const getStorePostCartsUrl = (params?: StorePostCartsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts?${normalizedParams.toString()}` : `http://localhost:9000/store/carts`
}

export const storePostCarts = async (storePostCartsBody: StorePostCartsBody,
    params?: StorePostCartsParams, options?: RequestInit): Promise<storePostCartsResponse> => {
  
  return customFetch<Promise<storePostCartsResponse>>(getStorePostCartsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storePostCartsBody,)
  }
);}



/**
 * Retrieve a cart by its ID. You can expand the cart's relations or select the fields that should be returned.
 * @summary Get a Cart
 */
export type storeGetCartsIdResponse = {
  data: StoreCartResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetCartsIdUrl = (id: string,
    params?: StoreGetCartsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts/${id}?${normalizedParams.toString()}` : `http://localhost:9000/store/carts/${id}`
}

export const storeGetCartsId = async (id: string,
    params?: StoreGetCartsIdParams, options?: RequestInit): Promise<storeGetCartsIdResponse> => {
  
  return customFetch<Promise<storeGetCartsIdResponse>>(getStoreGetCartsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update a cart's details. This unsets the shipping an payment methods chosen before, and the customer would have to choose them again.
 * @summary Update a Cart
 */
export type storePostCartsIdResponse = {
  data: StorePostCartsId200;
  status: number;
  headers: Headers;
}

export const getStorePostCartsIdUrl = (id: string,
    params?: StorePostCartsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts/${id}?${normalizedParams.toString()}` : `http://localhost:9000/store/carts/${id}`
}

export const storePostCartsId = async (id: string,
    storePostCartsIdBody: StorePostCartsIdBody,
    params?: StorePostCartsIdParams, options?: RequestInit): Promise<storePostCartsIdResponse> => {
  
  return customFetch<Promise<storePostCartsIdResponse>>(getStorePostCartsIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storePostCartsIdBody,)
  }
);}



/**
 * Complete a cart and place an order.
 * @summary Complete Cart
 */
export type storePostCartsIdCompleteResponse = {
  data: StorePostCartsIdComplete200;
  status: number;
  headers: Headers;
}

export const getStorePostCartsIdCompleteUrl = (id: string,
    params?: StorePostCartsIdCompleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts/${id}/complete?${normalizedParams.toString()}` : `http://localhost:9000/store/carts/${id}/complete`
}

export const storePostCartsIdComplete = async (id: string,
    params?: StorePostCartsIdCompleteParams, options?: RequestInit): Promise<storePostCartsIdCompleteResponse> => {
  
  return customFetch<Promise<storePostCartsIdCompleteResponse>>(getStorePostCartsIdCompleteUrl(id,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Set the customer of the cart. This is useful when you create the cart for a guest customer, then they log in with their account.
 * @summary Set Cart's Customer
 */
export type storePostCartsIdCustomerResponse = {
  data: StoreCartResponse;
  status: number;
  headers: Headers;
}

export const getStorePostCartsIdCustomerUrl = (id: string,
    params?: StorePostCartsIdCustomerParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts/${id}/customer?${normalizedParams.toString()}` : `http://localhost:9000/store/carts/${id}/customer`
}

export const storePostCartsIdCustomer = async (id: string,
    params?: StorePostCartsIdCustomerParams, options?: RequestInit): Promise<storePostCartsIdCustomerResponse> => {
  
  return customFetch<Promise<storePostCartsIdCustomerResponse>>(getStorePostCartsIdCustomerUrl(id,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Add a product variant as a line item in the cart.
 * @summary Add Line Item to Cart
 */
export type storePostCartsIdLineItemsResponse = {
  data: StoreCartResponse;
  status: number;
  headers: Headers;
}

export const getStorePostCartsIdLineItemsUrl = (id: string,
    params?: StorePostCartsIdLineItemsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts/${id}/line-items?${normalizedParams.toString()}` : `http://localhost:9000/store/carts/${id}/line-items`
}

export const storePostCartsIdLineItems = async (id: string,
    storeAddCartLineItem: StoreAddCartLineItem,
    params?: StorePostCartsIdLineItemsParams, options?: RequestInit): Promise<storePostCartsIdLineItemsResponse> => {
  
  return customFetch<Promise<storePostCartsIdLineItemsResponse>>(getStorePostCartsIdLineItemsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeAddCartLineItem,)
  }
);}



/**
 * Update a line item's details in the cart.
 * @summary Update a Line Item in a Cart
 */
export type storePostCartsIdLineItemsLineIdResponse = {
  data: StoreCartResponse;
  status: number;
  headers: Headers;
}

export const getStorePostCartsIdLineItemsLineIdUrl = (id: string,
    lineId: string,
    params?: StorePostCartsIdLineItemsLineIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts/${id}/line-items/${lineId}?${normalizedParams.toString()}` : `http://localhost:9000/store/carts/${id}/line-items/${lineId}`
}

export const storePostCartsIdLineItemsLineId = async (id: string,
    lineId: string,
    storeUpdateCartLineItem: StoreUpdateCartLineItem,
    params?: StorePostCartsIdLineItemsLineIdParams, options?: RequestInit): Promise<storePostCartsIdLineItemsLineIdResponse> => {
  
  return customFetch<Promise<storePostCartsIdLineItemsLineIdResponse>>(getStorePostCartsIdLineItemsLineIdUrl(id,lineId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeUpdateCartLineItem,)
  }
);}



/**
 * Remove a line item from a cart.
 * @summary Remove Line Item from Cart
 */
export type storeDeleteCartsIdLineItemsLineIdResponse = {
  data: StoreDeleteCartsIdLineItemsLineId200;
  status: number;
  headers: Headers;
}

export const getStoreDeleteCartsIdLineItemsLineIdUrl = (id: string,
    lineId: string,
    params?: StoreDeleteCartsIdLineItemsLineIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts/${id}/line-items/${lineId}?${normalizedParams.toString()}` : `http://localhost:9000/store/carts/${id}/line-items/${lineId}`
}

export const storeDeleteCartsIdLineItemsLineId = async (id: string,
    lineId: string,
    params?: StoreDeleteCartsIdLineItemsLineIdParams, options?: RequestInit): Promise<storeDeleteCartsIdLineItemsLineIdResponse> => {
  
  return customFetch<Promise<storeDeleteCartsIdLineItemsLineIdResponse>>(getStoreDeleteCartsIdLineItemsLineIdUrl(id,lineId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add a list of promotions to a cart.
 * @summary Add Promotions to Cart
 */
export type storePostCartsIdPromotionsResponse = {
  data: StoreCartResponse;
  status: number;
  headers: Headers;
}

export const getStorePostCartsIdPromotionsUrl = (id: string,
    params?: StorePostCartsIdPromotionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts/${id}/promotions?${normalizedParams.toString()}` : `http://localhost:9000/store/carts/${id}/promotions`
}

export const storePostCartsIdPromotions = async (id: string,
    storePostCartsIdPromotionsBody: StorePostCartsIdPromotionsBody,
    params?: StorePostCartsIdPromotionsParams, options?: RequestInit): Promise<storePostCartsIdPromotionsResponse> => {
  
  return customFetch<Promise<storePostCartsIdPromotionsResponse>>(getStorePostCartsIdPromotionsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storePostCartsIdPromotionsBody,)
  }
);}



/**
 * Remove a list of promotions from a cart.
 * @summary Remove Promotions from Cart
 */
export type storeDeleteCartsIdPromotionsResponse = {
  data: StoreDeleteCartsIdPromotions200;
  status: number;
  headers: Headers;
}

export const getStoreDeleteCartsIdPromotionsUrl = (id: string,
    params?: StoreDeleteCartsIdPromotionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts/${id}/promotions?${normalizedParams.toString()}` : `http://localhost:9000/store/carts/${id}/promotions`
}

export const storeDeleteCartsIdPromotions = async (id: string,
    params?: StoreDeleteCartsIdPromotionsParams, options?: RequestInit): Promise<storeDeleteCartsIdPromotionsResponse> => {
  
  return customFetch<Promise<storeDeleteCartsIdPromotionsResponse>>(getStoreDeleteCartsIdPromotionsUrl(id,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Add a shipping method to a cart. Use this API route when the customer chooses their preferred shipping option.
 * @summary Add Shipping Method to Cart
 */
export type storePostCartsIdShippingMethodsResponse = {
  data: StoreCartResponse;
  status: number;
  headers: Headers;
}

export const getStorePostCartsIdShippingMethodsUrl = (id: string,
    params?: StorePostCartsIdShippingMethodsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts/${id}/shipping-methods?${normalizedParams.toString()}` : `http://localhost:9000/store/carts/${id}/shipping-methods`
}

export const storePostCartsIdShippingMethods = async (id: string,
    storePostCartsIdShippingMethodsBody: StorePostCartsIdShippingMethodsBody,
    params?: StorePostCartsIdShippingMethodsParams, options?: RequestInit): Promise<storePostCartsIdShippingMethodsResponse> => {
  
  return customFetch<Promise<storePostCartsIdShippingMethodsResponse>>(getStorePostCartsIdShippingMethodsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storePostCartsIdShippingMethodsBody,)
  }
);}



/**
 * Calculate the cart's tax lines and amounts.
 * @summary Calculate Cart Taxes
 */
export type storePostCartsIdTaxesResponse = {
  data: StoreCartResponse;
  status: number;
  headers: Headers;
}

export const getStorePostCartsIdTaxesUrl = (id: string,
    params?: StorePostCartsIdTaxesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/carts/${id}/taxes?${normalizedParams.toString()}` : `http://localhost:9000/store/carts/${id}/taxes`
}

export const storePostCartsIdTaxes = async (id: string,
    params?: StorePostCartsIdTaxesParams, options?: RequestInit): Promise<storePostCartsIdTaxesResponse> => {
  
  return customFetch<Promise<storePostCartsIdTaxesResponse>>(getStorePostCartsIdTaxesUrl(id,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Retrieve a list of collections. The collections can be filtered by fields such as `handle`. The collections can also be sorted or paginated.
 * @summary List Collections
 */
export type storeGetCollectionsResponse = {
  data: StoreGetCollections200;
  status: number;
  headers: Headers;
}

export const getStoreGetCollectionsUrl = (params?: StoreGetCollectionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/collections?${normalizedParams.toString()}` : `http://localhost:9000/store/collections`
}

export const storeGetCollections = async (params?: StoreGetCollectionsParams, options?: RequestInit): Promise<storeGetCollectionsResponse> => {
  
  return customFetch<Promise<storeGetCollectionsResponse>>(getStoreGetCollectionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a collection by its ID. You can expand the collection's relations or select the fields that should be returned.
 * @summary Get a Collection
 */
export type storeGetCollectionsIdResponse = {
  data: StoreCollectionResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetCollectionsIdUrl = (id: string,
    params?: StoreGetCollectionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/collections/${id}?${normalizedParams.toString()}` : `http://localhost:9000/store/collections/${id}`
}

export const storeGetCollectionsId = async (id: string,
    params?: StoreGetCollectionsIdParams, options?: RequestInit): Promise<storeGetCollectionsIdResponse> => {
  
  return customFetch<Promise<storeGetCollectionsIdResponse>>(getStoreGetCollectionsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a list of currencies. The currencies can be filtered by fields such as `code`. The currencies can also be sorted or paginated.
 * @summary List Currencies
 */
export type storeGetCurrenciesResponse = {
  data: StoreCurrencyListResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetCurrenciesUrl = (params?: StoreGetCurrenciesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/currencies?${normalizedParams.toString()}` : `http://localhost:9000/store/currencies`
}

export const storeGetCurrencies = async (params?: StoreGetCurrenciesParams, options?: RequestInit): Promise<storeGetCurrenciesResponse> => {
  
  return customFetch<Promise<storeGetCurrenciesResponse>>(getStoreGetCurrenciesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a currency by its code. You can expand the currency's relations or select the fields that should be returned.
 * @summary Get a Currency
 */
export type storeGetCurrenciesCodeResponse = {
  data: StoreCurrencyResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetCurrenciesCodeUrl = (code: string,
    params?: StoreGetCurrenciesCodeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/currencies/${code}?${normalizedParams.toString()}` : `http://localhost:9000/store/currencies/${code}`
}

export const storeGetCurrenciesCode = async (code: string,
    params?: StoreGetCurrenciesCodeParams, options?: RequestInit): Promise<storeGetCurrenciesCodeResponse> => {
  
  return customFetch<Promise<storeGetCurrenciesCodeResponse>>(getStoreGetCurrenciesCodeUrl(code,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Register a customer. Use the `/auth/customer/emailpass/register` API route first to retrieve the registration token and pass it in the header of the request.
 * @summary Register Customer
 */
export type storePostCustomersResponse = {
  data: StoreCustomerResponse;
  status: number;
  headers: Headers;
}

export const getStorePostCustomersUrl = (params?: StorePostCustomersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/customers?${normalizedParams.toString()}` : `http://localhost:9000/store/customers`
}

export const storePostCustomers = async (storeCreateCustomer: StoreCreateCustomer,
    params?: StorePostCustomersParams, options?: RequestInit): Promise<storePostCustomersResponse> => {
  
  return customFetch<Promise<storePostCustomersResponse>>(getStorePostCustomersUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeCreateCustomer,)
  }
);}



/**
 * Retrieve the logged-in customer. You can expand the customer's relations or select the fields that should be returned.
 * @summary Get Logged-in Customer
 */
export type storeGetCustomersMeResponse = {
  data: StoreCustomerResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetCustomersMeUrl = (params?: StoreGetCustomersMeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/customers/me?${normalizedParams.toString()}` : `http://localhost:9000/store/customers/me`
}

export const storeGetCustomersMe = async (params?: StoreGetCustomersMeParams, options?: RequestInit): Promise<storeGetCustomersMeResponse> => {
  
  return customFetch<Promise<storeGetCustomersMeResponse>>(getStoreGetCustomersMeUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update the logged-in customer's details.
 * @summary Update Customer
 */
export type storePostCustomersMeResponse = {
  data: StoreCustomerResponse;
  status: number;
  headers: Headers;
}

export const getStorePostCustomersMeUrl = (params?: StorePostCustomersMeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/customers/me?${normalizedParams.toString()}` : `http://localhost:9000/store/customers/me`
}

export const storePostCustomersMe = async (storeUpdateCustomer: StoreUpdateCustomer,
    params?: StorePostCustomersMeParams, options?: RequestInit): Promise<storePostCustomersMeResponse> => {
  
  return customFetch<Promise<storePostCustomersMeResponse>>(getStorePostCustomersMeUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeUpdateCustomer,)
  }
);}



/**
 * Retrieve the addresses of the logged-in customer. The addresses can be filtered by fields such as `country_code`. The addresses can also be sorted or paginated.
 * @summary List Customer's Addresses
 */
export type storeGetCustomersMeAddressesResponse = {
  data: StoreCustomerAddressListResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetCustomersMeAddressesUrl = (params?: StoreGetCustomersMeAddressesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/customers/me/addresses?${normalizedParams.toString()}` : `http://localhost:9000/store/customers/me/addresses`
}

export const storeGetCustomersMeAddresses = async (params?: StoreGetCustomersMeAddressesParams, options?: RequestInit): Promise<storeGetCustomersMeAddressesResponse> => {
  
  return customFetch<Promise<storeGetCustomersMeAddressesResponse>>(getStoreGetCustomersMeAddressesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create an address for the logged-in customer.
 * @summary Create Address for Logged-In Customer
 */
export type storePostCustomersMeAddressesResponse = {
  data: StoreCustomerResponse;
  status: number;
  headers: Headers;
}

export const getStorePostCustomersMeAddressesUrl = (params?: StorePostCustomersMeAddressesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/customers/me/addresses?${normalizedParams.toString()}` : `http://localhost:9000/store/customers/me/addresses`
}

export const storePostCustomersMeAddresses = async (storePostCustomersMeAddressesBody: StorePostCustomersMeAddressesBody,
    params?: StorePostCustomersMeAddressesParams, options?: RequestInit): Promise<storePostCustomersMeAddressesResponse> => {
  
  return customFetch<Promise<storePostCustomersMeAddressesResponse>>(getStorePostCustomersMeAddressesUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storePostCustomersMeAddressesBody,)
  }
);}



/**
 * Retrieve an address of the logged-in customer. You can expand the address's relations or select the fields that should be returned.
 * @summary Get Customer's Address
 */
export type storeGetCustomersMeAddressesAddressIdResponse = {
  data: StoreCustomerAddressResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetCustomersMeAddressesAddressIdUrl = (addressId: string,
    params?: StoreGetCustomersMeAddressesAddressIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/customers/me/addresses/${addressId}?${normalizedParams.toString()}` : `http://localhost:9000/store/customers/me/addresses/${addressId}`
}

export const storeGetCustomersMeAddressesAddressId = async (addressId: string,
    params?: StoreGetCustomersMeAddressesAddressIdParams, options?: RequestInit): Promise<storeGetCustomersMeAddressesAddressIdResponse> => {
  
  return customFetch<Promise<storeGetCustomersMeAddressesAddressIdResponse>>(getStoreGetCustomersMeAddressesAddressIdUrl(addressId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Update the logged-in customer's address.
 * @summary Update Customer's Address
 */
export type storePostCustomersMeAddressesAddressIdResponse = {
  data: StoreCustomerResponse;
  status: number;
  headers: Headers;
}

export const getStorePostCustomersMeAddressesAddressIdUrl = (addressId: string,
    params?: StorePostCustomersMeAddressesAddressIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/customers/me/addresses/${addressId}?${normalizedParams.toString()}` : `http://localhost:9000/store/customers/me/addresses/${addressId}`
}

export const storePostCustomersMeAddressesAddressId = async (addressId: string,
    storePostCustomersMeAddressesAddressIdBody: StorePostCustomersMeAddressesAddressIdBody,
    params?: StorePostCustomersMeAddressesAddressIdParams, options?: RequestInit): Promise<storePostCustomersMeAddressesAddressIdResponse> => {
  
  return customFetch<Promise<storePostCustomersMeAddressesAddressIdResponse>>(getStorePostCustomersMeAddressesAddressIdUrl(addressId,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storePostCustomersMeAddressesAddressIdBody,)
  }
);}



/**
 * Remove an address of the logged-in customer.
 * @summary Remove Customer's Address
 */
export type storeDeleteCustomersMeAddressesAddressIdResponse = {
  data: StoreDeleteCustomersMeAddressesAddressId200;
  status: number;
  headers: Headers;
}

export const getStoreDeleteCustomersMeAddressesAddressIdUrl = (addressId: string,
    params?: StoreDeleteCustomersMeAddressesAddressIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/customers/me/addresses/${addressId}?${normalizedParams.toString()}` : `http://localhost:9000/store/customers/me/addresses/${addressId}`
}

export const storeDeleteCustomersMeAddressesAddressId = async (addressId: string,
    params?: StoreDeleteCustomersMeAddressesAddressIdParams, options?: RequestInit): Promise<storeDeleteCustomersMeAddressesAddressIdResponse> => {
  
  return customFetch<Promise<storeDeleteCustomersMeAddressesAddressIdResponse>>(getStoreDeleteCustomersMeAddressesAddressIdUrl(addressId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieve the orders of the logged-in customer. The orders can be filtered by fields such as `id`. The orders can also be sorted or paginated.
 * @summary List Logged-in Customer's Orders
 */
export type storeGetOrdersResponse = {
  data: StoreGetOrders200;
  status: number;
  headers: Headers;
}

export const getStoreGetOrdersUrl = (params?: StoreGetOrdersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/orders?${normalizedParams.toString()}` : `http://localhost:9000/store/orders`
}

export const storeGetOrders = async (params?: StoreGetOrdersParams, options?: RequestInit): Promise<storeGetOrdersResponse> => {
  
  return customFetch<Promise<storeGetOrdersResponse>>(getStoreGetOrdersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve an order by its ID. You can expand the order's relations or select the fields that should be returned.
 * @summary Get an Order
 */
export type storeGetOrdersIdResponse = {
  data: StoreOrderResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetOrdersIdUrl = (id: string,
    params?: StoreGetOrdersIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/orders/${id}?${normalizedParams.toString()}` : `http://localhost:9000/store/orders/${id}`
}

export const storeGetOrdersId = async (id: string,
    params?: StoreGetOrdersIdParams, options?: RequestInit): Promise<storeGetOrdersIdResponse> => {
  
  return customFetch<Promise<storeGetOrdersIdResponse>>(getStoreGetOrdersIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Accept an order to be transfered to a customer's account, which was specified when the transfer request was created. The transfer is requested previously either by the customer using the [Request Order Transfer Store API route](https://docs.medusajs.com/api/store#orders_postordersidtransferrequest), or by the admin using the [Request Order Transfer Admin API route](https://docs.medusajs.com/api/admin#orders_postordersidtransferrequest).
 * @summary Accept Order Transfer
 */
export type storePostOrdersIdTransferAcceptResponse = {
  data: StoreOrderResponse;
  status: number;
  headers: Headers;
}

export const getStorePostOrdersIdTransferAcceptUrl = (id: string,
    params?: StorePostOrdersIdTransferAcceptParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/orders/${id}/transfer/accept?${normalizedParams.toString()}` : `http://localhost:9000/store/orders/${id}/transfer/accept`
}

export const storePostOrdersIdTransferAccept = async (id: string,
    storeAcceptOrderTransfer: StoreAcceptOrderTransfer,
    params?: StorePostOrdersIdTransferAcceptParams, options?: RequestInit): Promise<storePostOrdersIdTransferAcceptResponse> => {
  
  return customFetch<Promise<storePostOrdersIdTransferAcceptResponse>>(getStorePostOrdersIdTransferAcceptUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeAcceptOrderTransfer,)
  }
);}



/**
 * Cancel an order transfer that the logged-in customer previously requested using the [Request Order Transfer](https://docs.medusajs.com/api/store#orders_postordersidtransferrequest) API route.
 * @summary Cancel Order Transfer
 */
export type storePostOrdersIdTransferCancelResponse = {
  data: StoreOrderResponse;
  status: number;
  headers: Headers;
}

export const getStorePostOrdersIdTransferCancelUrl = (id: string,
    params?: StorePostOrdersIdTransferCancelParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/orders/${id}/transfer/cancel?${normalizedParams.toString()}` : `http://localhost:9000/store/orders/${id}/transfer/cancel`
}

export const storePostOrdersIdTransferCancel = async (id: string,
    params?: StorePostOrdersIdTransferCancelParams, options?: RequestInit): Promise<storePostOrdersIdTransferCancelResponse> => {
  
  return customFetch<Promise<storePostOrdersIdTransferCancelResponse>>(getStorePostOrdersIdTransferCancelUrl(id,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Decline an order transfer previously requested, typically by the admin user using the [Request Order Transfer Admin API route](https://docs.medusajs.com/api/admin#orders_postordersidtransferrequest).
 * @summary Decline Order Transfer
 */
export type storePostOrdersIdTransferDeclineResponse = {
  data: StoreOrderResponse;
  status: number;
  headers: Headers;
}

export const getStorePostOrdersIdTransferDeclineUrl = (id: string,
    params?: StorePostOrdersIdTransferDeclineParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/orders/${id}/transfer/decline?${normalizedParams.toString()}` : `http://localhost:9000/store/orders/${id}/transfer/decline`
}

export const storePostOrdersIdTransferDecline = async (id: string,
    storeDeclineOrderTransferRequest: StoreDeclineOrderTransferRequest,
    params?: StorePostOrdersIdTransferDeclineParams, options?: RequestInit): Promise<storePostOrdersIdTransferDeclineResponse> => {
  
  return customFetch<Promise<storePostOrdersIdTransferDeclineResponse>>(getStorePostOrdersIdTransferDeclineUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeDeclineOrderTransferRequest,)
  }
);}



/**
 * Request an order to be transfered to the logged-in customer's account. The transfer is confirmed using the [Accept Order Transfer](https://docs.medusajs.com/api/store#orders_postordersidtransferaccept) API route.
 * @summary Request Order Transfer
 */
export type storePostOrdersIdTransferRequestResponse = {
  data: StoreOrderResponse;
  status: number;
  headers: Headers;
}

export const getStorePostOrdersIdTransferRequestUrl = (id: string,
    params?: StorePostOrdersIdTransferRequestParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/orders/${id}/transfer/request?${normalizedParams.toString()}` : `http://localhost:9000/store/orders/${id}/transfer/request`
}

export const storePostOrdersIdTransferRequest = async (id: string,
    storeRequestOrderTransfer: StoreRequestOrderTransfer,
    params?: StorePostOrdersIdTransferRequestParams, options?: RequestInit): Promise<storePostOrdersIdTransferRequestResponse> => {
  
  return customFetch<Promise<storePostOrdersIdTransferRequestResponse>>(getStorePostOrdersIdTransferRequestUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeRequestOrderTransfer,)
  }
);}



/**
 * Create a payment collection for a cart. This is used during checkout, where the payment collection holds the cart's payment sessions.
 * @summary Create Payment Collection
 */
export type storePostPaymentCollectionsResponse = {
  data: StorePaymentCollectionResponse;
  status: number;
  headers: Headers;
}

export const getStorePostPaymentCollectionsUrl = (params?: StorePostPaymentCollectionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/payment-collections?${normalizedParams.toString()}` : `http://localhost:9000/store/payment-collections`
}

export const storePostPaymentCollections = async (storeCreatePaymentCollection: StoreCreatePaymentCollection,
    params?: StorePostPaymentCollectionsParams, options?: RequestInit): Promise<storePostPaymentCollectionsResponse> => {
  
  return customFetch<Promise<storePostPaymentCollectionsResponse>>(getStorePostPaymentCollectionsUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeCreatePaymentCollection,)
  }
);}



/**
 * Initialize and add a payment session to a payment collection. This is used during checkout, where you create a payment collection for the cart, then initialize a payment session for the payment provider that the customer chooses.
 * @summary Initialize Payment Session of a Payment Collection
 */
export type storePostPaymentCollectionsIdPaymentSessionsResponse = {
  data: StorePaymentCollectionResponse;
  status: number;
  headers: Headers;
}

export const getStorePostPaymentCollectionsIdPaymentSessionsUrl = (id: string,
    params?: StorePostPaymentCollectionsIdPaymentSessionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/payment-collections/${id}/payment-sessions?${normalizedParams.toString()}` : `http://localhost:9000/store/payment-collections/${id}/payment-sessions`
}

export const storePostPaymentCollectionsIdPaymentSessions = async (id: string,
    storeInitializePaymentSession: StoreInitializePaymentSession,
    params?: StorePostPaymentCollectionsIdPaymentSessionsParams, options?: RequestInit): Promise<storePostPaymentCollectionsIdPaymentSessionsResponse> => {
  
  return customFetch<Promise<storePostPaymentCollectionsIdPaymentSessionsResponse>>(getStorePostPaymentCollectionsIdPaymentSessionsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeInitializePaymentSession,)
  }
);}



/**
 * Retrieve a list of payment providers. You must provide the `region_id` query parameter to retrieve the payment providers enabled in that region.
 * @summary List Payment Providers
 */
export type storeGetPaymentProvidersResponse = {
  data: StoreGetPaymentProviders200;
  status: number;
  headers: Headers;
}

export const getStoreGetPaymentProvidersUrl = (params: StoreGetPaymentProvidersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/payment-providers?${normalizedParams.toString()}` : `http://localhost:9000/store/payment-providers`
}

export const storeGetPaymentProviders = async (params: StoreGetPaymentProvidersParams, options?: RequestInit): Promise<storeGetPaymentProvidersResponse> => {
  
  return customFetch<Promise<storeGetPaymentProvidersResponse>>(getStoreGetPaymentProvidersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a list of product categories. The product categories can be filtered by fields such as `id`. The product categories can also be sorted or paginated.
 * @summary List Product Categories
 */
export type storeGetProductCategoriesResponse = {
  data: StoreProductCategoryListResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetProductCategoriesUrl = (params?: StoreGetProductCategoriesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/product-categories?${normalizedParams.toString()}` : `http://localhost:9000/store/product-categories`
}

export const storeGetProductCategories = async (params?: StoreGetProductCategoriesParams, options?: RequestInit): Promise<storeGetProductCategoriesResponse> => {
  
  return customFetch<Promise<storeGetProductCategoriesResponse>>(getStoreGetProductCategoriesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a product category by its ID. You can expand the product category's relations or select the fields that should be returned.
 * @summary Get a Product Category
 */
export type storeGetProductCategoriesIdResponse = {
  data: StoreProductCategoryResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetProductCategoriesIdUrl = (id: string,
    params?: StoreGetProductCategoriesIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/product-categories/${id}?${normalizedParams.toString()}` : `http://localhost:9000/store/product-categories/${id}`
}

export const storeGetProductCategoriesId = async (id: string,
    params?: StoreGetProductCategoriesIdParams, options?: RequestInit): Promise<storeGetProductCategoriesIdResponse> => {
  
  return customFetch<Promise<storeGetProductCategoriesIdResponse>>(getStoreGetProductCategoriesIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a list of products. The products can be filtered by fields such as `id`. The products can also be sorted or paginated.
 * @summary List Products
 */
export type storeGetProductsResponse = {
  data: StoreGetProducts200;
  status: number;
  headers: Headers;
}

export const getStoreGetProductsUrl = (params?: StoreGetProductsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/products?${normalizedParams.toString()}` : `http://localhost:9000/store/products`
}

export const storeGetProducts = async (params?: StoreGetProductsParams, options?: RequestInit): Promise<storeGetProductsResponse> => {
  
  return customFetch<Promise<storeGetProductsResponse>>(getStoreGetProductsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a product by its ID. You can expand the product's relations or select the fields that should be returned.
 * @summary Get a Product
 */
export type storeGetProductsIdResponse = {
  data: StoreProductResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetProductsIdUrl = (id: string,
    params?: StoreGetProductsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/products/${id}?${normalizedParams.toString()}` : `http://localhost:9000/store/products/${id}`
}

export const storeGetProductsId = async (id: string,
    params?: StoreGetProductsIdParams, options?: RequestInit): Promise<storeGetProductsIdResponse> => {
  
  return customFetch<Promise<storeGetProductsIdResponse>>(getStoreGetProductsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a list of regions. The regions can be filtered by fields such as `id`. The regions can also be sorted or paginated.
 * @summary List Regions
 */
export type storeGetRegionsResponse = {
  data: StoreGetRegions200;
  status: number;
  headers: Headers;
}

export const getStoreGetRegionsUrl = (params?: StoreGetRegionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/regions?${normalizedParams.toString()}` : `http://localhost:9000/store/regions`
}

export const storeGetRegions = async (params?: StoreGetRegionsParams, options?: RequestInit): Promise<storeGetRegionsResponse> => {
  
  return customFetch<Promise<storeGetRegionsResponse>>(getStoreGetRegionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a region by its ID. You can expand the region's relations or select the fields that should be returned.
 * @summary Get a Region
 */
export type storeGetRegionsIdResponse = {
  data: StoreGetRegionsId200;
  status: number;
  headers: Headers;
}

export const getStoreGetRegionsIdUrl = (id: string,
    params?: StoreGetRegionsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/regions/${id}?${normalizedParams.toString()}` : `http://localhost:9000/store/regions/${id}`
}

export const storeGetRegionsId = async (id: string,
    params?: StoreGetRegionsIdParams, options?: RequestInit): Promise<storeGetRegionsIdResponse> => {
  
  return customFetch<Promise<storeGetRegionsIdResponse>>(getStoreGetRegionsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Create a return for an order's items. The admin receives the return and process it from their side.
 * @summary Create Return
 */
export type storePostReturnResponse = {
  data: StoreReturnResponse;
  status: number;
  headers: Headers;
}

export const getStorePostReturnUrl = () => {


  return `http://localhost:9000/store/return`
}

export const storePostReturn = async (storeCreateReturn: StoreCreateReturn, options?: RequestInit): Promise<storePostReturnResponse> => {
  
  return customFetch<Promise<storePostReturnResponse>>(getStorePostReturnUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeCreateReturn,)
  }
);}



/**
 * Retrieve a list of return reasons. The return reasons can be sorted or paginated.
 * @summary List Return Reasons
 */
export type storeGetReturnReasonsResponse = {
  data: StoreGetReturnReasons200;
  status: number;
  headers: Headers;
}

export const getStoreGetReturnReasonsUrl = (params?: StoreGetReturnReasonsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/return-reasons?${normalizedParams.toString()}` : `http://localhost:9000/store/return-reasons`
}

export const storeGetReturnReasons = async (params?: StoreGetReturnReasonsParams, options?: RequestInit): Promise<storeGetReturnReasonsResponse> => {
  
  return customFetch<Promise<storeGetReturnReasonsResponse>>(getStoreGetReturnReasonsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a return reason by its ID. You can expand the return reason's relations or select the fields that should be returned.
 * @summary Get a Return Reason
 */
export type storeGetReturnReasonsIdResponse = {
  data: StoreReturnReasonResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetReturnReasonsIdUrl = (id: string,
    params?: StoreGetReturnReasonsIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/return-reasons/${id}?${normalizedParams.toString()}` : `http://localhost:9000/store/return-reasons/${id}`
}

export const storeGetReturnReasonsId = async (id: string,
    params?: StoreGetReturnReasonsIdParams, options?: RequestInit): Promise<storeGetReturnReasonsIdResponse> => {
  
  return customFetch<Promise<storeGetReturnReasonsIdResponse>>(getStoreGetReturnReasonsIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieve a list of shipping options for a cart. The cart's ID is set in the required `cart_id` query parameter.

The shipping options also be sorted or paginated.

 * @summary List Shipping Options for Cart
 */
export type storeGetShippingOptionsResponse = {
  data: StoreShippingOptionListResponse;
  status: number;
  headers: Headers;
}

export const getStoreGetShippingOptionsUrl = (params: StoreGetShippingOptionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/shipping-options?${normalizedParams.toString()}` : `http://localhost:9000/store/shipping-options`
}

export const storeGetShippingOptions = async (params: StoreGetShippingOptionsParams, options?: RequestInit): Promise<storeGetShippingOptionsResponse> => {
  
  return customFetch<Promise<storeGetShippingOptionsResponse>>(getStoreGetShippingOptionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Calculate the price of a shipping option in a cart.
 * @summary Calculate Shipping Option Price
 */
export type storePostShippingOptionsIdCalculateResponse = {
  data: StoreShippingOptionResponse;
  status: number;
  headers: Headers;
}

export const getStorePostShippingOptionsIdCalculateUrl = (id: string,
    params?: StorePostShippingOptionsIdCalculateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/store/shipping-options/${id}/calculate?${normalizedParams.toString()}` : `http://localhost:9000/store/shipping-options/${id}/calculate`
}

export const storePostShippingOptionsIdCalculate = async (id: string,
    storePostShippingOptionsIdCalculateBody: StorePostShippingOptionsIdCalculateBody,
    params?: StorePostShippingOptionsIdCalculateParams, options?: RequestInit): Promise<storePostShippingOptionsIdCalculateResponse> => {
  
  return customFetch<Promise<storePostShippingOptionsIdCalculateResponse>>(getStorePostShippingOptionsIdCalculateUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storePostShippingOptionsIdCalculateBody,)
  }
);}



/**
 * Authenticate a seller and receive the JWT token to be used in the header of subsequent requests.

When used with a third-party provider, such as Google, the request returns a `location` property. You redirect to the specified URL in your frontend to continue authentication with the third-party service.

 * @summary Authenticate Seller
 */
export type postSellerTypeAuthProviderResponse = {
  data: PostSellerTypeAuthProvider200;
  status: number;
  headers: Headers;
}

export const getPostSellerTypeAuthProviderUrl = (authProvider: string,) => {


  return `http://localhost:9000/auth/seller/${authProvider}`
}

export const postSellerTypeAuthProvider = async (authProvider: string,
    postSellerTypeAuthProviderBody: PostSellerTypeAuthProviderBody, options?: RequestInit): Promise<postSellerTypeAuthProviderResponse> => {
  
  return customFetch<Promise<postSellerTypeAuthProviderResponse>>(getPostSellerTypeAuthProviderUrl(authProvider),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postSellerTypeAuthProviderBody,)
  }
);}



/**
 * This API route retrieves a registration JWT token of a seller that hasn't been registered yet. The token is used in the header of requests that create a seller, such as the Accept Invite API route.
 * @summary Retrieve Registration JWT Token
 */
export type postSellerTypeAuthProviderRegisterResponse = {
  data: AuthResponse;
  status: number;
  headers: Headers;
}

export const getPostSellerTypeAuthProviderRegisterUrl = (authProvider: string,) => {


  return `http://localhost:9000/auth/seller/${authProvider}/register`
}

export const postSellerTypeAuthProviderRegister = async (authProvider: string,
    postSellerTypeAuthProviderRegisterBody: PostSellerTypeAuthProviderRegisterBody, options?: RequestInit): Promise<postSellerTypeAuthProviderRegisterResponse> => {
  
  return customFetch<Promise<postSellerTypeAuthProviderRegisterResponse>>(getPostSellerTypeAuthProviderRegisterUrl(authProvider),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postSellerTypeAuthProviderRegisterBody,)
  }
);}



/**
 * Deletes a Fulfillment Set.
 * @summary Delete a Fulfillment Set
 */
export type vendorDeleteFulfillmentSetResponse = {
  data: VendorDeleteFulfillmentSet200;
  status: number;
  headers: Headers;
}

export const getVendorDeleteFulfillmentSetUrl = (id: string,) => {


  return `http://localhost:9000/vendor/fulfillment-sets/${id}`
}

export const vendorDeleteFulfillmentSet = async (id: string, options?: RequestInit): Promise<vendorDeleteFulfillmentSetResponse> => {
  
  return customFetch<Promise<vendorDeleteFulfillmentSetResponse>>(getVendorDeleteFulfillmentSetUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Creates a Service Zone.
 * @summary Create a Service Zone
 */
export type vendorCreateServiceZoneResponse = {
  data: VendorCreateServiceZone200;
  status: number;
  headers: Headers;
}

export const getVendorCreateServiceZoneUrl = (id: string,) => {


  return `http://localhost:9000/vendor/fulfillment-sets/${id}/service-zones`
}

export const vendorCreateServiceZone = async (id: string,
    vendorCreateServiceZone: VendorCreateServiceZone, options?: RequestInit): Promise<vendorCreateServiceZoneResponse> => {
  
  return customFetch<Promise<vendorCreateServiceZoneResponse>>(getVendorCreateServiceZoneUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorCreateServiceZone,)
  }
);}



/**
 * Updates a Service Zone.
 * @summary Update a Service Zone
 */
export type vendorUpdateServiceZoneByIdResponse = {
  data: VendorUpdateServiceZoneById200;
  status: number;
  headers: Headers;
}

export const getVendorUpdateServiceZoneByIdUrl = (id: string,
    zoneId: string,) => {


  return `http://localhost:9000/vendor/fulfillment-sets/${id}/service-zones/${zoneId}`
}

export const vendorUpdateServiceZoneById = async (id: string,
    zoneId: string,
    vendorUpdateServiceZone: VendorUpdateServiceZone, options?: RequestInit): Promise<vendorUpdateServiceZoneByIdResponse> => {
  
  return customFetch<Promise<vendorUpdateServiceZoneByIdResponse>>(getVendorUpdateServiceZoneByIdUrl(id,zoneId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorUpdateServiceZone,)
  }
);}



/**
 * Deletes a Service Zone.
 * @summary Delete a Service Zone
 */
export type vendorDeleteServiceZoneByIdResponse = {
  data: VendorDeleteServiceZoneById200;
  status: number;
  headers: Headers;
}

export const getVendorDeleteServiceZoneByIdUrl = (id: string,
    zoneId: string,) => {


  return `http://localhost:9000/vendor/fulfillment-sets/${id}/service-zones/${zoneId}`
}

export const vendorDeleteServiceZoneById = async (id: string,
    zoneId: string, options?: RequestInit): Promise<vendorDeleteServiceZoneByIdResponse> => {
  
  return customFetch<Promise<vendorDeleteServiceZoneByIdResponse>>(getVendorDeleteServiceZoneByIdUrl(id,zoneId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieves list of InventoryItems
 * @summary List InventoryItems
 */
export type vendorListInventoryItemResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getVendorListInventoryItemUrl = () => {


  return `http://localhost:9000/vendor/inventory-items`
}

export const vendorListInventoryItem = async ( options?: RequestInit): Promise<vendorListInventoryItemResponse> => {
  
  return customFetch<Promise<vendorListInventoryItemResponse>>(getVendorListInventoryItemUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieves InventoryItem of specified id
 * @summary Get inventory item
 */
export type vendorGetInventoryItemResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getVendorGetInventoryItemUrl = (id: string,) => {


  return `http://localhost:9000/vendor/inventory-items/${id}`
}

export const vendorGetInventoryItem = async (id: string, options?: RequestInit): Promise<vendorGetInventoryItemResponse> => {
  
  return customFetch<Promise<vendorGetInventoryItemResponse>>(getVendorGetInventoryItemUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Updates InventoryItem of specified id
 * @summary Update inventory item
 */
export type vendorUpdateInventoryItemResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getVendorUpdateInventoryItemUrl = (id: string,) => {


  return `http://localhost:9000/vendor/inventory-items/${id}`
}

export const vendorUpdateInventoryItem = async (id: string,
    vendorUpdateInventoryItem: VendorUpdateInventoryItem, options?: RequestInit): Promise<vendorUpdateInventoryItemResponse> => {
  
  return customFetch<Promise<vendorUpdateInventoryItemResponse>>(getVendorUpdateInventoryItemUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorUpdateInventoryItem,)
  }
);}



/**
 * Retrieves inventory levels of the InventoryItem
 * @summary Get InventoryLevels of specified InventoryItem 
 */
export type vendorGetItemInventoryLevelResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getVendorGetItemInventoryLevelUrl = (id: string,) => {


  return `http://localhost:9000/vendor/inventory-items/${id}/location-levels`
}

export const vendorGetItemInventoryLevel = async (id: string, options?: RequestInit): Promise<vendorGetItemInventoryLevelResponse> => {
  
  return customFetch<Promise<vendorGetItemInventoryLevelResponse>>(getVendorGetItemInventoryLevelUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Creates inventory level of the InventoryItem in the specified location
 * @summary Create inventory level
 */
export type vendorCreateInventoryLevelResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getVendorCreateInventoryLevelUrl = (id: string,) => {


  return `http://localhost:9000/vendor/inventory-items/${id}/location-levels`
}

export const vendorCreateInventoryLevel = async (id: string,
    vendorCreateInventoryLevel: VendorCreateInventoryLevel, options?: RequestInit): Promise<vendorCreateInventoryLevelResponse> => {
  
  return customFetch<Promise<vendorCreateInventoryLevelResponse>>(getVendorCreateInventoryLevelUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorCreateInventoryLevel,)
  }
);}



/**
 * Retrieves inventory level of the InventoryItem in the specified location
 * @summary Get inventory level
 */
export type vendorGetInventoryLevelResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getVendorGetInventoryLevelUrl = (id: string,
    locationId: string,) => {


  return `http://localhost:9000/vendor/inventory-items/${id}/location-levels/${locationId}`
}

export const vendorGetInventoryLevel = async (id: string,
    locationId: string, options?: RequestInit): Promise<vendorGetInventoryLevelResponse> => {
  
  return customFetch<Promise<vendorGetInventoryLevelResponse>>(getVendorGetInventoryLevelUrl(id,locationId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Updates inventory level of the InventoryItem in the specified location
 * @summary Update inventory level
 */
export type vendorUpdateInventoryLevelResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getVendorUpdateInventoryLevelUrl = (id: string,
    locationId: string,) => {


  return `http://localhost:9000/vendor/inventory-items/${id}/location-levels/${locationId}`
}

export const vendorUpdateInventoryLevel = async (id: string,
    locationId: string,
    vendorUpdateInventoryLevel: VendorUpdateInventoryLevel, options?: RequestInit): Promise<vendorUpdateInventoryLevelResponse> => {
  
  return customFetch<Promise<vendorUpdateInventoryLevelResponse>>(getVendorUpdateInventoryLevelUrl(id,locationId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorUpdateInventoryLevel,)
  }
);}



/**
 * Retrieves a list of member invites for the authenticated vendor.
 * @summary List Member Invites
 */
export type vendorListInvitesResponse = {
  data: VendorListInvites200;
  status: number;
  headers: Headers;
}

export const getVendorListInvitesUrl = (params?: VendorListInvitesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/invites?${normalizedParams.toString()}` : `http://localhost:9000/vendor/invites`
}

export const vendorListInvites = async (params?: VendorListInvitesParams, options?: RequestInit): Promise<vendorListInvitesResponse> => {
  
  return customFetch<Promise<vendorListInvitesResponse>>(getVendorListInvitesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Creates a new member invite for the authenticated vendor.
 * @summary Create a Member Invite
 */
export type vendorCreateInviteResponse = {
  data: VendorCreateInvite201;
  status: number;
  headers: Headers;
}

export const getVendorCreateInviteUrl = () => {


  return `http://localhost:9000/vendor/invites`
}

export const vendorCreateInvite = async (vendorInviteMember: VendorInviteMember, options?: RequestInit): Promise<vendorCreateInviteResponse> => {
  
  return customFetch<Promise<vendorCreateInviteResponse>>(getVendorCreateInviteUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorInviteMember,)
  }
);}



/**
 * Accepts a member invite using the provided token and creates a new member.
 * @summary Accept a Member Invite
 */
export type vendorAcceptInviteResponse = {
  data: VendorAcceptInvite200;
  status: number;
  headers: Headers;
}

export const getVendorAcceptInviteUrl = (id: string,) => {


  return `http://localhost:9000/vendor/invites/${id}/accept`
}

export const vendorAcceptInvite = async (id: string,
    vendorAcceptMemberInvite: VendorAcceptMemberInvite, options?: RequestInit): Promise<vendorAcceptInviteResponse> => {
  
  return customFetch<Promise<vendorAcceptInviteResponse>>(getVendorAcceptInviteUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorAcceptMemberInvite,)
  }
);}



/**
 * Retrieves a list of members.
 * @summary List Members
 */
export type vendorListMembersResponse = {
  data: VendorListMembers200;
  status: number;
  headers: Headers;
}

export const getVendorListMembersUrl = (params?: VendorListMembersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/members?${normalizedParams.toString()}` : `http://localhost:9000/vendor/members`
}

export const vendorListMembers = async (params?: VendorListMembersParams, options?: RequestInit): Promise<vendorListMembersResponse> => {
  
  return customFetch<Promise<vendorListMembersResponse>>(getVendorListMembersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieves the member associated with the authenticated user.
 * @summary Get Current Member
 */
export type vendorGetMemberMeResponse = {
  data: VendorGetMemberMe200;
  status: number;
  headers: Headers;
}

export const getVendorGetMemberMeUrl = () => {


  return `http://localhost:9000/vendor/members/me`
}

export const vendorGetMemberMe = async ( options?: RequestInit): Promise<vendorGetMemberMeResponse> => {
  
  return customFetch<Promise<vendorGetMemberMeResponse>>(getVendorGetMemberMeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieves a member by id.
 * @summary Get a Member
 */
export type vendorGetMemberByIdResponse = {
  data: VendorGetMemberById200;
  status: number;
  headers: Headers;
}

export const getVendorGetMemberByIdUrl = (id: string,) => {


  return `http://localhost:9000/vendor/members/${id}`
}

export const vendorGetMemberById = async (id: string, options?: RequestInit): Promise<vendorGetMemberByIdResponse> => {
  
  return customFetch<Promise<vendorGetMemberByIdResponse>>(getVendorGetMemberByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Updates a member by id for the authenticated vendor.
 * @summary Update a Member
 */
export type vendorUpdateMemberByIdResponse = {
  data: VendorUpdateMemberById200;
  status: number;
  headers: Headers;
}

export const getVendorUpdateMemberByIdUrl = (id: string,) => {


  return `http://localhost:9000/vendor/members/${id}`
}

export const vendorUpdateMemberById = async (id: string,
    vendorUpdateMember: VendorUpdateMember, options?: RequestInit): Promise<vendorUpdateMemberByIdResponse> => {
  
  return customFetch<Promise<vendorUpdateMemberByIdResponse>>(getVendorUpdateMemberByIdUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorUpdateMember,)
  }
);}



/**
 * Deletes a member by id.
 * @summary Delete a Member
 */
export type vendorDeleteMemberByIdResponse = {
  data: VendorDeleteMemberById200;
  status: number;
  headers: Headers;
}

export const getVendorDeleteMemberByIdUrl = (id: string,) => {


  return `http://localhost:9000/vendor/members/${id}`
}

export const vendorDeleteMemberById = async (id: string, options?: RequestInit): Promise<vendorDeleteMemberByIdResponse> => {
  
  return customFetch<Promise<vendorDeleteMemberByIdResponse>>(getVendorDeleteMemberByIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieves a list of orders for the authenticated vendor.
 * @summary List Orders
 */
export type vendorListOrdersResponse = {
  data: VendorListOrders200;
  status: number;
  headers: Headers;
}

export const getVendorListOrdersUrl = (params?: VendorListOrdersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/orders?${normalizedParams.toString()}` : `http://localhost:9000/vendor/orders`
}

export const vendorListOrders = async (params?: VendorListOrdersParams, options?: RequestInit): Promise<vendorListOrdersResponse> => {
  
  return customFetch<Promise<vendorListOrdersResponse>>(getVendorListOrdersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retrieves the details of specified order.
 * @summary Get Order details
 */
export type vendorGetOrderResponse = {
  data: VendorGetOrder200;
  status: number;
  headers: Headers;
}

export const getVendorGetOrderUrl = (id: string,) => {


  return `http://localhost:9000/vendor/orders/${id}`
}

export const vendorGetOrder = async (id: string, options?: RequestInit): Promise<vendorGetOrderResponse> => {
  
  return customFetch<Promise<vendorGetOrderResponse>>(getVendorGetOrderUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Mark order as cancelled.
 * @summary Mark order as cancelled
 */
export type vendorCancelOrderResponse = {
  data: VendorCancelOrder200;
  status: number;
  headers: Headers;
}

export const getVendorCancelOrderUrl = (id: string,) => {


  return `http://localhost:9000/vendor/orders/${id}/cancel`
}

export const vendorCancelOrder = async (id: string, options?: RequestInit): Promise<vendorCancelOrderResponse> => {
  
  return customFetch<Promise<vendorCancelOrderResponse>>(getVendorCancelOrderUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Mark order as complete.
 * @summary Mark order as complete
 */
export type vendorCompleteOrderResponse = {
  data: VendorCompleteOrder200;
  status: number;
  headers: Headers;
}

export const getVendorCompleteOrderUrl = (id: string,) => {


  return `http://localhost:9000/vendor/orders/${id}/complete`
}

export const vendorCompleteOrder = async (id: string, options?: RequestInit): Promise<vendorCompleteOrderResponse> => {
  
  return customFetch<Promise<vendorCompleteOrderResponse>>(getVendorCompleteOrderUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}



/**
 * Retrieves the payout account for the authenticated vendor.
 * @summary Get Payout Account
 */
export type vendorGetPayoutAccountResponse = {
  data: VendorGetPayoutAccount200;
  status: number;
  headers: Headers;
}

export const getVendorGetPayoutAccountUrl = (params?: VendorGetPayoutAccountParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/payout-account?${normalizedParams.toString()}` : `http://localhost:9000/vendor/payout-account`
}

export const vendorGetPayoutAccount = async (params?: VendorGetPayoutAccountParams, options?: RequestInit): Promise<vendorGetPayoutAccountResponse> => {
  
  return customFetch<Promise<vendorGetPayoutAccountResponse>>(getVendorGetPayoutAccountUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Creates a payout account for the authenticated vendor.
 * @summary Create Payout Account
 */
export type vendorCreatePayoutAccountResponse = {
  data: VendorCreatePayoutAccount201;
  status: number;
  headers: Headers;
}

export const getVendorCreatePayoutAccountUrl = () => {


  return `http://localhost:9000/vendor/payout-account`
}

export const vendorCreatePayoutAccount = async (vendorCreatePayoutAccount: VendorCreatePayoutAccount, options?: RequestInit): Promise<vendorCreatePayoutAccountResponse> => {
  
  return customFetch<Promise<vendorCreatePayoutAccountResponse>>(getVendorCreatePayoutAccountUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorCreatePayoutAccount,)
  }
);}



/**
 * Creates an onboarding for the authenticated vendor's payout account.
 * @summary Create Onboarding
 */
export type vendorCreateOnboardingResponse = {
  data: VendorCreateOnboarding200;
  status: number;
  headers: Headers;
}

export const getVendorCreateOnboardingUrl = () => {


  return `http://localhost:9000/vendor/payout-account/onboarding`
}

export const vendorCreateOnboarding = async (vendorCreateOnboarding: VendorCreateOnboarding, options?: RequestInit): Promise<vendorCreateOnboardingResponse> => {
  
  return customFetch<Promise<vendorCreateOnboardingResponse>>(getVendorCreateOnboardingUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorCreateOnboarding,)
  }
);}



/**
 * Retrieves a list of products for the authenticated vendor.
 * @summary List Products
 */
export type vendorListProductsResponse = {
  data: VendorListProducts200;
  status: number;
  headers: Headers;
}

export const getVendorListProductsUrl = (params?: VendorListProductsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/products?${normalizedParams.toString()}` : `http://localhost:9000/vendor/products`
}

export const vendorListProducts = async (params?: VendorListProductsParams, options?: RequestInit): Promise<vendorListProductsResponse> => {
  
  return customFetch<Promise<vendorListProductsResponse>>(getVendorListProductsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Creates a new product for the authenticated vendor.
 * @summary Create a Product
 */
export type vendorCreateProductResponse = {
  data: VendorCreateProduct201;
  status: number;
  headers: Headers;
}

export const getVendorCreateProductUrl = () => {


  return `http://localhost:9000/vendor/products`
}

export const vendorCreateProduct = async (vendorCreateProduct: VendorCreateProduct, options?: RequestInit): Promise<vendorCreateProductResponse> => {
  
  return customFetch<Promise<vendorCreateProductResponse>>(getVendorCreateProductUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorCreateProduct,)
  }
);}



/**
 * Retrieves a product by id for the authenticated vendor.
 * @summary Get a Product
 */
export type vendorGetProductByIdResponse = {
  data: VendorGetProductById200;
  status: number;
  headers: Headers;
}

export const getVendorGetProductByIdUrl = (id: string,
    params?: VendorGetProductByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/products/${id}?${normalizedParams.toString()}` : `http://localhost:9000/vendor/products/${id}`
}

export const vendorGetProductById = async (id: string,
    params?: VendorGetProductByIdParams, options?: RequestInit): Promise<vendorGetProductByIdResponse> => {
  
  return customFetch<Promise<vendorGetProductByIdResponse>>(getVendorGetProductByIdUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Updates an existing product for the authenticated vendor.
 * @summary Update a Product
 */
export type vendorUpdateProductByIdResponse = {
  data: VendorUpdateProductById200;
  status: number;
  headers: Headers;
}

export const getVendorUpdateProductByIdUrl = (id: string,
    params?: VendorUpdateProductByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/products/${id}?${normalizedParams.toString()}` : `http://localhost:9000/vendor/products/${id}`
}

export const vendorUpdateProductById = async (id: string,
    vendorUpdateProduct: VendorUpdateProduct,
    params?: VendorUpdateProductByIdParams, options?: RequestInit): Promise<vendorUpdateProductByIdResponse> => {
  
  return customFetch<Promise<vendorUpdateProductByIdResponse>>(getVendorUpdateProductByIdUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorUpdateProduct,)
  }
);}



/**
 * Deletes a product by id for the authenticated vendor.
 * @summary Delete a Product
 */
export type vendorDeleteProductByIdResponse = {
  data: VendorDeleteProductById200;
  status: number;
  headers: Headers;
}

export const getVendorDeleteProductByIdUrl = (id: string,) => {


  return `http://localhost:9000/vendor/products/${id}`
}

export const vendorDeleteProductById = async (id: string, options?: RequestInit): Promise<vendorDeleteProductByIdResponse> => {
  
  return customFetch<Promise<vendorDeleteProductByIdResponse>>(getVendorDeleteProductByIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Updates an existing product for the authenticated vendor.
 * @summary Update a Product
 */
export type vendorCreateFulfillmentResponse = {
  data: VendorCreateFulfillment200;
  status: number;
  headers: Headers;
}

export const getVendorCreateFulfillmentUrl = (id: string,) => {


  return `http://localhost:9000/vendor/products/${id}/fulfillment`
}

export const vendorCreateFulfillment = async (id: string,
    vendorCreateFulfillment: VendorCreateFulfillment, options?: RequestInit): Promise<vendorCreateFulfillmentResponse> => {
  
  return customFetch<Promise<vendorCreateFulfillmentResponse>>(getVendorCreateFulfillmentUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorCreateFulfillment,)
  }
);}



/**
 * Creates a new seller with an initial owner member.
 * @summary Create a Seller
 */
export type vendorCreateSellerResponse = {
  data: VendorCreateSeller201;
  status: number;
  headers: Headers;
}

export const getVendorCreateSellerUrl = () => {


  return `http://localhost:9000/vendor/sellers`
}

export const vendorCreateSeller = async (vendorCreateSeller: VendorCreateSeller, options?: RequestInit): Promise<vendorCreateSellerResponse> => {
  
  return customFetch<Promise<vendorCreateSellerResponse>>(getVendorCreateSellerUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorCreateSeller,)
  }
);}



/**
 * Retrieves the seller associated with the authenticated user.
 * @summary Get Current Seller
 */
export type vendorGetSellerMeResponse = {
  data: VendorGetSellerMe200;
  status: number;
  headers: Headers;
}

export const getVendorGetSellerMeUrl = () => {


  return `http://localhost:9000/vendor/sellers/me`
}

export const vendorGetSellerMe = async ( options?: RequestInit): Promise<vendorGetSellerMeResponse> => {
  
  return customFetch<Promise<vendorGetSellerMeResponse>>(getVendorGetSellerMeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Updates the seller associated with the authenticated user.
 * @summary Update Current Seller
 */
export type vendorUpdateSellerMeResponse = {
  data: VendorUpdateSellerMe200;
  status: number;
  headers: Headers;
}

export const getVendorUpdateSellerMeUrl = () => {


  return `http://localhost:9000/vendor/sellers/me`
}

export const vendorUpdateSellerMe = async (vendorUpdateSeller: VendorUpdateSeller, options?: RequestInit): Promise<vendorUpdateSellerMeResponse> => {
  
  return customFetch<Promise<vendorUpdateSellerMeResponse>>(getVendorUpdateSellerMeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorUpdateSeller,)
  }
);}



/**
 * Retrieves a list of Shipping Options for a Service Zone.
 * @summary List Shipping Options
 */
export type vendorListShippingOptionsResponse = {
  data: VendorListShippingOptions200;
  status: number;
  headers: Headers;
}

export const getVendorListShippingOptionsUrl = (id: string,) => {


  return `http://localhost:9000/vendor/service-zones/${id}/shipping-options`
}

export const vendorListShippingOptions = async (id: string, options?: RequestInit): Promise<vendorListShippingOptionsResponse> => {
  
  return customFetch<Promise<vendorListShippingOptionsResponse>>(getVendorListShippingOptionsUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Creates a Shipping Option for a Service Zone.
 * @summary Create a Shipping Option
 */
export type vendorCreateShippingOptionResponse = {
  data: VendorCreateShippingOption201;
  status: number;
  headers: Headers;
}

export const getVendorCreateShippingOptionUrl = (id: string,) => {


  return `http://localhost:9000/vendor/service-zones/${id}/shipping-options`
}

export const vendorCreateShippingOption = async (id: string,
    vendorCreateShippingOption: VendorCreateShippingOption, options?: RequestInit): Promise<vendorCreateShippingOptionResponse> => {
  
  return customFetch<Promise<vendorCreateShippingOptionResponse>>(getVendorCreateShippingOptionUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorCreateShippingOption,)
  }
);}



/**
 * Retrieves a Shipping Option by its ID.
 * @summary Get a Shipping Option
 */
export type vendorGetShippingOptionByIdResponse = {
  data: VendorGetShippingOptionById200;
  status: number;
  headers: Headers;
}

export const getVendorGetShippingOptionByIdUrl = (id: string,) => {


  return `http://localhost:9000/vendor/shipping-options/${id}`
}

export const vendorGetShippingOptionById = async (id: string, options?: RequestInit): Promise<vendorGetShippingOptionByIdResponse> => {
  
  return customFetch<Promise<vendorGetShippingOptionByIdResponse>>(getVendorGetShippingOptionByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Updates a Shipping Option.
 * @summary Update a Shipping Option
 */
export type vendorUpdateShippingOptionByIdResponse = {
  data: VendorUpdateShippingOptionById200;
  status: number;
  headers: Headers;
}

export const getVendorUpdateShippingOptionByIdUrl = (id: string,) => {


  return `http://localhost:9000/vendor/shipping-options/${id}`
}

export const vendorUpdateShippingOptionById = async (id: string,
    vendorUpdateShippingOption: VendorUpdateShippingOption, options?: RequestInit): Promise<vendorUpdateShippingOptionByIdResponse> => {
  
  return customFetch<Promise<vendorUpdateShippingOptionByIdResponse>>(getVendorUpdateShippingOptionByIdUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorUpdateShippingOption,)
  }
);}



/**
 * Deletes a Shipping Option.
 * @summary Delete a Shipping Option
 */
export type vendorDeleteShippingOptionByIdResponse = {
  data: VendorDeleteShippingOptionById200;
  status: number;
  headers: Headers;
}

export const getVendorDeleteShippingOptionByIdUrl = (id: string,) => {


  return `http://localhost:9000/vendor/shipping-options/${id}`
}

export const vendorDeleteShippingOptionById = async (id: string, options?: RequestInit): Promise<vendorDeleteShippingOptionByIdResponse> => {
  
  return customFetch<Promise<vendorDeleteShippingOptionByIdResponse>>(getVendorDeleteShippingOptionByIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retrieves a list of Stock Locations.
 * @summary List Stock Locations
 */
export type vendorListStockLocationsResponse = {
  data: VendorListStockLocations200;
  status: number;
  headers: Headers;
}

export const getVendorListStockLocationsUrl = (params?: VendorListStockLocationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/stock-locations?${normalizedParams.toString()}` : `http://localhost:9000/vendor/stock-locations`
}

export const vendorListStockLocations = async (params?: VendorListStockLocationsParams, options?: RequestInit): Promise<vendorListStockLocationsResponse> => {
  
  return customFetch<Promise<vendorListStockLocationsResponse>>(getVendorListStockLocationsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Creates a Stock Location.
 * @summary Create a Stock Location
 */
export type vendorCreateStockLocationResponse = {
  data: VendorCreateStockLocation201;
  status: number;
  headers: Headers;
}

export const getVendorCreateStockLocationUrl = (params?: VendorCreateStockLocationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/stock-locations?${normalizedParams.toString()}` : `http://localhost:9000/vendor/stock-locations`
}

export const vendorCreateStockLocation = async (vendorCreateStockLocation: VendorCreateStockLocation,
    params?: VendorCreateStockLocationParams, options?: RequestInit): Promise<vendorCreateStockLocationResponse> => {
  
  return customFetch<Promise<vendorCreateStockLocationResponse>>(getVendorCreateStockLocationUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorCreateStockLocation,)
  }
);}



/**
 * Retrieves a Stock Location by id.
 * @summary Get Stock Location
 */
export type vendorGetStockLocationResponse = {
  data: VendorGetStockLocation200;
  status: number;
  headers: Headers;
}

export const getVendorGetStockLocationUrl = (id: string,
    params?: VendorGetStockLocationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/stock-locations/${id}?${normalizedParams.toString()}` : `http://localhost:9000/vendor/stock-locations/${id}`
}

export const vendorGetStockLocation = async (id: string,
    params?: VendorGetStockLocationParams, options?: RequestInit): Promise<vendorGetStockLocationResponse> => {
  
  return customFetch<Promise<vendorGetStockLocationResponse>>(getVendorGetStockLocationUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Updates a Stock Location.
 * @summary Update Stock Location
 */
export type vendorUpdateStockLocationResponse = {
  data: VendorUpdateStockLocation200;
  status: number;
  headers: Headers;
}

export const getVendorUpdateStockLocationUrl = (id: string,
    params?: VendorUpdateStockLocationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/stock-locations/${id}?${normalizedParams.toString()}` : `http://localhost:9000/vendor/stock-locations/${id}`
}

export const vendorUpdateStockLocation = async (id: string,
    vendorUpdateStockLocation: VendorUpdateStockLocation,
    params?: VendorUpdateStockLocationParams, options?: RequestInit): Promise<vendorUpdateStockLocationResponse> => {
  
  return customFetch<Promise<vendorUpdateStockLocationResponse>>(getVendorUpdateStockLocationUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorUpdateStockLocation,)
  }
);}



/**
 * Updates the fulfillment providers of a Stock Location.
 * @summary Update Stock Location Fulfillment Providers
 */
export type vendorUpdateStockLocationFulfillmentProvidersResponse = {
  data: VendorUpdateStockLocationFulfillmentProviders200;
  status: number;
  headers: Headers;
}

export const getVendorUpdateStockLocationFulfillmentProvidersUrl = (id: string,
    params?: VendorUpdateStockLocationFulfillmentProvidersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/stock-locations/${id}/fulfillment-providers?${normalizedParams.toString()}` : `http://localhost:9000/vendor/stock-locations/${id}/fulfillment-providers`
}

export const vendorUpdateStockLocationFulfillmentProviders = async (id: string,
    vendorUpdateStockLocationFulfillmentProvidersBody: VendorUpdateStockLocationFulfillmentProvidersBody,
    params?: VendorUpdateStockLocationFulfillmentProvidersParams, options?: RequestInit): Promise<vendorUpdateStockLocationFulfillmentProvidersResponse> => {
  
  return customFetch<Promise<vendorUpdateStockLocationFulfillmentProvidersResponse>>(getVendorUpdateStockLocationFulfillmentProvidersUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorUpdateStockLocationFulfillmentProvidersBody,)
  }
);}



/**
 * Creates a Fulfillment Set for a Stock Location.
 * @summary Create a Fulfillment Set
 */
export type vendorCreateStockLocationFulfillmentSetResponse = {
  data: VendorCreateStockLocationFulfillmentSet200;
  status: number;
  headers: Headers;
}

export const getVendorCreateStockLocationFulfillmentSetUrl = (id: string,
    params?: VendorCreateStockLocationFulfillmentSetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/stock-locations/${id}/fulfillment-sets?${normalizedParams.toString()}` : `http://localhost:9000/vendor/stock-locations/${id}/fulfillment-sets`
}

export const vendorCreateStockLocationFulfillmentSet = async (id: string,
    vendorCreateStockLocationFulfillmentSet: VendorCreateStockLocationFulfillmentSet,
    params?: VendorCreateStockLocationFulfillmentSetParams, options?: RequestInit): Promise<vendorCreateStockLocationFulfillmentSetResponse> => {
  
  return customFetch<Promise<vendorCreateStockLocationFulfillmentSetResponse>>(getVendorCreateStockLocationFulfillmentSetUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorCreateStockLocationFulfillmentSet,)
  }
);}



/**
 * Updates the sales channels of a Stock Location.
 * @summary Update Stock Location Sales Channels
 */
export type vendorUpdateStockLocationSalesChannelsResponse = {
  data: VendorUpdateStockLocationSalesChannels200;
  status: number;
  headers: Headers;
}

export const getVendorUpdateStockLocationSalesChannelsUrl = (id: string,
    params?: VendorUpdateStockLocationSalesChannelsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:9000/vendor/stock-locations/${id}/sales-channels?${normalizedParams.toString()}` : `http://localhost:9000/vendor/stock-locations/${id}/sales-channels`
}

export const vendorUpdateStockLocationSalesChannels = async (id: string,
    vendorUpdateStockLocationSalesChannelsBody: VendorUpdateStockLocationSalesChannelsBody,
    params?: VendorUpdateStockLocationSalesChannelsParams, options?: RequestInit): Promise<vendorUpdateStockLocationSalesChannelsResponse> => {
  
  return customFetch<Promise<vendorUpdateStockLocationSalesChannelsResponse>>(getVendorUpdateStockLocationSalesChannelsUrl(id,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendorUpdateStockLocationSalesChannelsBody,)
  }
);}



